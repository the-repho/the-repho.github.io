<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="keywords" content="OI">
<meta property="og:type" content="website">
<meta property="og:title" content="Repho&#39;s blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Repho&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Repho's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Repho's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">The coding life...</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="repho">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Repho's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">8.20 模拟赛  题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-01 00:50:13 / 修改时间：12:09:59" itemprop="dateCreated datePublished" datetime="2019-11-01T00:50:13+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Glo"><a href="#Glo" class="headerlink" title="Glo"></a>Glo</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/glo.png" class title="glo">

<h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>一看是一个最长上升子序列，只是带一点特殊的东西，再一看数据范围，根据已学知识要用单调栈搞一个 $\log$ 算法差不多能过。</p>
<p>然后开始看那个特殊的区间加操作。然后发现如果把一个区间加向后面拓展成后缀加，答案一定是不劣的，同理区间减扩展成前缀减。进一步我们发现最长上升子序列关心的只是他们之间的差值，所以数值本身意义不大，因此前缀减可以等效成后缀加，那么现在的问题就变成了要给一个后缀加上一个数之后的最长上升子序列了。</p>
<p>然后我考虑单调栈的做法，就是维护一个当前的上升子序列长度为 $x$ 的一个最小值，然后找到刚好比自己大的位置插进去，并更新答案。所以我的想法就是与此同时也在一个后缀的栈里面找到 $x-k$ 的位置，用那里的后缀最长下降子序列更新总的答案。但是这个栈是没办法回退的，所以我发现不能预处理一遍后缀栈然后在做前缀的时候退出上一位的影响。那就只能暴力做这里的栈了，这个做法要么时间爆炸要么空间爆炸。而我也没有什么进一步思路了。</p>
<p>看看部分分。</p>
<h4 id="k-0"><a href="#k-0" class="headerlink" title="$k=0$"></a>$k=0$</h4><p>这个就是普通的最长上升子序列。直接做。</p>
<h4 id="k-1e9-infin"><a href="#k-1e9-infin" class="headerlink" title="$k=1e9( \infin)$"></a>$k=1e9( \infin)$</h4><p>这个已经不需要考虑 $x-k$ 在哪了，所有的后缀都能满足了。那直接正反求一遍，然后在中间用前后缀更新答案。</p>
<p>出分：$10pt.$ ？？？它 $subtask???$ 稍微改了改救回 $33.$ </p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>上面的做法已经离得很近了。在处理前缀的时候，我们可以直接把那个值的答案记下来。就是那个前缀 $x$ 处的最长上升子序列，那么前缀上就必须大于 $x + k$。然后我们再倒着看，只要在每个地方加了之后在之前里面的答案中更新即可。具体而言就是：</p>
<p>记录一个 $f_i$ 表示在 $1 \to a_i$ 前缀上严格以 $a_i+k$ 结尾的最长上升子序列。那么在倒着做的时候，只需要在栈里面找 $a_i$ 的答案 $f_i$。</p>
<p>这个可以用单调栈实现，但是这次学会了另一种求最长上升子序列的方法：在值域上维护区间最大值。因为每一次要的是结尾比 $a_i$ 小的最长上升子序列，所以相当于求一个值域前缀 $\max.$ 这个离散化之后用线段树或者树状数组维护即可。也是一个 $\log$ 的。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/2dnt4nTXrg/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/2dnt4nTXrg/</a></p>
<h1 id="Mobitel"><a href="#Mobitel" class="headerlink" title="Mobitel"></a>Mobitel</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/mobitel.png" class title="mobitel">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>没想到用 $dp.$ 写的爆搜加小剪枝，因为发现当大于的时候后面的方案数可以用组合数算了，就直接剪掉了。</p>
<p>出分：$10pt.$ </p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>$dp.$ 因为大于 $n$ 没什么限制条件不好做，所以我们转化一下，转化成用整个的（也是一个组合数）减去小于 $n$ 的方案数，因此这个就可以 $dp$ 了。</p>
<p>设 $f_{i,<del>j,</del>m}$ 表示现在走到 $(i,<del>j)$ 乘积是 $m$ 的方案数。然后转移转移到 $(i+1,</del>j)$ 和 $(i,~j+1)$ 即可。这个复杂度是 $O(rsn)$ 的，肯定爆炸了。</p>
<p>所以考虑进一步转化，优化一下状态。因为发现最后能用到的空间其实是 $\large\frac{rest}{a_{i,<del>j}}$ ，而 $\large\frac n x$ 的个数又只有 $2\sqrt n$ 个 ，所以可以把状态优化成 $f_{i,</del>j,<del>m}$ 表示走到 $(i,</del>j)$ 还剩下 $m$ 给我们除。还是上面的转移，就可以继续做了。时间复杂度对了，但是发现空间炸了啊？能滚动吗？可以哦。每一次的值只和上一层有关，只要记这两层的就好了。</p>
<p>另外还有一个细节就是他要求的是大于等于 $n$ 的路径积方案数，所以求因子的时候注意要先 $n–.$</p>
<p><del>模数是 $1e9+7$ 不是 $998244353$！！！</del></p>
<p>$code:$  <a href="https://paste.ubuntu.com/p/qCc4dyDV4s/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/qCc4dyDV4s/</a></p>
<h1 id="Lottery"><a href="#Lottery" class="headerlink" title="Lottery"></a>Lottery</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/lottery.png" class title="lottery">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>只想到了 $n^3$ 转移的暴力。<del>其实是只去肝第一题了。。</del></p>
<p>出分：$25pt.$ </p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>首先 $n^2$ 就有一个很<del>巧妙</del>简单的转移：可以通过去掉左边端点上的两个加上右边端点上的两个点，来实现同一长度的区间从左向右的移动 $O(1)$ 得到答案。然后发现 $n=1e4?$ $O(n^2)$ 预处理好像能过。</p>
<p>但是发现空间开的很小，所以需要优化一下空间。如果直接开 $1e4\times 1e4$ 的数组要几个 $GB$ 内存啊。然后询问很少啊？</p>
<p>那就说明没有询问到的长度是无效的。所以可以先把询问离线下来，去个重编个号每次只要记每个数询问处的答案即可。</p>
<p>具体实现类似一个离散化吧。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/VtcCv5R4dp/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/VtcCv5R4dp/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/8.18%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="repho">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Repho's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/8.18%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">8.18 模拟赛  题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-01 00:49:23 / 修改时间：01:14:51" itemprop="dateCreated datePublished" datetime="2019-11-01T00:49:23+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>比赛真的变简单了好多呢。</p>
<h1 id="Backpack"><a href="#Backpack" class="headerlink" title="Backpack"></a>Backpack</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.18 模拟赛 题解/backpack.png" title="backpack">

<h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>首先想了一个贪心。（部分背包类似，把所有物品按照一个性价比排序。）</p>
<p>然后黑了自己。</p>
<p>然后开始 $dp$ ，发现是一个 $O(nm).$ ：</p>
<p>​    $\Large dp_j=\max\{dp_{j-w_i}+v_i\}.$</p>
<p>搞完后面的之后回头来看，发现 $a,<del>b$ 的范围只有 $[1,</del>100]$，那可以考虑做一个桶，把 $a$ 一样的物品只存它们的 $\max v.$</p>
<p>然后就得到了一个 $O(m\max a)$ 的算法，能拿 $60pt.$ 稍微考虑了一下矩乘但是好像不太好写就没管了。</p>
<p>出分： $60pt.$ </p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><h4 id="贪心。？？"><a href="#贪心。？？" class="headerlink" title="贪心。？？"></a>贪心。？？</h4><p>没错，一开始的类似部分背包的贪心有一定的正确性。可以大概的猜到，最优解里面一定会有很大一部分用性价比最大的物品组成的。所以我们考虑剩下多少贪心不一定正确。</p>
<p>首先在任意的 $n$ 个数中，一定有某些数之和是 $n$ 的倍数。证明方法考虑它们的 $n+1$ 个前缀和，由抽屉原理，一定有两个在模 $n$ 意义下同余。所以他们之差所对应的区间的数之和一定是 $n$ 的倍数。</p>
<p>如此一来，只要留下 $a_s$ 个数即可，不然可以通过用 $s$ 替换里面的若干个和是 $a_s$ 的倍数的物品，这样肯定会更优。（ $s$ 即为性价比最高的物品。）</p>
<p>这样把剩下的很少的物品做一个 $dp$ 即可。</p>
<p>$code:$ </p>
<h4 id="矩乘！"><a href="#矩乘！" class="headerlink" title="矩乘！"></a>矩乘！</h4><p>看这个 $m$ 的范围应该可以大概想到矩乘优化一下 $DP.$ 那么就是考虑怎么做转移矩阵了。</p>
<p>那么我们考虑现在的答案会从前面的哪里转移过来，用多少代价。我们发现，我们在 $i$ 的时候，会从所有的 $i-w_j$ 转移过来，并且答案是 $\max\{f_i+v_j\}.$ 所以就可以考虑构建一个 $100\times100$ 的矩阵，每次乘法是做的加法取 $\max.$ 那么矩阵具体应该是什么样的呢？</p>
<p>那么我们考虑从 $\large f_{i-k+1}\to f_i$ 转移到 $\large f_{i-k + 2}\to f_{i+1}.$ （其中 $k=\max\{w_i,~v_i\}$）首先，之前的后 $k-1$ 项和之后的前 $k-1$ 项是要相同的，考虑到是加法取 $\max$ ，可以只算矩阵中非 $-1$ 的数，并把对应斜对角线赋为 $0.$ 这样可以保证前 $k-1$ 项了。那么最后一行的矩阵就是直接和转移方程挂钩了。那么就是在所有的 $w_i$ 的位置上赋 $v_i$ 的值即可。其他空位赋 $-1.$ </p>
<p>完整矩阵如下图：（最后一行假定被所有物品填满了，且 $w_i=i.$）</p>
<p>​                                                             $\large\left[\begin{matrix} -1 &amp; 0&amp;-1&amp;\cdots &amp;-1&amp;-1\-1&amp;-1&amp;0&amp;\cdots&amp;-1&amp;-1\\\vdots&amp;\vdots &amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\-1&amp;-1&amp;-1&amp;\cdots&amp;0&amp;-1\-1&amp;-1&amp;-1&amp;\cdots&amp;-1&amp;0\\v_1&amp;v_2&amp;v_3&amp;\cdots&amp;v_{k-1}&amp;v_k\end{matrix}\right]$ </p>
<p>那么用它自乘再预处理前 $k$ 个就可以矩乘了。</p>
<p>$code:$ </p>
<h1 id="Median"><a href="#Median" class="headerlink" title="Median"></a>Median</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.18 模拟赛 题解/median.png" title="median">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>不知道是什么时候无意中看到了这道题的算法。但是没什么印象了，大概记得是二分吧。</p>
<p>所以首先我考虑在一个上面二分，然后每次在另一个上面 $lower_bound$ 出它的位置，加起来就可以知道它在合并之后的序列中的位置，复杂度就是 $O(n\log^2n).$ </p>
<p>但是出题人好像卡了两个 $\log$ 的算法。。只有暴力分。</p>
<p>所以要更优秀的算法了。我们仍然考虑二分，但方式不同了。由上面的我们可以联想到，那前一半的数大概分布是一边多一边少的（废话。。），那么我们不就可以每一次扔掉多的那部分里面的一些吗？那么为了尽量优，我们可以考虑每次丢一半，这样就能做到一个 $\log$ 啦。具体而言是这样的：</p>
<p>假设我们现在还要选的数的个数是 $p$ ，那么我们可以分别在两个序列里面取第 $\large \frac{p}{2}$ 个，然后比较一下它们的值，可以发现那个更小的一定被那更多的一边覆盖住了，所以就可以丢掉它了。这样规模减少了一半。直到一遍被删完之后，就可以直接在另一边的里面找到答案了。</p>
<p><strong>注意：上面说的更多一点其实是有问题的，仅用来理解这个算法的正确性。当一边的数分散在两极的时候，可能这边的少些，但是仍然要删它了。</strong></p>
<p>出分：$100pt.$ </p>
<p>$code: $ </p>
<h1 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.18 模拟赛 题解/sequence.png" title="sequence">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>我是怎么都没看出来它是一个积性函数。（因为在此之前我的认知是所有数都要有 $f(x)f(y)=f(xy).$）</p>
<p>然后写的爆搜。</p>
<p>出分： $10pt.$ </p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>没错，这应该是一个积性函数。因为如果两个数互质，那么他们和 $B$ 的 $\gcd$ 一定是互不相关，因此由乘法原理，它们乘起来的总方案数就是答案。（也就是没有重叠的多余部分被计算了。）</p>
<p>那么看着这个数据范围，就可以试一下欧拉筛了。（前面模拟赛的时候考过学过。）</p>
<p>首先考虑 $f(p^c)$ 怎么做。因为最后贡献要和 $B$ 取 $\gcd$ 所以这个一定和 $B$ 中的 $p$ 个数有关。那么考虑 $B$ 质因数分解后 $p$ 的指数是 $k.$ </p>
<p>那么对于 $A=p^c$ ，我们需要分两类讨论：$c&gt;k$ 与 $c\le k.$ 对于第二类，我们可以枚举所有 $a$ 中最小的次数 $i\leq c$ 每一次用 $p$ 的次数大于等于 $i$ 的所有数的可能情况 $(c-i+1)^n$ 减去大于等于 $i+1$ 的情况就能得到至少有一个最小值次数是等于 $i$ 的情况了，而这些整个要乘上它们的贡献，也就是 $\gcd(a_1,<del>\dots,</del>a_n,~B)$ 也就是 $p^c$ 了。而对于第二类，因为总的次数不能超过 $k$ ，所以 $c$ 超过的部分是没有贡献的，或者说贡献仍然只有 $p^k$，所以我们只需要枚举到 $k$ ，超过的部分直接用一个表示超过取值 $c\to k$ 的整个式子就好了，它们的贡献上面也说了，就是 $p^k$。具体就是：</p>
<p>​                            $\large\begin{equation}<br>\begin{aligned}    f(p^c)=<br>\begin{cases}<br>c\leq k&amp;&amp;&amp;\sum\limits_{i=1}^c ((c-i+1)^n-(c-i)^n)p^i.\\<br>c &gt; k &amp;&amp;&amp; \sum\limits_{i=1}^k ((c-i+1)^n-(c-i)^n)p^i<del>+</del>p^k(c-k)^n.<br>\end{cases}<br>\end{aligned}\end{equation}$ </p>
<p>那么实现起来就是以前的欧拉筛模板，有一点区别的就是当 $i$ 是一个合数的最小质因子的时候，我们就要另外用他这个最小质因子的整个次数去乘了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/fqgyRVMfdR/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/fqgyRVMfdR/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/8.17%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="repho">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Repho's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/8.17%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">8.17 模拟赛  题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-01 00:48:54 / 修改时间：01:14:53" itemprop="dateCreated datePublished" datetime="2019-11-01T00:48:54+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Slope"><a href="#Slope" class="headerlink" title="Slope"></a>Slope</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.17 模拟赛 题解/slope.png" title="slope">

<h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>首先读了下题，题意是找出斜率最接近 $\large\frac{P}{Q}$ 过两点直线的斜率·。</p>
<p>那么直接看一下一条直线的斜率和 $\large \frac{P}{Q}$ 的差是什么：</p>
<p>​    $\Large \Delta=|\frac{P}{Q}-\frac{y_1-y_2}{x_1-x_2}|=|\frac{P(x_1-x_2)-Q(y_1-y_2)}{Q(x_1-x_2)}|=\frac 1 Q|\frac{(Px_1-Qy_1)-(Px_2-Qy_2)}{x_1-x_2}|.$ </p>
<p>当我们转化成这样的时候，就发现分子上的部分括号内的只与某一个点有关.</p>
<p>那么对于每一个点，就可以记 $\large w_i=Px_1-Qy_1$ ，那么这里的 $\Delta$ 在忽略前面的常数之后就相当于：</p>
<p>​    $\Large \Delta = |\frac{w_1-w_2}{x_1-x_2}|.$ </p>
<p>这个式子的形式也可以看作是过两个点的直线的斜率了。我们问题就转化成求过两点的直线的斜率的绝对值最小。</p>
<p>这个问题就好求了，直接将所有点按照 $w_i$ 排序，然后只需要考虑每个点后面的那个和它相邻的点统计答案即可。</p>
<p>为什么呢？首先他前面的点跟他统计过一次答案了，所以只需要统计后面的。那么为什么在排序之后答案是最优的呢？考虑点 $i$，那么记它和 $i+1$ 连成的直线的斜率是 $k$ （不妨设两点间斜率均大于零），那么如果 $j$ 和 $i$ 有更优的答案，我们发现 $i+1$ 和 $j$ 会更优，证明如下：（其实画图很好理解）</p>
<p>​        不妨设 $i:(0,<del>0),</del> i+1:(x_1,<del>y_1), ~j:(x_2, ~y_2).$ 那么有：<br>​         $\Large</del>\frac{y_1}{x_1}&gt;\frac{y_2}{x_2}\\\therefore y_1x_2&gt;x_1y_2\\\therefore y_1x_2-x_1y_1&gt;x_1y_2-x_1y_1\\\therefore (x_2-x_1)y_1&gt;(y_2-y_1)x_1\\\therefore \Large\frac{y_1}{x_1}&gt;\frac{y_2-y_1}{x_2-x_1}$<br>​        得证。</p>
<p>程序就记一下如果相等取 $k$ 的 $\min$ 就好了。</p>
<p>出分：$100pt.$</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/MVB39949PK/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/MVB39949PK/</a></p>
<h1 id="Min"><a href="#Min" class="headerlink" title="Min"></a>Min</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.17 模拟赛 题解/min.png" title="min">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>第一次讲课讲 $DP$ 的时候好像说过很多种这一类题，那么考虑一个朴素的 $DP.$ </p>
<p>$f_i$ 表示最后一个区间以 $i$ 结尾的答案，那么转移就枚举最后一个区间左端点即可。具体就是：</p>
<p>​    $\Large f_i=\max\limits_{j=0}^{i-1}f_j+F(\min\limits_{k=j+1}^{i} a_k).$</p>
<p>然后就是区间最小值了， $ST$ 表即可。</p>
<p>对于那个特殊条件，对于样例稍加改动看了看函数值，发现这个时候只有当前一个数能自成一段时转移，否则跟前面合并。</p>
<p>出分：$20pt.$ 暴力挂了。不知道为什么。</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>因为只需要求之前的，并且右端点严格递增的区间最小值，因此可以用一个单调线性数据结构维护，考虑到没有对长度的限制，所以用单调栈维护就好。每一次只要维护一个位置的关键字即可。那么我们考虑答案在哪里。</p>
<p>首先答案如果是在栈上面维护的点之外的地方，那么肯定可以在它靠右的最近的一个点上有不劣的答案。那么我们只需要在关键点上更新信息就好。那么我们可以考虑维护每两个相邻关键点中间的区间中的 $f$ 值，而在不断弹出栈顶的时候可以一起记下他们的 $f$ 来继承他们的贡献。因为我们设的 $f$ 是一个前缀的答案，所以可以直接用栈顶来更新当前的 $f_i$，需要注意的是这个点单独成一个区间也需要考虑。</p>
<p>那么写起来就较为容易了。整体而言不算是很难的 $dp$ 优化，但是细节很多了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/wGNYdXZg65/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/wGNYdXZg65/</a></p>
<h1 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.17 模拟赛 题解/swap.png" title="swap">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>是一道有趣的题目，一开始的想法是找逆序对然后直接暴力交换，开始写的时候发现不好写。。</p>
<p>然后随便糊了一个特别慢的东西。就交了。</p>
<p>出分：$0pt.$</p>
<p>其实逆序对是可以搞的啊，只要把$B$ 关于 $A$ 类似离散化一下就好了啊。。没想到吧。</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>神奇的做法。</p>
<p>首先他说的交换好像很玄学，所以只需要考虑两两交换即可。<del>那你说什么最大最小值。。</del> </p>
<p>那么因为是两两交换，所以交换是可逆的，因此可以通过把 $A,~B$ 变成有序的，再把变换 $B$ 的序列反过来即可。</p>
<p>现在要求的就是多少次交换之后能够让整个变得有序了。什么排序算法呢？<del>冒泡</del>，快排，归并，堆？</p>
<p>快排的交换好像无法实现，堆就不说了。那考虑归并排序。</p>
<p>分治就普通分治就好，关键是怎么合并。假设我们已经有了两个有序的序列，现在就是要把它们合成一个。</p>
<p>出题人的想法很神奇。我们先让问题好描述一点。对于两个有序序列 $A,<del>B$ 需要让他们通过交换操作变得有序。这里大概借用快排的思想，就是用一个基准数 $x$。找出一个 $x$ 之后，在 $A$ 中找出所有的比它大的序列，拎出来，$B$ 中比它小的序列，拎出来。然后我们发现问题又分半：$A$ 的剩下部分和 $B$ 拿出来的部分都 $&lt;x$ ，剩下两部分都 $&gt;x$ 。但是还有问题：他们不挨着。那么交换就上场了，我们可以通过首尾的交换把 $A,</del>B$ 拿出来的部分分别反转，然后再整个翻转他们两个大区间，（通过选首尾的区间慢慢向中间选，具体可以画图。）这样两部分相互分开了，而内部就连在一起了，这样两边再分治下去，最后再连起来，就是一个有序的序列了。</p>
<p>复杂度呢？因为每一次合并的复杂度也需要分治，每一次翻转是 $O(n)$ 所以单次合并是 $O(n\log n)$ ，所以总复杂度是 $O(n\log^2n)$ 的。对于 $4096$ 的数据 $345678$ 就够了。</p>
<p>$code:$ </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/8.15%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="repho">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Repho's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/8.15%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">8.15 模拟赛  题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-01 00:48:44 / 修改时间：01:14:58" itemprop="dateCreated datePublished" datetime="2019-11-01T00:48:44+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vote"><a href="#Vote" class="headerlink" title="Vote"></a>Vote</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.15 模拟赛 题解/Vote.png" title="Vote">

<h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>一开始觉得应该是越靠近旁边的越容易被选上，但是写了一个小程序一看不太对。发现已选一定人之后怎么求出他们中的贡献是一定要求的所以开始推这个式子。</p>
<p>首先考虑 $f_i$ 表示前 $i$ 个是选上的，那么向下一个转移。然后可以插一对进去，可以两个赞成，两个反对或者一个赞成一个反对。一个赞成一个反对可以直接转移，但是另外两种情况就不行了，然后我开始走弯路，走了很远很远。。（$f_{i,~j}$ 表示前 $i$ 个 $j$ 被选了没有之类的。。）</p>
<p>然后发现还是暴力吧。就打了暴力，当然前面是一个错的贪心，因为后来我不知道为什么就想着用靠近 $0.5$ 的数。（那样是最小吧。。）</p>
<p>出分：$20pt.$ 果然，数据大的点 $WA$ 了。</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>没错，答案一定是一个前缀后缀，证明如下：</p>
<p>​    考虑一个数 $p_i$ 的贡献：$P<em>p_i+Q</em>(1-p_i)=(P-Q)p_i+Q.$ 其中 $P,~Q$ 是之前的答案，发现它其实是一个一次函数，所以极致一定在左右两端取到。证完。</p>
<p>那么左右两端可以 $DP$ 一下了。右边同理所以考虑左边。</p>
<p>$f_{i,~j}$ 表示前 $i$ 个中 $j$ 个赞成的结果。那么转移就从上一个赞成还是反对转移。具体就是：</p>
<p>​    $\Large f_{i,<del>j}=f_{i-1,</del>j-1}\times p<del>+f_{i - 1,</del>j}\times (1-p_i).$</p>
<p>最后枚举一下 $k$ 个数里面有几个在左边，几个赞成就好，注意答案是对每种选法取 $\max.$</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/qpwqWxVhdk/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/qpwqWxVhdk/</a></p>
<h1 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.15 模拟赛 题解/Point.png" title="Point">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>没怎么看，随便想出来了一个 $n^2$ 的暴力，就是枚举答案在哪里，然后向左右扩展找到最远的地方更新答案。</p>
<p>出分：$30pt..RE$ 了。。数组开小了。</p>
<p>重开数组之后： $95pt..????$  说好的 $5e5???$ 你让 $n^2$ 过？</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><h4 id="n-3-n-2-暴力"><a href="#n-3-n-2-暴力" class="headerlink" title="$n^3,n^2$暴力~~"></a><del>$n^3,</del>n^2$暴力~~</h4><p>数据水到一定程度。。。所谓的 $n^3$ 过 $5e5,~$ 暴力碾表算。。</p>
<h4 id="题解给的正解"><a href="#题解给的正解" class="headerlink" title="题解给的正解"></a>题解给的正解</h4><p>因为对于一段序列，如果能够是答案，那么最小的一个数一定就是那个关键数，也一定是序列中所有数的 $\gcd.$ 那么考虑用 $ST$ 表存 $\gcd$ 和 $\min$ ，二分答案判断就好，复杂度是 $O(n\log^2 n)$。</p>
<p>但是它 $T$ 了！！！这玩意没有暴力跑得快！！！</p>
<p>出题人在题解里面说要卡常才能过，但是暴力过了。。</p>
<p>唯一解释就是出题人卡了 $\gcd!!$ 如果所有的 $\gcd$ 卡满可能是更劣的。。</p>
<p>$upd…:$ 不。。其实我发现是 $math.h$ 里面的 $\log_2$ 这玩意跑的特别慢。</p>
<p><del>但是他放了暴力。。</del></p>
<p>$code:$ （$T$ 了的，<del>当然可能</del>就是我写丑了。）<a href="https://paste.ubuntu.com/p/VvckND36vP/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/VvckND36vP/</a></p>
<h4 id="优秀的线性做法-真正的标算"><a href="#优秀的线性做法-真正的标算" class="headerlink" title="优秀的线性做法 真正的标算"></a>优秀的线性做法 <del>真正的标算</del></h4><p>记得最一开始的 $n^2$ 暴力吗？这个可以优化的。因为每次是向左扩展一些，向右扩展一些，那么记一个点 $i$ 向右扩展到的点为 $r_i$ ，向左是 $l_i$ ，那么在区间 $[l_i,<del>r_i]$ 中间的点就不可能有更优的答案了，因此可以跳过他们。因此实现起来可以向两个方向扫一遍，每次向右扩展到 $r_i$ 的时候就把 $[i,</del>r_i]$ 的 $r$ 都记成 $r_i$ ，然后从 $r_i + 1$ 继续找即可。这样每个点只会被扩展一次，所以就是线性的了。！</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/yKH42tkcpP/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/yKH42tkcpP/</a></p>
<h1 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.15 模拟赛 题解/Actor.png" title="Actor">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>$emm..$ 不会。。考虑暴力吧。</p>
<p>然后第一个点特别小，就打了个表，其他的点放弃了。</p>
<p>出分：$13pt.$</p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>神仙 $DP~+$  优化。？咕。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/8.13%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="repho">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Repho's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/8.13%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">8.13 模拟赛  题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-01 00:48:34 / 修改时间：01:15:01" itemprop="dateCreated datePublished" datetime="2019-11-01T00:48:34+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.13 模拟赛 题解/Count.png" title="Count">

<h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>主攻它！</p>
<p>首先因为它要求所有数不是 $m$ 的倍数，所以首先考虑容斥一下把 $m$ 扣掉。</p>
<p>大概的式子是这样的：</p>
<p>​    $\Large C_{n - 1}^{m - 1}-\sum\limits_{k=1}^{\frac {n}{m}}C_{n-km-1}^{m-1}-\sum\limits_{k=2}^{\frac {n}{m}}C_{n-km-1}^{m-2}-…$ </p>
<p>我一开始想的是把下面一样的合并一下求，但是没有发现简洁公式。而且这个式子本来就是 $\large\frac{n}{m}$ 项的， $n$ 那么大它项数就直接炸了。</p>
<p>所以换一个思路，考虑他们对 $m$ 的余数。因为不被整除，所以原式可以直接表示成 $\sum a_i\equiv A\mod m$ 。所以每一个 $a_i$ 可以转化成对 $m$ 的余数和商两部分，商部分因为没有任何限制，所以可以直接挡板法求，余数部分相当于若干个 $\in[1,<del>m-1]$ 的整数相加与 $n$ 模 $m$ 同余。同样，我们把 $n$ 也分成被 $m$ 组成的部分和被余数组成的部分，因为余数有范围，所以 $n$ 被余数组成的部分 $N’\in [k,</del>k(m-1)]$ 。这个东西规模就从 $10^{18}$ 缩小成 $km$ 了。那我们来看怎么求这些余数部分。</p>
<p>首先是同余，所以 $N’$ 的取值也是以 $m$ 为间隔的，也就是我们可以枚举这个和，复杂度是 $k$ 的，然后还是可以挡板，但是有 $[1,~m -1]$ 的限制。容斥一下？有点麻烦先看看其他的吧。（不麻烦啊这就是正解！！！）</p>
<p>当时我开始想能不能用类似背包的东西递推一下。就是 $N’k$ 的，也就是 $mk^2$ 的。写完之后发现更新的那重可以去掉改成前缀和减，所以单个 $N’$ 的求值部分复杂度就降到 $mk$ 了，总复杂度就是 $mk^2.$</p>
<p>可以过 $70pt.$ 了！那这个还能优化吗。？可能真的是还可以的，但是时间已经差不多了。写了个对拍发现过了。</p>
<p>出分：$30pt…$ ？？我过了拍还挂分了？然后发现怎么都调不对。</p>
<p><del>结果最后我写的正解的代码跟他拍还是过了，但是还是WA了。？原因后面会说。。orz…</del></p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><h4 id="容斥"><a href="#容斥" class="headerlink" title="容斥"></a>容斥</h4><p>真不难。。就是我上面说的容斥，先不考虑限制，然后减去一个超过了限制的结果，再加上两个超过了等等等。</p>
<p>当时真的就差实现的一步了。。至于实现就是超过限制的时候把超过的那 $m-1$ 减掉在求一个挡板。</p>
<p>然后就是它和前面的 $70$ 暴力过了拍但是 $WA$ 了的情况。。</p>
<p>经过长久的调试，我发现是再求组合数的地方爆了 $ll…$ 因为那是要求 $m$ 的倍数部分，所以是 $\large\frac{n}{m}+k-1$ 所以超级大，然后没取模直接成了 $ret…$ 就炸了。。<del>关键是爆成负数我都不知道因为后面把负数取回来了。。</del></p>
<p>然后就 $A$ 了。应该不算道难题吧。。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/dJRMVsjtkW/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/dJRMVsjtkW/</a></p>
<h4 id="生成函数。？"><a href="#生成函数。？" class="headerlink" title="生成函数。？"></a>生成函数。？</h4><p>老师说是道板子。。但是没学。。咕。（好像说代码和容斥是一样的。？）</p>
<h1 id="Pj"><a href="#Pj" class="headerlink" title="Pj"></a>Pj</h1><p>普及组？你在逗我。。</p>
<h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.13 模拟赛 题解/pj.png" title="pj">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>暴力滚了。</p>
<p>出分： $0pt.~~CE$ 了。。我随机数的 $ctime$ 头文件没打有尖括号。。</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>好像也不算难吧。</p>
<p>首先题目把 $x$ 给你了，就分解质因数，因为质因数之间是独立的。（鬼知道啊。。）</p>
<p>然后发现每个数的质因数指数不超过 $2.$ 然后考虑递推，分别看 $1,~2$ 两种情况。</p>
<p>指数是 $1$ 的时候可以发现就是删除最后一列上的 $1$ 所在位置以及它所在的行，那么一共有 $n$ 个位置，所以就是 $f_i=if_{i-1}.$</p>
<p>指数为二的时候有两种情况，就是一个 $2$ 和两个 $1.$ </p>
<p>一个二的时候可以类似上面转移，但是两个一就需要再考虑了。</p>
<p>考虑最后一列的 $i,<del>j$ 有两个 $1.$ 第 $i,</del>j$ 行的另一个 $1$ 在或者不在同列。首先要选两个 $1$ 在那就是 $\large C_i^2.$</p>
<pre><code>    1. 不在同列的话我们考虑合并其中的两列（可以 $i$ 的到 $j$ 也可以反过来。），那么就变成了两个 $1$ 在一列上。这个就是 $\large 2C_i^2f_{i-1}.$ 
​         2. 在同列的话我们首先去掉 $j$ 行和最后一列，然后在 $i$ 行另一个 $1$ 的位置变成 $2.$ 这个 $2$ 则考虑上面 一个 $2$ 的处理方法，那么同列情况的总数就是 $\large (i-1)C_i^2f_{i-2}.$ 注意因为上面一种情况我们算过这个一次了，所以要把它减掉。</code></pre><p>这样就有总的转移式：</p>
<p>​        $\Large f_i=if_{i-1}+2C_i^2f_{i-1}-(i-1)C_i^2f_{i-2}$ </p>
<p>这是对于每一个质因数的，总体而言呢？首先对于他们本身是可以加偶数个负号的，这个可以除了最后一行一列任意加，最后一行一列调整一下乘积即可，就是要乘上 $\large2^{(n-1)^2}.$ 然后乘上每一个质因数的答案即可。</p>
<p>然后线性递推出来记一下有几个 $1$ 几个 $2$ ，快速幂一下回答询问就好。</p>
<p>总复杂度 $O(n+q\log n).$ （$\log$ 在快速幂。）</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/fCnZ6myWHn/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/fCnZ6myWHn/</a></p>
<h1 id="Tg"><a href="#Tg" class="headerlink" title="Tg"></a>Tg</h1><img src="/8.13 模拟赛 题解/tg.png" title="tg">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>暴力滚了。但是还是手玩了几组样例，觉得那个序列挺有意思的，但是没时间了。</p>
<p>出分：$3pt.$ 这个点没有询问。。</p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>原来的那个最大下降子序列长度为 $2$ 的排列可以等价于一个前缀最大值序列。</p>
<p>前缀最大值序列是什么？就是每个位置记这个位置前缀的最大值。</p>
<p>为什么呢？对于一个前缀最大值序列，我们考虑改变了最大值的点，称为关键点，那么除去关键点之外的数字，它们必须是从小到大，并严格依次插入到空隙之中的。不然考虑有两个关键点 $i,<del>j$ 中间有两个数 $x,</del>y$ 不是关键点，但是 $x&gt;y,<del>p_x&lt;p_y$ ，那么就会出现一个下降子序列 $i&gt;x&gt;y$ 长度大于 $2$ 了。（$i&gt;x$ 是因为它现在在两个关键点之间，所以 $i$ 在区间 $[i,</del>j)$ 里面是最大值。）就矛盾了，就证明了原命题。</p>
<p>至于出题人怎么想到这样转换就不得而知了。</p>
<p>然后询问呢？寻询问是给出 $x,~y$ 让 $a_x=y.$ 那么两种情况：</p>
<p>​    $x\leq y:$ $y$ 一定在关键点上，不然前面会有一个比它大的点，而前面只有 $x-2$ 位，却要填上 $y-1$ 个数由抽屉原理可知一定有一个比 $y$ 小的数在 $y$ 后面，那就有一个长度大于 $2$ 的下降子序列了。矛盾。<br>​    $x &gt; y:$  把整个序列反转过来就是上面的情况了。</p>
<p>他是关键点的话怎么求呢？</p>
<p>考虑前缀最大值序列是什么。一个这样的序列可以看做是在一个坐标轴上，从 $(0,<del>0)$ 走到 $(n,</del>n)$ ，每次只能向上或者向右走，并且不能超过直线 $y=x$ 的方案数。（横坐标是 $i$，纵坐标是前缀 $\max.$）这个应该比较好理解。</p>
<p>那么现在就相当于有一个必经点，那答案就可以直接用组合数求了：</p>
<p>​    $\Large Ans=(C_{(x-1)+(y-1)}^{x-1}-C_{(x-1)+(y-1)}^{x})\times (C_{(n-x+n-y)}^{n -x}-C_{(n-x+n-y)}^{n -x - 1})$ </p>
<p>（上面要 $+1$ 是因为要手动过直线 $y=x$）</p>
<p>预处理阶乘快速幂求即可。时间复杂度同样 $O(n+q\log n).$ </p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/Mz2wnVvhWt/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/Mz2wnVvhWt/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/8.12%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="repho">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Repho's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/8.12%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">8.12 模拟赛  题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-01 00:48:24 / 修改时间：01:15:03" itemprop="dateCreated datePublished" datetime="2019-11-01T00:48:24+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Maze"><a href="#Maze" class="headerlink" title="Maze"></a>Maze</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3>

<h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>第一眼看到了那个 $n$ 好像特别小，就想着能不能用 $n\times n$ 的正方形来分成很多很多块，然后一起做，至于询问的话想了一下线段树来维护边上的点到另一边点的最短距离（每个节点上开二维数组存），然后写广搜初始化和旁边的情况。至于线段树上的合并可以枚举一下中间从哪里走然后更新整个的答案。</p>
<p>然后。。。分块块 $+$ 线段树加上两边的广搜，我第一次发现线段树写起来简单。最后一个小时开始写的，还没写完就 $250$ 行左右，还没搞完还没调试。没了。</p>
<p>出分：没交。</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>很不幸的是分块和线段树两种都能做。没必要结合在一起。我服了我自己。</p>
<h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><p>虽说也是分块，但这是普通的分块，就是分成 $\sqrt m$ 块。 然后也是两边暴力 $bfs$ 然后中间预处理完了就直接跳大块。修改的话是暴力重构是 $O(n^2\sqrt m)$ 的，询问要枚举中间的转移点，是 $O(n^3\sqrt m)$ 的。</p>
<p>总复杂度就是 $qn^3\sqrt m.$ </p>
<p>好像这个开 $O3$ 优化可以过。</p>
<h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>跟我前面用的线段树一样但有几点变动。</p>
<p>不需要分组！！！然后每个地方也是二维数组存的是从左端点到右端点的每对点之间的最短距离。转移的时候也是枚举一个中间点转移。然后查询直接分下去，修改直接改单点。</p>
<p>这样复杂度就都是 $qn^3\log m.$ </p>
<p>好写多了。。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/8qCFTTQkwM/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/8qCFTTQkwM/</a></p>
<h1 id="Mhw"><a href="#Mhw" class="headerlink" title="Mhw"></a>Mhw</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3>

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>看上去是个二分图的样子。题目给了两类人，在一定距离下他们有克制关系。那就相当于有向边啊。</p>
<p>因为要求的三点环必须有两条边是横跨两边，另一边在一半上的，所以只需要给那个在一半上的点定向就可以了。那么三点环有几种连边情况：（对于在一边的两点 $x,~y$ 和 另一边上的点 $z$）</p>
<p>​    1. 对于两条边 $x\leftrightarrow z <del>\&amp;</del> y \leftrightarrow z$ 他们的方向必须是反的。就是： $x\rightarrow z <del>\&amp;</del> z \rightarrow y$ 或 $y\rightarrow z<del>(\alpha) ~\&amp;</del> z \rightarrow x(\beta).$<br>​     2. 对于上面的两种不同的边的方向，我们要给 $x \leftrightarrow y$ 定向，在最大值的时候就是在所有 $\alpha$ 和 $\beta$ 环里面找到较多的一个给它们定向，最小值则相反。</p>
<p>那么求两点间的边数就可以确定边的方向了。我只会 $n^3$ 的方法。。</p>
<p>出分： $20pt.O(n^3).$ </p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>$O(n^3)$ 可以过 $1000????$ （要开 $O3$ 优化别想了。）</p>
<h4 id="线段树扫描线"><a href="#线段树扫描线" class="headerlink" title="线段树扫描线"></a>线段树扫描线</h4><p>又是你。扫描线。</p>
<p>这玩意跟扫描线有什么关系啊。？</p>
<p>我们先继续上面的两项向下分析。先把两边的点染色，左边的染白色，右边染黑色。那么我们先考虑所有白点间的边。</p>
<p>我们记白点 $x$ 连向一个黑点的黑点总数是 $f_x.$ 而两个白点 $x,<del>y$ 同时连向一个黑点的黑点总数是 $g_{x,</del>y}.$ </p>
<p>所以对于两个点 $x,<del>y$ 间半环（两条确定边）个数就是 $f_x-g_{x,</del>y}$ 相当于取一个补集。</p>
<p>那么对于所有的贡献就是：</p>
<p>$\Large \begin{aligned}Ans&amp;=\sum\limits_{x,<del>y</del>\in<del>S_{white}} \max\{f_x-g_{x,</del>y},<del>f_y-g_{x,y}\}\\\Large&amp;=\sum\limits_{x,</del>y<del>\in</del>S_{white}} \max\{f_x,f_y\}-g_{x,~y}\end{aligned}$</p>
<p>那么我们再考虑右边的那个 $g_{x, y}$ 能不能也化成 $f_x$ ？</p>
<p>它的意思就是同时连向了一个黑点，那么反过来就是一个黑点被两个白点连了，那么既然我们还要求一遍所有黑点 $f$ 那么就相当于是对于每一个黑点，选两个连向自己的边的总数。所以把 $f$ 重新定义成连向异色点的。</p>
<p>那么就是：$\large \sum g_{x, y} = \sum\tbinom{f_k}2.$具体而言就是说：</p>
<p>$\Large Ans=\sum\limits_{x,<del>y</del>\in<del>S_{white}} \max\{f_x,f_y\}-\sum\limits_{k</del>\in~S_{black}}\tbinom {f_k}2.$</p>
<p>剩下的就是求所有的 $f_x$ 了。 </p>
<p>我们回到最初的连边条件：曼哈顿距离小于等于 $D.$ 这个不太好处理所以<del>常规地</del>把他转化成切比雪夫距离。至于它是什么：</p>
<p>​    对于两个 $k$ 维的点 $A,<del>B$，其中 $A=(a_1,</del>a_2,<del>…,</del>a_k)$，<br>​    则他们的切比雪夫距离定义为：$\large\max\limits_{i<del>=</del>1}^k\{|a_i-b_i|\}.$</p>
<p><del>曼哈顿距离是什么就不说了。。</del> </p>
<p>那么怎么转换呢？曼哈顿距离只是二维的，所以对于 $(x,<del>y)$，就变成 $(x+y,</del>x-y).$ </p>
<p>但其实理解起来没那么复杂。我们要算的是曼哈顿距离小于等于 $D$ 就是说要在范围内的点集。因为是曼哈顿距离，所以他就是一个斜着的正方形。这个就已经变成了二维的矩形内选点，但是线段树扫描线只能搞横平竖直的矩形，所以考虑把所有正方形旋转 $45^\circ$ 。而这个其实就可以用上面的那个变换。</p>
<p>还有一个问题，就是这样转换完之后长度没变吗？没变！证明如下：</p>
<p>​    对于两个点 $A(x_1, <del>y_1),</del>B(x_2,<del>y_2)$，<br>​    他们变换之后变成了：$A’(x_1+y_1, ~x_1 -y_1),</del>B’(x_2+y_2,<del>x_2-y_2).$<br>​    然后之前的曼哈顿距离是：$|x_1-x_2|+|y_1-y_2|.$<br>​    现在的切比雪夫距离是： $\max\{|(x_1+y_1)-(x_2+y_2)|, |(x_1-y_1)-(x_2-y_2)|\}.$<br>​    还记得三角不等式吗：$|a-b|\leq|a|+|b|.$ 和 $|a+b|\leq|a|+|b|.$<br>​    我们记 $a=x_1-x_2,</del>b=y_1-y_2$，不就是最大值吗？<br>​    证完。</p>
<p>那么就用线段树扫描线扫以一个点为中心的矩形里面包含的点的数量即可。（前缀点数和。）</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/PTvD7P2Yqr/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/PTvD7P2Yqr/</a></p>
<h1 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.12 模拟赛 题解/Factory.png" title="Factory">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>一开始想到思路的竟然是这题。</p>
<p>既然要任意情况都行，所以最后的矩阵一定是一个对角线上全是 $1$ 的正方形的方案。</p>
<p>所以就贪心排个序，然后顺着用并查集记一下现在所在的正方形大小。</p>
<p>然后自己黑了自己。。然后随便排了下序过了，然后交了。</p>
<p>出分：$30pt.$ 贪心是错的。</p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>神仙状压 $DP.$</p>
<p>听了三遍之后感觉差不多了。</p>
<p>首先题目给的一个人会不会操作几台机器给出的一张表其实就可以相当于是一张二分图。</p>
<p>那么一个人会操作就相当于给那个机器连上了一条边。由于上面那个小结论，我们就是需要把每个二分图上的联通块连成完全二分图并且两边点数相等。</p>
<p>证明呢？考虑反证：</p>
<p>​    如果不连通，那么设人有一些没和 $x$ 连边，那么当和 $x$ 连边的人不做 $x$ 的时候，就没人做 $x$ 了。</p>
<p>​    如果联通了但是点数不相等，那么就无法一一分配。</p>
<p>然后我们把每个联通块记成一个二元组 $(x_i,~y_i)$ 那么考虑怎么选这些二元组让代价最小。那么考虑状压 $DP$ 看每个联通块选不选时候的答案。</p>
<p>如可统计答案呢？因为已连边数不变，要加的边数等于总边数减已连边数，所以最小化总边数即可。总边数则是 $\large\sum\limits_{S’\subseteq S}\sum\limits_{i\in S’} x_i\times\sum y_i=\sum\limits_{S’\subseteq S}(\sum\limits_{i\in S’}x_i)^2.$ </p>
<p>最暴力的方法 $dp_S$ 表示选 $S$ 集合的答案，转移则枚举子集，如果子集满足 $\large \sum\limits_{i<del>\in</del>S’} x_i=\sum\limits_{i<del>\in</del>S’} y_i$ 就用它更新答案。复杂度是 $3^{cnt}$ ，$cnt$ 是二元组数量。</p>
<p>然后慢慢优化它。</p>
<p>设 $dp_{S,<del>i}$ 表示现在已选的数是 $S$ ，在处理的联通块里面的 $\sum x=i.$ 那么每次枚举一个二元组加到状态里面即可，然后如果 $S$ 有 $\sum x=\sum y$（之前配好了，现在也配好了，所以总的是好的。），就相当于目前已经可以更新答案了就给 $dp_{S,</del>0}$ 更新。时间复杂度是 $2^{cnt}n.$ 还需要进一步优化。</p>
<p>发现其实不需要把每一个二元组记下来，只需要记每一种二元组出现了多少次。这个可以用一个 $cnt$ 压起来，每次向上枚举就可以了，出题人说其实 $n=30$ 时一共只有 $1.7e5$ 左右种二元组，每一次就只需要枚举一种二元组，那么时间复杂度就是 $O(n\times 1.7e5)$ ，是能过的。空间复杂度可能有点高，但是也不会太大。</p>
<p>$code:$ </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/8.10%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="repho">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Repho's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/8.10%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">8.10 模拟赛  题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-01 00:48:14 / 修改时间：01:15:06" itemprop="dateCreated datePublished" datetime="2019-11-01T00:48:14+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><del>因为好像走了就用不了 $jzoj$ 了所以不放比赛地址了。。</del></p>
<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.10 模拟赛 题解/math.png" title="math">

<h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>考场上主要玩这题了。能 $A$ 了就值了。。</p>
<p>首先朴素的把答案的式子展开：$\vec a=(x_1, y_1), ~\vec b = (x_2, y_2).$</p>
<p>​    $\large\begin{equation} \begin{aligned}Ans &amp;=|\lambda_1\vec a+\lambda_2\vec b|^2\\&amp;=(\lambda_1x_1+\lambda_2x_2)^2+(\lambda_1y_1+\lambda_2y_2)^2\ &amp;=\lambda_1^2x_1^2+2\lambda_1\lambda_2x_1x_2+\lambda_2^2x_2^2+\lambda_1^2y_1^2+2\lambda_1\lambda_2y_1y_2+\lambda_2^2y_2^2 \ &amp;=\lambda_1^2(x_1^2+y_1^2)+2\lambda_1\lambda_2(x_1x_2+y_1y_2)+\lambda_2^2(x_2^2+y_2^2)\end{aligned}\end{equation}$ </p>
<p>然后因为 $\vec a, <del>\vec b$ 是给定的，所以可以记 $\large a=x_1^2+y_1^2,</del>b=x_1x_2+y_1y_2,~c=x_2^2+y_2^2.$ </p>
<p>那么式子就变成了：$\large Ans =a\lambda_1^2+2b\lambda_1\lambda_2+c\lambda_2^2$，然后我们研究右边。</p>
<p>首先有 $a\geq 0$ 所以把右边配成定点式有：$\large a(\lambda_1+\frac b a \lambda_2)^2+\frac{ac-b^2}a \lambda_2^2 \geq \frac{ac-b^2}a \lambda_2^2$ </p>
<p>它有什么用呢？</p>
<p>首先，如果我们枚举一个 $\lambda_2$ 的话，我们就可以通过取 $\lambda_1$ 顶点 $\frac a b\lambda_2$ 附近的两个值就是最小值了。进一步可以发现，因为包含 $\lambda_2$ 的项有平方，而 $\lambda_1$ 又可以根据它来取，所以可以令 $\lambda_2\geq 0$ ，这样它小于零的情况可以通过把 $\lambda_1$ 取反等效成大于零。</p>
<p>其次，我们继续观察它的顶点纵坐标 $\frac{ac-b^2}a \lambda_2^2$ 。因为我们取的 $\lambda_2$ 是递增的自然数，所以它的平方递增的速度就非常快了，那么我们看看它的系数是不是也是非负的，这样就可以提很多速了。首先下面是非负的，也就是正的了，那么上面可以：</p>
<p>​    $\large\begin{equation} \begin{aligned}ac-b^2&amp;=(x_1^2+y_1^2)(x_2^2+y_2^2)-(x_1x_2+y_1y_2)^2\\&amp;=x_1^2x_2^2+x_1^2y_2^2+y_1^2x_2^2+y_1^2y_2^2-x_1^2x_2^2-2x_1x_2y_1y_2-y_1^2y_2^2\\&amp;=x_1^2y_2^2+y_1^2x_2^2-2x_1x_2y_1y_2\ &amp;=(x_1y_2+x_2y_1)^2\geq0.\end{aligned}\end{equation}$</p>
<p>好的！它是非负的。所以就可以这样做啦！</p>
<p>然后开始和纯暴力拍，拍了一会改了些错发现没什么问题。</p>
<p>然后随机了几组数据发现跑的飞快。（$300ms\sim500ms $ 加个 $O(2)$ 估计会很快）</p>
<p>出分：$100pt.$ //数据有点水，我这个算法应该能被卡的。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/x3m5FqDWCw/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/x3m5FqDWCw/</a></p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>那个算法很奇妙，所以还是好好写一下。</p>
<p>首先它是从欧几里得算法过来的。（靠虑共线的时候就是 $\gcd$ 最小。（$ax+by=1.$））</p>
<p>我们考虑两条向量的夹角到一定程度之后是什么样的。还是从答案出发，这次用点乘：</p>
<p>​    $\large\begin{equation}\begin{aligned}Ans&amp;=|\lambda_1\vec a+\lambda_2\vec b|^2\ &amp;=\lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2+2\lambda_1\lambda_2|\vec a·\vec b|\ &amp;=\lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2+2\lambda_1\lambda_2|\vec a||\vec b|\cos\ang\theta.\end{aligned}\end{equation}$</p>
<p>其中 $\theta$ 就是夹角了，我们想把前面的 $2$ 消掉？那 $\theta$ 取 $60^\circ$？</p>
<p>​    $\large\begin{equation}\begin{aligned}Ans&amp;= \lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2+2\lambda_1\lambda_2|\vec a||\vec b|(-\frac1 2)\\&amp;=\lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2-\lambda_1\lambda_2|\vec a||\vec b|.\end{aligned}\end{equation}$ </p>
<p>两个 $\lambda$ 分别取 $0$ 的时候坑定是另一项取 $1$ 最优，那不就是等于 $\vec a^2$ 或 $\vec b^2$？</p>
<p>那么不取零的时候呢？考虑配方：</p>
<p>​    $\large\begin{equation}\begin{aligned}Ans&amp;\geq|\lambda_1^2\vec a|^2+|\lambda_2^2\vec b|^2-|\lambda_1\vec a||\lambda_2\vec b|\\&amp;=(|\lambda_1\vec a|-|\lambda_2\vec b|)^2+|\lambda_1\vec a||\lambda_2\vec b|\\&amp;\geq|\lambda_1\vec a||\lambda_2\vec b|\geq|\vec a||\vec b|.\end{aligned}\end{equation}$</p>
<p>那我们不妨设 $|\vec a|\geq|\vec b|$ 就有：</p>
<p>​    $\large Ans \geq \vec a^2.$ </p>
<p>$OK$ 了！</p>
<p>而当夹角更大的时候 $\cos \theta$ 是减小的所以那个东西是大于等于这个六十度的时候，所以同理了。</p>
<p>也就是说把角度搞到 $60^\circ$ 以上就好了？那我们怎么改角度呢？因为我们的 $\lambda$ 是任取的，所以两个向量分别加上一定倍数的对方是没有影响的。（可以通过减对方减回来。）<br>即 $Ans\{\vec a,<del>\vec b\}=Ans\{\vec a,</del>\vec b+k\vec a\}.$</p>
<p>好的那么我们构造一下。</p>
<p>这里记 $\vec a=\vec{OA},~\vec b = \vec{OB}$，其中 $|\vec a| \leq |\vec b|$考虑两个向量的差 $\vec c=k\vec a-\vec b$ ，那么我们可以直接求 $Ans\{\vec a , ~\vec c\}$ 即可，那么怎么取 $k$ 可以让夹角尽量大呢？</p>
<p>考虑向量 $\vec b$ 在 $\vec a$ 所在直线上的投影点 $K$ ，然后考虑 $k\vec a$ 在 $K$ 附近，这里假设 $k\vec a=\vec{OA’},~（k+1）\vec a=\vec{OA’’}$ ，而 $K$ 在 $A’A’’$ 上。则：</p>
<p>​    如果 $|k|=1$ ，那么直接取它就好。</p>
<p>​    不然的话考虑哪一个更优，就比较 $BA’$ 和 $BA’’$ 的大小就好。</p>
<p>但其实实现上来说直接取 $k\vec a$ 就够了。</p>
<p>这样慢慢增大夹角直到大于 $60^\circ$ 的话，就相当于是欧几里得里面的不断取模，最后得到答案。</p>
<p>这个复杂度作者也不会证，但是几次就能得到答案的，因为每次增加的角不小。（作者猜测 $log$ 级）</p>
<p>这个复杂度就比上面的剪枝靠谱多了。</p>
<p>$code:$ </p>
<hr>
<h1 id="Treasure"><a href="#Treasure" class="headerlink" title="Treasure"></a>Treasure</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.10 模拟赛 题解/treasure.png" title="treasure">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>一看就是爆搜？写了写前两个点，自己造的小数据过了，就没管了。</p>
<p>具体做法就是每一层记录最左最右的宝藏位置，那么他们之间的一定挖过了。然后暴力看走那个就好。</p>
<p>出分：$0pt.$ </p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>好像是用斯坦纳树，看了博客不太会。咕。</p>
<h1 id="City"><a href="#City" class="headerlink" title="City"></a>City</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.10 模拟赛 题解/city.png" title="city">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>建树$+DP$ ？</p>
<p>写了写一个倍增求路径和但是是错的。</p>
<p>出分：$0pt.$ </p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>这是个 $IOI2012<del>Day2</del>T1$？？？</p>
<p>做法还是挺有意思的。</p>
<p>我们考虑如果是一棵树怎么办。就直接树形 $DP$ ，对于一个点 $now$ 记其子树大小 $siz$ ，我们考虑它和父亲连的边的贡献就是 $siz\times(n-siz).$ </p>
<p>那么这道题呢？考虑把它变成树，而我们每一次只考虑横着的或者纵着的联通块。这样就能分别处理出竖向边和横向边分别的贡献，然后累加即可。</p>
<p>是的。就是如此简单，至于横纵交换交换一下横纵坐标即可。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/Nk5JBZfKRc/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/Nk5JBZfKRc/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/8.9%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="repho">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Repho's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/8.9%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">8.9 模拟赛  题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-01 00:47:23 / 修改时间：01:14:33" itemprop="dateCreated datePublished" datetime="2019-11-01T00:47:23+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>比赛地址：<a href="http://jzoj.net/senior/#contest/home/2835" target="_blank" rel="noopener">http://jzoj.net/senior/#contest/home/2835</a></p>
<hr>
<h1 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.9 模拟赛 题解/cell.png" title="cell">

<p>###　考场</p>
<p>比较简单的题吧，首先它给出了一种叫传送门的东西要走迷宫，就先看看传送门用来做什么。</p>
<p>它可以被开在墙上，然后在墙边上传送过去。</p>
<p>那么就相当于两个点由一条更近的路连在一起了，那么就考虑最短路，看这个可能连成稠密图，所以跑 $dijkstra$ 。</p>
<p>怎么建边呢？首先两个相邻的不是墙的点之间要连，长度为 $1$，另外在墙边上可以传到其他传送门去。所以墙边上就向每一个对着的墙前的空地连长度为 $1$ 的边。然后最短路。</p>
<p>出分： $0pt. RE$ ？？？？？经过反复检查<del>提交</del>发现我在读图的时候用 $int$ 存了 $char.$ 但理论上没什么事啊。。$orz…$</p>
<p>改了之后还是没有 $A$ 为什么呢？</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>仔细读题！发现第二项说明，就是建传送门的时候不需要和墙相邻！那么在四边没有墙的地方就也可以向某一边发传送门，然后走到另一个最近的墙，再在那座墙上开个传送门传到原来发了传送门的地方。也就是对于点 $(i, <del>j)$ 向四个方向拓展到了墙是 $(x_k,</del>y_k),<del>k \in [0,</del>3]$ 那么向每个点建长度为 $\min |x_k-i+y_k-j|+1$ 的边。（这里最近的点可能建了更远的边，但是没关系，因为我们可以直接用以前建好了的相邻空地的边走过去。）</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/hbSPW2jsFJ/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/hbSPW2jsFJ/</a></p>
<h6 id="原题：jzoj5781"><a href="#原题：jzoj5781" class="headerlink" title="原题：jzoj5781"></a>原题：<a href="http://jzoj.net/senior/#main/show/5781" target="_blank" rel="noopener">jzoj5781</a></h6><hr>
<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.9 模拟赛 题解/tree.png" title="tree">

<h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>这个，好复杂，没什么想法。。</p>
<p>考虑一下随机吧！既然是二叉搜索树，$n$ 也很小，那就考虑每次随即一个插入顺序，暴力插入更新答案？</p>
<p>可以的，第二个样例天差地别。。</p>
<p>不管了看 $T3$ 了。。</p>
<p>出分：$5pt..emm…$ 随机化一分没有。。//特判第一个点的 $5pt…$</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>因为一个二叉搜索树的根可以相当于有序序列上的一个中间点，左边的区间就是左子树，右边的区间就是右子树。因为一个区间 $[l,~r]$ 只可能挂在 $l-1$ 的右边或者挂在 $r+1$ 的左边。所以我们记一下一个区间是挂在哪个爸爸上的。然后我们是知道整棵树的答案，所以可以类似区间 $dp$ 来做。</p>
<p>首先 $f_{l,<del>r,</del>0/1}$ 表示一段区间左端点（$0$）或右端点（$1$）是爸爸，自己就是 $[l+1,<del>r]$ 或者 $[l,</del>r - 1].$ 那么考虑一个普通的区间 $dp$ 是怎么转移的。 首先枚举左端点和右端点，那么我们考虑怎么转移，这里因为是可以把自己的爸爸挂在它爸爸的左边或者右边，再考虑向 $f_{l-1,<del>r,</del>0}$ 和 $f_{l,<del>r-1,</del>1}$ 转移，就有方程：                                $\Large f_{l-1,<del>r,</del>0}=\max f_{l,<del>k,</del>1}+f_{k,<del>r,</del>0}+\sum_{i=l}^{r}K_i,\quad \gcd(K_{l-1},<del>K_k)&gt;1\\\Large f_{l,</del>r +1,<del>0}=\max f_{l,</del>k,<del>1}+f_{k,</del>r,<del>0}+\sum_{i=l}^{r}K_i,\quad \gcd(K_{r+1},</del>K_k)&gt;1$</p>
<p>后面的区间和考虑用前缀和预处理即可。并且如果每一次求 $\gcd$ 也会 $T$ 掉，所以两两间的 $\gcd$ 也要预处理。$k$ 跟另外答案是 $\max f_{1,<del>i,</del>1}+f_{i,<del>n,</del>0}.$ </p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/f2wk9GBwJX/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/f2wk9GBwJX/</a></p>
<hr>
<h1 id="Rotate"><a href="#Rotate" class="headerlink" title="Rotate"></a>Rotate</h1><img src="/8.9 模拟赛 题解/rotate.png" title="rotate">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>题意很简单，先考虑第一个 $30pt.$： $O(n^3)$ 暴力：暴力选区间，暴力反转，暴力找对数。</p>
<p>然后看第二个数据点是个 $O(n^2)$ 的做法，那考虑优化上面那个暴力：不需要暴力找了，可以固定一个中间点，然后一对一对向外面扩展，没扩展一层更新答案。这就有 $60pt.$ 了。（卡到了 $65pt..$）</p>
<p>最后要交题的时候准备推一下一个点到自己的对应位置的式子，发现对于每个点有：</p>
<p>​        对于点 $i$ 要去的点是 $a_i$ ，如果关于 $k_i$ 对称过去，那么有 $i+a_i=2k_i.$ </p>
<p>然后发现左边的每个点是固定的，所以对应 $k_i$ 也是固定的，那么考虑一下反转区间，发现反转区间的左右端点肯定是有一个固定点的，因为没有的话就没必要扩展开，不扩展是不劣的。（可能把固定点翻没了。）那就可以考虑每一个点的这个 $k_i$ ，更新答案，所以我们需要维护的是反转区间里面 $k_j=k_i$ 的点的个数，反转区间外的前后缀和解决。这个可以用根号算法解决，比如分块？莫队？</p>
<p>分块写的快些所以当时写的分块，但是没调出来。<del>就算调出来了也要爆空间。。</del></p>
<p>交的平方暴力。</p>
<p>出分：$65pt.$ </p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><h4 id="莫队（-O-n-sqrt-n-）"><a href="#莫队（-O-n-sqrt-n-）" class="headerlink" title="莫队（$O(n\sqrt n)$）"></a>莫队（$O(n\sqrt n)$）</h4><p>上面讲的够清楚了，接下来就是把那些反转区间的询问用莫队搞一搞了。应该就是模板了，只需要询问区间内某个数的出现次数即可。//注意维护的是 $v_i$ 也就是 $a_i+i~!!!$ </p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/nB6h7KSrbx/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/nB6h7KSrbx/</a></p>
<h4 id="优化上面的平方暴力？（-O-n-log-n-，-log-数据结构（其实可以排序降一点）。）"><a href="#优化上面的平方暴力？（-O-n-log-n-，-log-数据结构（其实可以排序降一点）。）" class="headerlink" title="优化上面的平方暴力？（$O(n\log n)$，$\log$ 数据结构（其实可以排序降一点）。）"></a>优化上面的平方暴力？（$O(n\log n)$，$\log$ 数据结构（其实可以排序降一点）。）</h4><p>首先上面分块的时候说过一个反转序列的左右端点一定在反转之后是一个不动点，然后就可以记一下一个点的不动点在哪里，挂在那个中间点后面，然后在枚举中间点的时候就可以左右跳只跳到不动点的位置更新答案，这里因为要顺着跳，所以可以用一个大根堆记左端点（或小根堆记右端点），然后一个个跳着更新答案就可以了。因为只有 $n$ 个点，所以只会跳 $n$ 次，加上堆的复杂度就是 $O(n\log n).$ </p>
<p>其实复杂度瓶颈在让每个点后面的数有序，其实用一个线性排序算法就可以总体线性了。（基数排序。？）</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/x552Wr74HK/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/x552Wr74HK/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/8.7%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="repho">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Repho's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/8.7%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">8.7 模拟赛  题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-01 00:47:13 / 修改时间：01:14:21" itemprop="dateCreated datePublished" datetime="2019-11-01T00:47:13+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>比赛链接：<a href="http://jzoj.net/senior/#contest/home/2833" target="_blank" rel="noopener">http://jzoj.net/senior/#contest/home/2833</a></p>
<h1 id="Seq"><a href="#Seq" class="headerlink" title="Seq"></a>Seq</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.7 模拟赛 题解/seq.png" title="seq">

<h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>题目变简单了。这道题一个递推式很显然地看出可以做矩乘。那考虑怎么构造矩阵。</p>
<p>因为他都是前面式子相乘得到的下一项，而递推式里的常数 $b_i$ 又在指数上，可以想到两个等底数的式子相乘就等于他们的指数相加。那么只需要在指数上做矩乘维护一个递推后的指数和就好了。</p>
<p>这么构造矩阵的话，转移矩阵会很好看：</p>
<p>$\begin{bmatrix}<br>0 &amp;1 &amp; 0 &amp; …&amp;0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; …&amp;0 &amp; 0\\<br>&amp;&amp;&amp;…\\<br>0 &amp; 0 &amp; 0 &amp; …&amp; 1&amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; …&amp;0&amp;1\\<br>b_k&amp;b_{k-1}&amp;b_{k-2}&amp;…&amp;b_2&amp;b_1\\<br>\end{bmatrix}$</p>
<p>构造起来也很简单。然后普通矩乘就好。</p>
<p>注意这里跑起来会有点慢，经过反复卡常 $+O3$ 之后本地仍然 $1.6s+.$ 开网之后在 $customtest$ 测了一下发现开 $O3 ~400ms+$，不开 $2000ms+…$ 然后交了 $O3.$ 拍了很久没错就觉得应该是满分了。</p>
<p>出分：$100pt.$</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/87Rk2K453B/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/87Rk2K453B/</a></p>
<h1 id="Dream"><a href="#Dream" class="headerlink" title="Dream"></a>Dream</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.7 模拟赛 题解/dream.png" title="dream">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>挺喜欢题面的。然后发现好像可以直接贪心。因为一个 $t$ 只能对应一个 $[l,~r]$，所以我们可以类似选区间的策略按左端点排序然后尽量选右端点靠左的区间和 $t$ 配对，这样区间更靠右的就有可能和后面的点配对从而有更优的答案。</p>
<p>具体实现起来就把区间按左端点排序，从小到大考虑 $t$ ，每一次首先把所有左端点小于 $t$ 的区间假如考虑中，因为后面的 $t$ 不减而我们要找最小的右端点，所以我们只需要用一个小根堆存这些区间的右端点，在找区间的时候如果堆顶比 $t$ 还要小，就直接弹出，因为它不能和 $t$ 配对就更不可能和 $t$ 后面的数配对。然后如果能配上一个就计入答案并弹出堆顶。（因为有可能一个满足的区间都没有，就是堆为空）</p>
<p>代码也很简单了。</p>
<p>出分：$100pt.$ //其实当时没想要拿满，但好像也举不出反例就交了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/n2XGdh5xkT/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/n2XGdh5xkT/</a></p>
<h1 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.7 模拟赛 题解/tree.png" title="tree">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>先暴力吧，就是暴力两个点然后暴力中间的点走过了一个点对没有。</p>
<p>然后觉得这个枚举另一个点的过程好像可以在搜出去的过程中解决，但是没往下想。//这个是可以的。</p>
<p>然后开始看特殊数据。</p>
<p>一条链还只有一对点的话，直接左边右边讨论。</p>
<p>菊花图的一对点的话，也可以直接讨论，这个讨论了我很一会。</p>
<p>然后由于第一题卡常卡了很久，<del>谁知道它臭氧优化那么快。。</del> 没时间了。</p>
<p>出分：$20pt.$ //可能讨论挂了吧。毕竟没有造数据看。</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>？？矩形面积并？？神奇。。</p>
<p>还是先从序列上下手的，把问题转化成求不合法的对数，这样原来的答案就是总对数减。</p>
<p>求不合法的对数的话，就是所有包括这两个点 $[l_i, <del>r_i]$ 的一个区间，这样就是要区间的左端点 $\leq l_i$，右端点 $\geq r_i$。这个东西的解集可以看成一个二维的东西，具体而言就是一个矩形，因为它就是所有满足 $x \in [1,</del>l_i],<del>y\in [r_i,</del>n]$ 的点对。这个就是一个矩形了。然后对每一个求一个并就是求矩形面积并了。</p>
<p>这是序列上的，那树上怎么办呢？那我们就在 $dfs$ 序上面考虑就好了。考虑点对 $(x,~y)$就有两种情况：</p>
<p>​    1. $(x,<del>y)$ 不是相互的祖先，那么一对答案 $(u,</del>v)$ 要满足 $u$ 在 $x$ 的子树里面，$v$ 在 $y$ 的子树里面，那么在一个 $dfs$ 序上就可以直接转化成两段区间。<br>​     2. $(x, <del>y)$ 有祖先后代关系，不妨设 $x$ 是 $y$ 的祖先，那么一对答案 $(u,</del>v)$ 要满足 $u$ 在 $y$ 的子树里面，$v$ 在整棵树除了 $y$ 所在的 $x$ 的子树里面。这个就是整个区间减一个区间，拆成两个区间即可。</p>
<p>然后就是矩形面积并了。</p>
<p>那它怎么写呢？？？</p>
<p>既然这个已经咕了很久，今天又是七夕，那就来写一下他吧。这个还是单独放在另一个博客里吧：[矩形面积并]</p>
<p>[矩形面积并]: </p>
<p>然后和普通的矩形面积并不同，它的坐标是比较小的，所以不需要离散化，除此之外，因为一对点就算是算面积也只能被算一次，所以要严格保证所有表示矩形区间的横坐标小于纵坐标，大于就换一下，以为换一下不影响计数。而且因为边界都要算上，所以再加矩形的时候吧终边（上边）纵坐标 $+1$ 之后再加，保证上面那条线被算到了。</p>
<p>最后用 $\frac{n\times (n-1)}{2} - cnt$ 就可以得到答案了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/BDvhkHGKDy/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/BDvhkHGKDy/</a></p>
<h6 id="七夕快乐啊！！orz…"><a href="#七夕快乐啊！！orz…" class="headerlink" title="七夕快乐啊！！orz….."></a>七夕快乐啊！！orz…..</h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/8.5%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="repho">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Repho's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/8.5%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">8.5 模拟赛  题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-01 00:46:59 / 修改时间：01:14:39" itemprop="dateCreated datePublished" datetime="2019-11-01T00:46:59+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>比赛地址：<a href="http://jzoj.net/senior/#contest/home/2831" target="_blank" rel="noopener">http://jzoj.net/senior/#contest/home/2831</a></p>
<h1 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.5 模拟赛 题解/game.png" title="game">

<h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>比较简单的数学题。//没想到第二道能 $A$ 的题就在今天。</p>
<p>首先发现 $n, m$ 都很大就肯定要行列分开的。因为你开一个数据结构空间也肯定爆了。</p>
<p>分开行列的时候观察每一个点上原始的数字是什么：</p>
<p>第 $i$ 行 $j$ 列是 $(i - 1)\times m+j$ 这个东西好像天然把行和列分开了。</p>
<table>
    <tr>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
    <tr>
        <td>5</td>
        <td>6</td>
        <td>7</td>
        <td>8</td>
    </tr>
    <tr>
        <td>9</td>
        <td>10</td>
        <td>11</td>
        <td>12</td>
    </tr>
</table>

<p>那么我们试着把一张表拆成两张表, 其中一张表是加号前的那项, 另一张是加号后的。（这样做的另一个动机是每一列可以看做是 $m$ 的一个剩余系了。）</p>
<p>表 $1$ ：</p>
<table>
    <tr>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
    <tr>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
    <tr>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
</table>

<p>表 $2$ ：</p>
<table>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>4</td>
        <td>4</td>
        <td>4</td>
        <td>4</td>
    </tr>
    <tr>
        <td>8</td>
        <td>8</td>
        <td>8</td>
        <td>8</td>
    </tr>
</table>

<p>其实这样对应相加也能得到原始表格。那么根据乘法分配律, 所有操作可以分别对两个表进行之后求和相加即可得到原表格的答案。</p>
<p>然后发现表 $1$ 里面的每一列是相同的, 表 $2$ 中的数是相同的。所以表 $1$ 中只需要将列的修改做成一个倍数和, 从行的方向扫一遍, 并将它和行的修改以及这一列的数字一起乘起来就是结果了。表 $2$ 中同理。</p>
<p>这样的复杂度就只有 $O(n+m)$ 了, 然后 $n,m$ 同级所以就是线性的了。</p>
<p>出分：$40pt.$ 我求倍数和的时候没取模爆炸了！！！！</p>
<p>加了就 $A$ 了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/CpJXw6vXhR/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/CpJXw6vXhR/</a></p>
<h1 id="Jump"><a href="#Jump" class="headerlink" title="Jump"></a>Jump</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.5 模拟赛 题解/jump.png" title="jump">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>这个。一个数好像只能向一个地方走, 那就是 $n$ 个点,  $n$ 条边, 就是一颗基环外向树啊？</p>
<p>那么一定有循环了。但是找循环应该是 $O(nm)$ 级别的, 待修改的话就起飞了。</p>
<p>那考虑修改怎么改。因为是一颗基环外向树, 那么边只可能是树边和环边了, 那分类讨论一下：</p>
<pre><code>1. 树边重新接在树上：对环（循环）没有影响直接连.
2. 树边重新接在环上：还是没有影响.
3. 环边重新接在树上：环变大了.搜一下变大的部分.
4. 环边重新接在环上：环变小了.搜一下变成树的部分.</code></pre><p>然后开始写。然后就没时间了。然后发现这样写每一次修改都要带着 $O(nm)$ 这个肯定就会爆炸了。</p>
<p>然后跟暴力拍 $1$ 个点就 $WA$ 了。细节写挂了吧。。</p>
<p>出分：$20pt.$ （交的暴力。）</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>就是高效地找循环搞循环。</p>
<p>因为循环是 $O(nm)$ 的而且每跳过 $n$ 步所在的一列是重复的。所以我们分块一下, 每一块的长度是 $L =\min (n, m)$ , （这个东西如果 $m$ 比 $n$ 大手动交换它们。）每一次一大块一大块地跳来找循环节, 不在大块顶点就暴力跳。这样找循环的复杂度就是 $O(L).$ 然后一个小优化就是只需要在修改后的第一次查询处找一次循环节。</p>
<p>那修改操作呢。修改操作应该是会去有可能改到前三个点的范围内的答案的, 然后我们分别看每一个点, 首先看它改到了哪一个点, 先从那个点往后跳跳到块地端点上, 然后向前跳, 向前跳发现可能前面的几个数都跳到这里了, 那么发现我们可以从中间向外扩展, 每次只考虑上下界的转移, 因为中间的只能看到后面三个包含在我们考虑区间内的, 一定能走到后面的点上的。（如果连第一行都走不到就不用更新了。）</p>
<p>但是他有一个 $3$ 的常数？//其实我怎么看这个都会 $T…$</p>
<p>$code: $ </p>
<h3 id="原题。？"><a href="#原题。？" class="headerlink" title="原题。？"></a>原题。？</h3><p>$luogu$ 原题链接：[<a href="https://www.luogu.org/problem/P4739]（它开" target="_blank" rel="noopener">https://www.luogu.org/problem/P4739]（它开</a> $8s$ 比赛开 $4s$ ？）</p>
<p>[<a href="https://www.luogu.org/problem/P4739]" target="_blank" rel="noopener">https://www.luogu.org/problem/P4739]</a> :<a href="https://www.luogu.org/problem/P4739" target="_blank" rel="noopener">https://www.luogu.org/problem/P4739</a></p>
<h1 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.5 模拟赛 题解/sequence.png" title="sequence">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>想着用线段树 $Hash$ , （我傻啊又没有重复。。）写了 $WA$ 掉了的暴力。//没时间了。。</p>
<p>出分：$0pt…$</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><h4 id="80pt-100pt-的卡常线段树-ST-表"><a href="#80pt-100pt-的卡常线段树-ST-表" class="headerlink" title="$80pt.$$100pt.$ 的卡常线段树 $/ ST$表"></a>$80pt.$<del>$100pt.$ 的卡常线段树 $/</del> ST$表</h4><p>因为要是一段优美的序列 $a_{i…j}$, 里面的就需要是 $[<del>\min_{i…j},</del>\max_{i…j}~]$ 中的所有数都要包含在内的, 就是说</p>
<p> $[<del>\min_{i…j},</del>\max_{i…j}~]$ 中即使是最左边和最右边的数都要在这个范围内, 因为他已经天然离散化了, 所以可以根据一个数字出现的位置得到一个新序列, 而优美的序列就是说两个序列的长度是一样的。这样通过反复地来回映射就可以找到一个最短的包含自己的序列了。（因为每一次映射都是一个必须满足的条件得到的一个新区间, 而区间长度递增, 所以第一次的就是最短的。）</p>
<p>$eg.$<br>$\quad A~=\{ 3,1,7,5,6,4,2\}\\<br>\quad A’=\{ 2,7, 1,6,4,5,3\}$<br>那么例如 $[3, 6]$ 就是一段优美的序列, 因为 $A$ 序列中的最大最小值对应区间 $[4,7]$ 长度和原序列中的 $[3,6]$ 长度都是 $4.$</p>
<p>那么我们就是需要查询两个序列的区间最值, 线段树 $/~ST$ 表, 因为线段树查询带 $log$ 而且常数大, $ST$ 表肯定就是更好的选择。</p>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>没人会。。题解讲的好像很随意。网上说得好像用线段树扫描线？</p>
<h4 id="严格-log-的线段树"><a href="#严格-log-的线段树" class="headerlink" title="严格 $log$ 的线段树"></a>严格 $log$ 的线段树</h4><p>考虑一个优美序列满足什么样的性质。首先它肯定是由连续数字组成的。（废话那是定义。）</p>
<p>称每两个连续数字是一个连续数对的话，那么对于一个优美序列而言就有：</p>
<p>$l+num=r ~IFF ~a_{l,…,r}是一个优美序列$.（其中 $num$ 是连续数对个数） </p>
<p>证明的话这个东西显然的：排好序之后是从 $Min$ 到 $Max$ 的一个连续序列, 中间自然就有 $r-l$ 个连续数对了, 逆命题同理。</p>
<p>然后我们考虑怎么维护这个信息。可以首先考虑把询问离线下来并从左往右考虑右端点 $i$ 框定包含询问的右端点的优美序列。 这样首先可以保证右边的 $r$ 是一个有序的。</p>
<p> 然后考虑每一次来到一个右端点 $r$ 的时候考虑用它所组成的连续数对更新能够成立的等式左边就可以了。这样的话首先考虑每个点初始就会有一个自己位置的值 $pos.$ 然后通过后面和它后面的数（包括它）构成的连续点对更新自己的值以得到答案。那么每次的右端点更新左边的值就是更新一个前缀和，那么区间加。</p>
<p>再考虑怎么得到答案。每次需要的是最右边的一个在询问的左端点左边的点，那么怎么保证呢？观察式子的左边，发现这个东西每一次可能受到 $+0,<del>+1,</del>+2$ 三种影响，这个不太好处理，而考虑到每一次右边是肯定会 $+1$ 的，所以我们考虑改变的差值。差值就只可能 $-1,<del>+0,</del>+1$ 因为 $num$ 初始为 $0$ 时左边是小于右边的，而每次 $+1$ 就又可以保证这个差值是一个一个缩小的，所以如果出现了答案，这个值一定是整个前缀中最大的之一。那么区间最大值。</p>
<p>区间加 $+$ 区间最大值：线段树。 $\rightarrow$ 严格 $O(n\log n)$ 算法。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/WgP6sm3MQH/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/WgP6sm3MQH/</a></p>
<h3 id="原题。？？"><a href="#原题。？？" class="headerlink" title="原题。？？"></a>原题。？？</h3><p>$luogu$ 原题链接：<a href="https://www.luogu.org/problem/P4747" target="_blank" rel="noopener">https://www.luogu.org/problem/P4747</a>（它开 $3s$ 比赛开 $1s$ ？？？）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="repho"
    src="/images/head.png">
  <p class="site-author-name" itemprop="name">repho</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/the-repho" title="GitHub &rarr; https://github.com/the-repho" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2373338240@qq.com" title="E-Mail &rarr; mailto:2373338240@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.luogu.org/space/show?uid=78369" title="Luogu &rarr; https://www.luogu.org/space/show?uid=78369" rel="noopener" target="_blank"><i class="fa fa-fw fa-code"></i>Luogu</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://codeforces.com/profile/Harmony_" title="Codeforces1 &rarr; https://codeforces.com/profile/Harmony_" rel="noopener" target="_blank"><i class="fa fa-fw fa-code"></i>Codeforces1</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://codeforces.com/profile/Repho" title="Codeforces2 &rarr; https://codeforces.com/profile/Repho" rel="noopener" target="_blank"><i class="fa fa-fw fa-code"></i>Codeforces2</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/180000517" title="bilibili &rarr; https://space.bilibili.com/180000517" rel="noopener" target="_blank"><i class="fa fa-fw fa-tv"></i>bilibili</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">repho</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>
















  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
