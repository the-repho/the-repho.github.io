<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[8.20 模拟赛 题解]]></title>
    <url>%2F8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Glo题面 考场一看是一个最长上升子序列，只是带一点特殊的东西，再一看数据范围，根据已学知识要用单调栈搞一个 $\log$ 算法差不多能过。 然后开始看那个特殊的区间加操作。然后发现如果把一个区间加向后面拓展成后缀加，答案一定是不劣的，同理区间减扩展成前缀减。进一步我们发现最长上升子序列关心的只是他们之间的差值，所以数值本身意义不大，因此前缀减可以等效成后缀加，那么现在的问题就变成了要给一个后缀加上一个数之后的最长上升子序列了。 然后我考虑单调栈的做法，就是维护一个当前的上升子序列长度为 $x$ 的一个最小值，然后找到刚好比自己大的位置插进去，并更新答案。所以我的想法就是与此同时也在一个后缀的栈里面找到 $x-k$ 的位置，用那里的后缀最长下降子序列更新总的答案。但是这个栈是没办法回退的，所以我发现不能预处理一遍后缀栈然后在做前缀的时候退出上一位的影响。那就只能暴力做这里的栈了，这个做法要么时间爆炸要么空间爆炸。而我也没有什么进一步思路了。 看看部分分。 $k=0$这个就是普通的最长上升子序列。直接做。 $k=1e9(\infin)$这个已经不需要考虑 $x-k$ 在哪了，所有的后缀都能满足了。那直接正反求一遍，然后在中间用前后缀更新答案。 出分：$10pt.$ ？？？它 $subtask???$ 稍微改了改救回 $33.$ 正解上面的做法已经离得很近了。在处理前缀的时候，我们可以直接把那个值的答案记下来。就是那个前缀 $x$ 处的最长上升子序列，那么前缀上就必须大于 $x + k$。然后我们再倒着看，只要在每个地方加了之后在之前里面的答案中更新即可。具体而言就是： 记录一个 $f_i$ 表示在 $1 \to a_i$ 前缀上严格以 $a_i+k$ 结尾的最长上升子序列。那么在倒着做的时候，只需要在栈里面找 $a_i$ 的答案 $f_i$。 这个可以用单调栈实现，但是这次学会了另一种求最长上升子序列的方法：在值域上维护区间最大值。因为每一次要的是结尾比 $a_i$ 小的最长上升子序列，所以相当于求一个值域前缀 $\max.$ 这个离散化之后用线段树或者树状数组维护即可。也是一个 $\log$ 的。 $code:$ https://paste.ubuntu.com/p/2dnt4nTXrg/ Mobitel题面 考场没想到用 $dp.$ 写的爆搜加小剪枝，因为发现当大于的时候后面的方案数可以用组合数算了，就直接剪掉了。 出分：$10pt.$ 正解$dp.$ 因为大于 $n$ 没什么限制条件不好做，所以我们转化一下，转化成用整个的（也是一个组合数）减去小于 $n$ 的方案数，因此这个就可以 $dp$ 了。 设 $f_{i,j,m}$ 表示现在走到 $(i,j)$ 乘积是 $m$ 的方案数。然后转移转移到 $(i+1,j)$ 和 $(i,~j+1)$ 即可。这个复杂度是 $O(rsn)$ 的，肯定爆炸了。 所以考虑进一步转化，优化一下状态。因为发现最后能用到的空间其实是 $\large\frac{rest}{a_{i,j}}$ ，而 $\large\frac n x$ 的个数又只有 $2\sqrt n$ 个 ，所以可以把状态优化成 $f_{i,j,m}$ 表示走到 $(i,j)$ 还剩下 $m$ 给我们除。还是上面的转移，就可以继续做了。时间复杂度对了，但是发现空间炸了啊？能滚动吗？可以哦。每一次的值只和上一层有关，只要记这两层的就好了。 另外还有一个细节就是他要求的是大于等于 $n$ 的路径积方案数，所以求因子的时候注意要先 $n–.$ 模数是 $1e9+7$ 不是 $998244353$！！！ $code:$ https://paste.ubuntu.com/p/qCc4dyDV4s/ Lottery题面 考场只想到了 $n^3$ 转移的暴力。其实是只去肝第一题了。。 出分：$25pt.$ 正解首先 $n^2$ 就有一个很巧妙简单的转移：可以通过去掉左边端点上的两个加上右边端点上的两个点，来实现同一长度的区间从左向右的移动 $O(1)$ 得到答案。然后发现 $n=1e4?$ $O(n^2)$ 预处理好像能过。 但是发现空间开的很小，所以需要优化一下空间。如果直接开 $1e4\times 1e4$ 的数组要几个 $GB$ 内存啊。然后询问很少啊？ 那就说明没有询问到的长度是无效的。所以可以先把询问离线下来，去个重编个号每次只要记每个数询问处的答案即可。 具体实现类似一个离散化吧。 $code:$ https://paste.ubuntu.com/p/VtcCv5R4dp/]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.18 模拟赛 题解]]></title>
    <url>%2F8.18%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[比赛真的变简单了好多呢。 Backpack题面 考场首先想了一个贪心。（部分背包类似，把所有物品按照一个性价比排序。） 然后黑了自己。 然后开始 $dp$ ，发现是一个 $O(nm).$ ： ​ $\Large dp_j=\max\{dp_{j-w_i}+v_i\}.$ 搞完后面的之后回头来看，发现 $a,b$ 的范围只有 $[1,100]$，那可以考虑做一个桶，把 $a$ 一样的物品只存它们的 $\max v.$ 然后就得到了一个 $O(m\max a)$ 的算法，能拿 $60pt.$ 稍微考虑了一下矩乘但是好像不太好写就没管了。 出分： $60pt.$ 正解贪心。？？没错，一开始的类似部分背包的贪心有一定的正确性。可以大概的猜到，最优解里面一定会有很大一部分用性价比最大的物品组成的。所以我们考虑剩下多少贪心不一定正确。 首先在任意的 $n$ 个数中，一定有某些数之和是 $n$ 的倍数。证明方法考虑它们的 $n+1$ 个前缀和，由抽屉原理，一定有两个在模 $n$ 意义下同余。所以他们之差所对应的区间的数之和一定是 $n$ 的倍数。 如此一来，只要留下 $a_s$ 个数即可，不然可以通过用 $s$ 替换里面的若干个和是 $a_s$ 的倍数的物品，这样肯定会更优。（ $s$ 即为性价比最高的物品。） 这样把剩下的很少的物品做一个 $dp$ 即可。 $code:$ 矩乘！看这个 $m$ 的范围应该可以大概想到矩乘优化一下 $DP.$ 那么就是考虑怎么做转移矩阵了。 那么我们考虑现在的答案会从前面的哪里转移过来，用多少代价。我们发现，我们在 $i$ 的时候，会从所有的 $i-w_j$ 转移过来，并且答案是 $\max\{f_i+v_j\}.$ 所以就可以考虑构建一个 $100\times100$ 的矩阵，每次乘法是做的加法取 $\max.$ 那么矩阵具体应该是什么样的呢？ 那么我们考虑从 $\large f_{i-k+1}\to f_i$ 转移到 $\large f_{i-k + 2}\to f_{i+1}.$ （其中 $k=\max\{w_i,~v_i\}$）首先，之前的后 $k-1$ 项和之后的前 $k-1$ 项是要相同的，考虑到是加法取 $\max$ ，可以只算矩阵中非 $-1$ 的数，并把对应斜对角线赋为 $0.$ 这样可以保证前 $k-1$ 项了。那么最后一行的矩阵就是直接和转移方程挂钩了。那么就是在所有的 $w_i$ 的位置上赋 $v_i$ 的值即可。其他空位赋 $-1.$ 完整矩阵如下图：（最后一行假定被所有物品填满了，且 $w_i=i.$） ​ $\large\left[\begin{matrix} -1 &amp; 0&amp;-1&amp;\cdots &amp;-1&amp;-1\-1&amp;-1&amp;0&amp;\cdots&amp;-1&amp;-1\\\vdots&amp;\vdots &amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\-1&amp;-1&amp;-1&amp;\cdots&amp;0&amp;-1\-1&amp;-1&amp;-1&amp;\cdots&amp;-1&amp;0\\v_1&amp;v_2&amp;v_3&amp;\cdots&amp;v_{k-1}&amp;v_k\end{matrix}\right]$ 那么用它自乘再预处理前 $k$ 个就可以矩乘了。 $code:$ Median题面 考场不知道是什么时候无意中看到了这道题的算法。但是没什么印象了，大概记得是二分吧。 所以首先我考虑在一个上面二分，然后每次在另一个上面 $lower_bound$ 出它的位置，加起来就可以知道它在合并之后的序列中的位置，复杂度就是 $O(n\log^2n).$ 但是出题人好像卡了两个 $\log$ 的算法。。只有暴力分。 所以要更优秀的算法了。我们仍然考虑二分，但方式不同了。由上面的我们可以联想到，那前一半的数大概分布是一边多一边少的（废话。。），那么我们不就可以每一次扔掉多的那部分里面的一些吗？那么为了尽量优，我们可以考虑每次丢一半，这样就能做到一个 $\log$ 啦。具体而言是这样的： 假设我们现在还要选的数的个数是 $p$ ，那么我们可以分别在两个序列里面取第 $\large \frac{p}{2}$ 个，然后比较一下它们的值，可以发现那个更小的一定被那更多的一边覆盖住了，所以就可以丢掉它了。这样规模减少了一半。直到一遍被删完之后，就可以直接在另一边的里面找到答案了。 注意：上面说的更多一点其实是有问题的，仅用来理解这个算法的正确性。当一边的数分散在两极的时候，可能这边的少些，但是仍然要删它了。 出分：$100pt.$ $code: $ Sequence题面 考场我是怎么都没看出来它是一个积性函数。（因为在此之前我的认知是所有数都要有 $f(x)f(y)=f(xy).$） 然后写的爆搜。 出分： $10pt.$ 正解没错，这应该是一个积性函数。因为如果两个数互质，那么他们和 $B$ 的 $\gcd$ 一定是互不相关，因此由乘法原理，它们乘起来的总方案数就是答案。（也就是没有重叠的多余部分被计算了。） 那么看着这个数据范围，就可以试一下欧拉筛了。（前面模拟赛的时候考过学过。） 首先考虑 $f(p^c)$ 怎么做。因为最后贡献要和 $B$ 取 $\gcd$ 所以这个一定和 $B$ 中的 $p$ 个数有关。那么考虑 $B$ 质因数分解后 $p$ 的指数是 $k.$ 那么对于 $A=p^c$ ，我们需要分两类讨论：$c&gt;k$ 与 $c\le k.$ 对于第二类，我们可以枚举所有 $a$ 中最小的次数 $i\leq c$ 每一次用 $p$ 的次数大于等于 $i$ 的所有数的可能情况 $(c-i+1)^n$ 减去大于等于 $i+1$ 的情况就能得到至少有一个最小值次数是等于 $i$ 的情况了，而这些整个要乘上它们的贡献，也就是 $\gcd(a_1,\dots,a_n,~B)$ 也就是 $p^c$ 了。而对于第二类，因为总的次数不能超过 $k$ ，所以 $c$ 超过的部分是没有贡献的，或者说贡献仍然只有 $p^k$，所以我们只需要枚举到 $k$ ，超过的部分直接用一个表示超过取值 $c\to k$ 的整个式子就好了，它们的贡献上面也说了，就是 $p^k$。具体就是： ​ $\large\begin{equation}\begin{aligned} f(p^c)=\begin{cases}c\leq k&amp;&amp;&amp;\sum\limits_{i=1}^c ((c-i+1)^n-(c-i)^n)p^i.\\c &gt; k &amp;&amp;&amp; \sum\limits_{i=1}^k ((c-i+1)^n-(c-i)^n)p^i+p^k(c-k)^n.\end{cases}\end{aligned}\end{equation}$ 那么实现起来就是以前的欧拉筛模板，有一点区别的就是当 $i$ 是一个合数的最小质因子的时候，我们就要另外用他这个最小质因子的整个次数去乘了。 $code:$ https://paste.ubuntu.com/p/fqgyRVMfdR/]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.17 模拟赛 题解]]></title>
    <url>%2F8.17%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Slope题面 考场首先读了下题，题意是找出斜率最接近 $\large\frac{P}{Q}$ 过两点直线的斜率·。 那么直接看一下一条直线的斜率和 $\large \frac{P}{Q}$ 的差是什么： ​ $\Large \Delta=|\frac{P}{Q}-\frac{y_1-y_2}{x_1-x_2}|=|\frac{P(x_1-x_2)-Q(y_1-y_2)}{Q(x_1-x_2)}|=\frac 1 Q|\frac{(Px_1-Qy_1)-(Px_2-Qy_2)}{x_1-x_2}|.$ 当我们转化成这样的时候，就发现分子上的部分括号内的只与某一个点有关. 那么对于每一个点，就可以记 $\large w_i=Px_1-Qy_1$ ，那么这里的 $\Delta$ 在忽略前面的常数之后就相当于： ​ $\Large \Delta = |\frac{w_1-w_2}{x_1-x_2}|.$ 这个式子的形式也可以看作是过两个点的直线的斜率了。我们问题就转化成求过两点的直线的斜率的绝对值最小。 这个问题就好求了，直接将所有点按照 $w_i$ 排序，然后只需要考虑每个点后面的那个和它相邻的点统计答案即可。 为什么呢？首先他前面的点跟他统计过一次答案了，所以只需要统计后面的。那么为什么在排序之后答案是最优的呢？考虑点 $i$，那么记它和 $i+1$ 连成的直线的斜率是 $k$ （不妨设两点间斜率均大于零），那么如果 $j$ 和 $i$ 有更优的答案，我们发现 $i+1$ 和 $j$ 会更优，证明如下：（其实画图很好理解） ​ 不妨设 $i:(0,0), i+1:(x_1,y_1), ~j:(x_2, ~y_2).$ 那么有：​ $\Large\frac{y_1}{x_1}&gt;\frac{y_2}{x_2}\\\therefore y_1x_2&gt;x_1y_2\\\therefore y_1x_2-x_1y_1&gt;x_1y_2-x_1y_1\\\therefore (x_2-x_1)y_1&gt;(y_2-y_1)x_1\\\therefore \Large\frac{y_1}{x_1}&gt;\frac{y_2-y_1}{x_2-x_1}$​ 得证。 程序就记一下如果相等取 $k$ 的 $\min$ 就好了。 出分：$100pt.$ $code:$ https://paste.ubuntu.com/p/MVB39949PK/ Min题面 考场第一次讲课讲 $DP$ 的时候好像说过很多种这一类题，那么考虑一个朴素的 $DP.$ $f_i$ 表示最后一个区间以 $i$ 结尾的答案，那么转移就枚举最后一个区间左端点即可。具体就是： ​ $\Large f_i=\max\limits_{j=0}^{i-1}f_j+F(\min\limits_{k=j+1}^{i} a_k).$ 然后就是区间最小值了， $ST$ 表即可。 对于那个特殊条件，对于样例稍加改动看了看函数值，发现这个时候只有当前一个数能自成一段时转移，否则跟前面合并。 出分：$20pt.$ 暴力挂了。不知道为什么。 正解因为只需要求之前的，并且右端点严格递增的区间最小值，因此可以用一个单调线性数据结构维护，考虑到没有对长度的限制，所以用单调栈维护就好。每一次只要维护一个位置的关键字即可。那么我们考虑答案在哪里。 首先答案如果是在栈上面维护的点之外的地方，那么肯定可以在它靠右的最近的一个点上有不劣的答案。那么我们只需要在关键点上更新信息就好。那么我们可以考虑维护每两个相邻关键点中间的区间中的 $f$ 值，而在不断弹出栈顶的时候可以一起记下他们的 $f$ 来继承他们的贡献。因为我们设的 $f$ 是一个前缀的答案，所以可以直接用栈顶来更新当前的 $f_i$，需要注意的是这个点单独成一个区间也需要考虑。 那么写起来就较为容易了。整体而言不算是很难的 $dp$ 优化，但是细节很多了。 $code:$ https://paste.ubuntu.com/p/wGNYdXZg65/ Swap题面 考场是一道有趣的题目，一开始的想法是找逆序对然后直接暴力交换，开始写的时候发现不好写。。 然后随便糊了一个特别慢的东西。就交了。 出分：$0pt.$ 其实逆序对是可以搞的啊，只要把$B$ 关于 $A$ 类似离散化一下就好了啊。。没想到吧。 正解神奇的做法。 首先他说的交换好像很玄学，所以只需要考虑两两交换即可。那你说什么最大最小值。。 那么因为是两两交换，所以交换是可逆的，因此可以通过把 $A,~B$ 变成有序的，再把变换 $B$ 的序列反过来即可。 现在要求的就是多少次交换之后能够让整个变得有序了。什么排序算法呢？冒泡，快排，归并，堆？ 快排的交换好像无法实现，堆就不说了。那考虑归并排序。 分治就普通分治就好，关键是怎么合并。假设我们已经有了两个有序的序列，现在就是要把它们合成一个。 出题人的想法很神奇。我们先让问题好描述一点。对于两个有序序列 $A,B$ 需要让他们通过交换操作变得有序。这里大概借用快排的思想，就是用一个基准数 $x$。找出一个 $x$ 之后，在 $A$ 中找出所有的比它大的序列，拎出来，$B$ 中比它小的序列，拎出来。然后我们发现问题又分半：$A$ 的剩下部分和 $B$ 拿出来的部分都 $&lt;x$ ，剩下两部分都 $&gt;x$ 。但是还有问题：他们不挨着。那么交换就上场了，我们可以通过首尾的交换把 $A,B$ 拿出来的部分分别反转，然后再整个翻转他们两个大区间，（通过选首尾的区间慢慢向中间选，具体可以画图。）这样两部分相互分开了，而内部就连在一起了，这样两边再分治下去，最后再连起来，就是一个有序的序列了。 复杂度呢？因为每一次合并的复杂度也需要分治，每一次翻转是 $O(n)$ 所以单次合并是 $O(n\log n)$ ，所以总复杂度是 $O(n\log^2n)$ 的。对于 $4096$ 的数据 $345678$ 就够了。 $code:$]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.15 模拟赛 题解]]></title>
    <url>%2F8.15%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Vote题面 考场一开始觉得应该是越靠近旁边的越容易被选上，但是写了一个小程序一看不太对。发现已选一定人之后怎么求出他们中的贡献是一定要求的所以开始推这个式子。 首先考虑 $f_i$ 表示前 $i$ 个是选上的，那么向下一个转移。然后可以插一对进去，可以两个赞成，两个反对或者一个赞成一个反对。一个赞成一个反对可以直接转移，但是另外两种情况就不行了，然后我开始走弯路，走了很远很远。。（$f_{i,~j}$ 表示前 $i$ 个 $j$ 被选了没有之类的。。） 然后发现还是暴力吧。就打了暴力，当然前面是一个错的贪心，因为后来我不知道为什么就想着用靠近 $0.5$ 的数。（那样是最小吧。。） 出分：$20pt.$ 果然，数据大的点 $WA$ 了。 正解没错，答案一定是一个前缀后缀，证明如下： ​ 考虑一个数 $p_i$ 的贡献：$Pp_i+Q(1-p_i)=(P-Q)p_i+Q.$ 其中 $P,~Q$ 是之前的答案，发现它其实是一个一次函数，所以极致一定在左右两端取到。证完。 那么左右两端可以 $DP$ 一下了。右边同理所以考虑左边。 $f_{i,~j}$ 表示前 $i$ 个中 $j$ 个赞成的结果。那么转移就从上一个赞成还是反对转移。具体就是： ​ $\Large f_{i,j}=f_{i-1,j-1}\times p+f_{i - 1,j}\times (1-p_i).$ 最后枚举一下 $k$ 个数里面有几个在左边，几个赞成就好，注意答案是对每种选法取 $\max.$ $code:$ https://paste.ubuntu.com/p/qpwqWxVhdk/ Point题面 考场没怎么看，随便想出来了一个 $n^2$ 的暴力，就是枚举答案在哪里，然后向左右扩展找到最远的地方更新答案。 出分：$30pt..RE$ 了。。数组开小了。 重开数组之后： $95pt..????$ 说好的 $5e5???$ 你让 $n^2$ 过？ 正解$n^3,n^2$暴力~~数据水到一定程度。。。所谓的 $n^3$ 过 $5e5,~$ 暴力碾表算。。 题解给的正解因为对于一段序列，如果能够是答案，那么最小的一个数一定就是那个关键数，也一定是序列中所有数的 $\gcd.$ 那么考虑用 $ST$ 表存 $\gcd$ 和 $\min$ ，二分答案判断就好，复杂度是 $O(n\log^2 n)$。 但是它 $T$ 了！！！这玩意没有暴力跑得快！！！ 出题人在题解里面说要卡常才能过，但是暴力过了。。 唯一解释就是出题人卡了 $\gcd!!$ 如果所有的 $\gcd$ 卡满可能是更劣的。。 $upd…:$ 不。。其实我发现是 $math.h$ 里面的 $\log_2$ 这玩意跑的特别慢。 但是他放了暴力。。 $code:$ （$T$ 了的，当然可能就是我写丑了。）https://paste.ubuntu.com/p/VvckND36vP/ 优秀的线性做法 真正的标算记得最一开始的 $n^2$ 暴力吗？这个可以优化的。因为每次是向左扩展一些，向右扩展一些，那么记一个点 $i$ 向右扩展到的点为 $r_i$ ，向左是 $l_i$ ，那么在区间 $[l_i,r_i]$ 中间的点就不可能有更优的答案了，因此可以跳过他们。因此实现起来可以向两个方向扫一遍，每次向右扩展到 $r_i$ 的时候就把 $[i,r_i]$ 的 $r$ 都记成 $r_i$ ，然后从 $r_i + 1$ 继续找即可。这样每个点只会被扩展一次，所以就是线性的了。！ $code:$ https://paste.ubuntu.com/p/yKH42tkcpP/ Actor题面 考场$emm..$ 不会。。考虑暴力吧。 然后第一个点特别小，就打了个表，其他的点放弃了。 出分：$13pt.$ 正解神仙 $DP~+$ 优化。？咕。]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.13 模拟赛 题解]]></title>
    <url>%2F8.13%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Count题面 考场主攻它！ 首先因为它要求所有数不是 $m$ 的倍数，所以首先考虑容斥一下把 $m$ 扣掉。 大概的式子是这样的： ​ $\Large C_{n - 1}^{m - 1}-\sum\limits_{k=1}^{\frac {n}{m}}C_{n-km-1}^{m-1}-\sum\limits_{k=2}^{\frac {n}{m}}C_{n-km-1}^{m-2}-…$ 我一开始想的是把下面一样的合并一下求，但是没有发现简洁公式。而且这个式子本来就是 $\large\frac{n}{m}$ 项的， $n$ 那么大它项数就直接炸了。 所以换一个思路，考虑他们对 $m$ 的余数。因为不被整除，所以原式可以直接表示成 $\sum a_i\equiv A\mod m$ 。所以每一个 $a_i$ 可以转化成对 $m$ 的余数和商两部分，商部分因为没有任何限制，所以可以直接挡板法求，余数部分相当于若干个 $\in[1,m-1]$ 的整数相加与 $n$ 模 $m$ 同余。同样，我们把 $n$ 也分成被 $m$ 组成的部分和被余数组成的部分，因为余数有范围，所以 $n$ 被余数组成的部分 $N’\in [k,k(m-1)]$ 。这个东西规模就从 $10^{18}$ 缩小成 $km$ 了。那我们来看怎么求这些余数部分。 首先是同余，所以 $N’$ 的取值也是以 $m$ 为间隔的，也就是我们可以枚举这个和，复杂度是 $k$ 的，然后还是可以挡板，但是有 $[1,~m -1]$ 的限制。容斥一下？有点麻烦先看看其他的吧。（不麻烦啊这就是正解！！！） 当时我开始想能不能用类似背包的东西递推一下。就是 $N’k$ 的，也就是 $mk^2$ 的。写完之后发现更新的那重可以去掉改成前缀和减，所以单个 $N’$ 的求值部分复杂度就降到 $mk$ 了，总复杂度就是 $mk^2.$ 可以过 $70pt.$ 了！那这个还能优化吗。？可能真的是还可以的，但是时间已经差不多了。写了个对拍发现过了。 出分：$30pt…$ ？？我过了拍还挂分了？然后发现怎么都调不对。 结果最后我写的正解的代码跟他拍还是过了，但是还是WA了。？原因后面会说。。orz… 正解容斥真不难。。就是我上面说的容斥，先不考虑限制，然后减去一个超过了限制的结果，再加上两个超过了等等等。 当时真的就差实现的一步了。。至于实现就是超过限制的时候把超过的那 $m-1$ 减掉在求一个挡板。 然后就是它和前面的 $70$ 暴力过了拍但是 $WA$ 了的情况。。 经过长久的调试，我发现是再求组合数的地方爆了 $ll…$ 因为那是要求 $m$ 的倍数部分，所以是 $\large\frac{n}{m}+k-1$ 所以超级大，然后没取模直接成了 $ret…$ 就炸了。。关键是爆成负数我都不知道因为后面把负数取回来了。。 然后就 $A$ 了。应该不算道难题吧。。 $code:$ https://paste.ubuntu.com/p/dJRMVsjtkW/ 生成函数。？老师说是道板子。。但是没学。。咕。（好像说代码和容斥是一样的。？） Pj普及组？你在逗我。。 题面 考场暴力滚了。 出分： $0pt.~~CE$ 了。。我随机数的 $ctime$ 头文件没打有尖括号。。 正解好像也不算难吧。 首先题目把 $x$ 给你了，就分解质因数，因为质因数之间是独立的。（鬼知道啊。。） 然后发现每个数的质因数指数不超过 $2.$ 然后考虑递推，分别看 $1,~2$ 两种情况。 指数是 $1$ 的时候可以发现就是删除最后一列上的 $1$ 所在位置以及它所在的行，那么一共有 $n$ 个位置，所以就是 $f_i=if_{i-1}.$ 指数为二的时候有两种情况，就是一个 $2$ 和两个 $1.$ 一个二的时候可以类似上面转移，但是两个一就需要再考虑了。 考虑最后一列的 $i,j$ 有两个 $1.$ 第 $i,j$ 行的另一个 $1$ 在或者不在同列。首先要选两个 $1$ 在那就是 $\large C_i^2.$ 1. 不在同列的话我们考虑合并其中的两列（可以 $i$ 的到 $j$ 也可以反过来。），那么就变成了两个 $1$ 在一列上。这个就是 $\large 2C_i^2f_{i-1}.$ ​ 2. 在同列的话我们首先去掉 $j$ 行和最后一列，然后在 $i$ 行另一个 $1$ 的位置变成 $2.$ 这个 $2$ 则考虑上面 一个 $2$ 的处理方法，那么同列情况的总数就是 $\large (i-1)C_i^2f_{i-2}.$ 注意因为上面一种情况我们算过这个一次了，所以要把它减掉。这样就有总的转移式： ​ $\Large f_i=if_{i-1}+2C_i^2f_{i-1}-(i-1)C_i^2f_{i-2}$ 这是对于每一个质因数的，总体而言呢？首先对于他们本身是可以加偶数个负号的，这个可以除了最后一行一列任意加，最后一行一列调整一下乘积即可，就是要乘上 $\large2^{(n-1)^2}.$ 然后乘上每一个质因数的答案即可。 然后线性递推出来记一下有几个 $1$ 几个 $2$ ，快速幂一下回答询问就好。 总复杂度 $O(n+q\log n).$ （$\log$ 在快速幂。） $code:$ https://paste.ubuntu.com/p/fCnZ6myWHn/ Tg 考场暴力滚了。但是还是手玩了几组样例，觉得那个序列挺有意思的，但是没时间了。 出分：$3pt.$ 这个点没有询问。。 正解原来的那个最大下降子序列长度为 $2$ 的排列可以等价于一个前缀最大值序列。 前缀最大值序列是什么？就是每个位置记这个位置前缀的最大值。 为什么呢？对于一个前缀最大值序列，我们考虑改变了最大值的点，称为关键点，那么除去关键点之外的数字，它们必须是从小到大，并严格依次插入到空隙之中的。不然考虑有两个关键点 $i,j$ 中间有两个数 $x,y$ 不是关键点，但是 $x&gt;y,p_x&lt;p_y$ ，那么就会出现一个下降子序列 $i&gt;x&gt;y$ 长度大于 $2$ 了。（$i&gt;x$ 是因为它现在在两个关键点之间，所以 $i$ 在区间 $[i,j)$ 里面是最大值。）就矛盾了，就证明了原命题。 至于出题人怎么想到这样转换就不得而知了。 然后询问呢？寻询问是给出 $x,~y$ 让 $a_x=y.$ 那么两种情况： ​ $x\leq y:$ $y$ 一定在关键点上，不然前面会有一个比它大的点，而前面只有 $x-2$ 位，却要填上 $y-1$ 个数由抽屉原理可知一定有一个比 $y$ 小的数在 $y$ 后面，那就有一个长度大于 $2$ 的下降子序列了。矛盾。​ $x &gt; y:$ 把整个序列反转过来就是上面的情况了。 他是关键点的话怎么求呢？ 考虑前缀最大值序列是什么。一个这样的序列可以看做是在一个坐标轴上，从 $(0,0)$ 走到 $(n,n)$ ，每次只能向上或者向右走，并且不能超过直线 $y=x$ 的方案数。（横坐标是 $i$，纵坐标是前缀 $\max.$）这个应该比较好理解。 那么现在就相当于有一个必经点，那答案就可以直接用组合数求了： ​ $\Large Ans=(C_{(x-1)+(y-1)}^{x-1}-C_{(x-1)+(y-1)}^{x})\times (C_{(n-x+n-y)}^{n -x}-C_{(n-x+n-y)}^{n -x - 1})$ （上面要 $+1$ 是因为要手动过直线 $y=x$） 预处理阶乘快速幂求即可。时间复杂度同样 $O(n+q\log n).$ $code:$ https://paste.ubuntu.com/p/Mz2wnVvhWt/]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.12 模拟赛 题解]]></title>
    <url>%2F8.12%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Maze题面 考场第一眼看到了那个 $n$ 好像特别小，就想着能不能用 $n\times n$ 的正方形来分成很多很多块，然后一起做，至于询问的话想了一下线段树来维护边上的点到另一边点的最短距离（每个节点上开二维数组存），然后写广搜初始化和旁边的情况。至于线段树上的合并可以枚举一下中间从哪里走然后更新整个的答案。 然后。。。分块块 $+$ 线段树加上两边的广搜，我第一次发现线段树写起来简单。最后一个小时开始写的，还没写完就 $250$ 行左右，还没搞完还没调试。没了。 出分：没交。 正解很不幸的是分块和线段树两种都能做。没必要结合在一起。我服了我自己。 分块虽说也是分块，但这是普通的分块，就是分成 $\sqrt m$ 块。 然后也是两边暴力 $bfs$ 然后中间预处理完了就直接跳大块。修改的话是暴力重构是 $O(n^2\sqrt m)$ 的，询问要枚举中间的转移点，是 $O(n^3\sqrt m)$ 的。 总复杂度就是 $qn^3\sqrt m.$ 好像这个开 $O3$ 优化可以过。 线段树跟我前面用的线段树一样但有几点变动。 不需要分组！！！然后每个地方也是二维数组存的是从左端点到右端点的每对点之间的最短距离。转移的时候也是枚举一个中间点转移。然后查询直接分下去，修改直接改单点。 这样复杂度就都是 $qn^3\log m.$ 好写多了。。 $code: $ https://paste.ubuntu.com/p/8qCFTTQkwM/ Mhw题面 考场看上去是个二分图的样子。题目给了两类人，在一定距离下他们有克制关系。那就相当于有向边啊。 因为要求的三点环必须有两条边是横跨两边，另一边在一半上的，所以只需要给那个在一半上的点定向就可以了。那么三点环有几种连边情况：（对于在一边的两点 $x,~y$ 和 另一边上的点 $z$） ​ 1. 对于两条边 $x\leftrightarrow z \&amp; y \leftrightarrow z$ 他们的方向必须是反的。就是： $x\rightarrow z \&amp; z \rightarrow y$ 或 $y\rightarrow z(\alpha) ~\&amp; z \rightarrow x(\beta).$​ 2. 对于上面的两种不同的边的方向，我们要给 $x \leftrightarrow y$ 定向，在最大值的时候就是在所有 $\alpha$ 和 $\beta$ 环里面找到较多的一个给它们定向，最小值则相反。 那么求两点间的边数就可以确定边的方向了。我只会 $n^3$ 的方法。。 出分： $20pt.O(n^3).$ 正解$O(n^3)$ 可以过 $1000????$ （要开 $O3$ 优化别想了。） 线段树扫描线又是你。扫描线。 这玩意跟扫描线有什么关系啊。？ 我们先继续上面的两项向下分析。先把两边的点染色，左边的染白色，右边染黑色。那么我们先考虑所有白点间的边。 我们记白点 $x$ 连向一个黑点的黑点总数是 $f_x.$ 而两个白点 $x,y$ 同时连向一个黑点的黑点总数是 $g_{x,y}.$ 所以对于两个点 $x,y$ 间半环（两条确定边）个数就是 $f_x-g_{x,y}$ 相当于取一个补集。 那么对于所有的贡献就是： $\Large \begin{aligned}Ans&amp;=\sum\limits_{x,y\inS_{white}} \max\{f_x-g_{x,y},f_y-g_{x,y}\}\\\Large&amp;=\sum\limits_{x,y\inS_{white}} \max\{f_x,f_y\}-g_{x,~y}\end{aligned}$ 那么我们再考虑右边的那个 $g_{x, y}$ 能不能也化成 $f_x$ ？ 它的意思就是同时连向了一个黑点，那么反过来就是一个黑点被两个白点连了，那么既然我们还要求一遍所有黑点 $f$ 那么就相当于是对于每一个黑点，选两个连向自己的边的总数。所以把 $f$ 重新定义成连向异色点的。 那么就是：$\large \sum g_{x, y} = \sum\tbinom{f_k}2.$具体而言就是说： $\Large Ans=\sum\limits_{x,y\inS_{white}} \max\{f_x,f_y\}-\sum\limits_{k\in~S_{black}}\tbinom {f_k}2.$ 剩下的就是求所有的 $f_x$ 了。 我们回到最初的连边条件：曼哈顿距离小于等于 $D.$ 这个不太好处理所以常规地把他转化成切比雪夫距离。至于它是什么： ​ 对于两个 $k$ 维的点 $A,B$，其中 $A=(a_1,a_2,…,a_k)$，​ 则他们的切比雪夫距离定义为：$\large\max\limits_{i=1}^k\{|a_i-b_i|\}.$ 曼哈顿距离是什么就不说了。。 那么怎么转换呢？曼哈顿距离只是二维的，所以对于 $(x,y)$，就变成 $(x+y,x-y).$ 但其实理解起来没那么复杂。我们要算的是曼哈顿距离小于等于 $D$ 就是说要在范围内的点集。因为是曼哈顿距离，所以他就是一个斜着的正方形。这个就已经变成了二维的矩形内选点，但是线段树扫描线只能搞横平竖直的矩形，所以考虑把所有正方形旋转 $45^\circ$ 。而这个其实就可以用上面的那个变换。 还有一个问题，就是这样转换完之后长度没变吗？没变！证明如下： ​ 对于两个点 $A(x_1, y_1),B(x_2,y_2)$，​ 他们变换之后变成了：$A’(x_1+y_1, ~x_1 -y_1),B’(x_2+y_2,x_2-y_2).$​ 然后之前的曼哈顿距离是：$|x_1-x_2|+|y_1-y_2|.$​ 现在的切比雪夫距离是： $\max\{|(x_1+y_1)-(x_2+y_2)|, |(x_1-y_1)-(x_2-y_2)|\}.$​ 还记得三角不等式吗：$|a-b|\leq|a|+|b|.$ 和 $|a+b|\leq|a|+|b|.$​ 我们记 $a=x_1-x_2,b=y_1-y_2$，不就是最大值吗？​ 证完。 那么就用线段树扫描线扫以一个点为中心的矩形里面包含的点的数量即可。（前缀点数和。） $code:$ https://paste.ubuntu.com/p/PTvD7P2Yqr/ Factory题面 考场一开始想到思路的竟然是这题。 既然要任意情况都行，所以最后的矩阵一定是一个对角线上全是 $1$ 的正方形的方案。 所以就贪心排个序，然后顺着用并查集记一下现在所在的正方形大小。 然后自己黑了自己。。然后随便排了下序过了，然后交了。 出分：$30pt.$ 贪心是错的。 正解神仙状压 $DP.$ 听了三遍之后感觉差不多了。 首先题目给的一个人会不会操作几台机器给出的一张表其实就可以相当于是一张二分图。 那么一个人会操作就相当于给那个机器连上了一条边。由于上面那个小结论，我们就是需要把每个二分图上的联通块连成完全二分图并且两边点数相等。 证明呢？考虑反证： ​ 如果不连通，那么设人有一些没和 $x$ 连边，那么当和 $x$ 连边的人不做 $x$ 的时候，就没人做 $x$ 了。 ​ 如果联通了但是点数不相等，那么就无法一一分配。 然后我们把每个联通块记成一个二元组 $(x_i,~y_i)$ 那么考虑怎么选这些二元组让代价最小。那么考虑状压 $DP$ 看每个联通块选不选时候的答案。 如可统计答案呢？因为已连边数不变，要加的边数等于总边数减已连边数，所以最小化总边数即可。总边数则是 $\large\sum\limits_{S’\subseteq S}\sum\limits_{i\in S’} x_i\times\sum y_i=\sum\limits_{S’\subseteq S}(\sum\limits_{i\in S’}x_i)^2.$ 最暴力的方法 $dp_S$ 表示选 $S$ 集合的答案，转移则枚举子集，如果子集满足 $\large \sum\limits_{i\inS’} x_i=\sum\limits_{i\inS’} y_i$ 就用它更新答案。复杂度是 $3^{cnt}$ ，$cnt$ 是二元组数量。 然后慢慢优化它。 设 $dp_{S,i}$ 表示现在已选的数是 $S$ ，在处理的联通块里面的 $\sum x=i.$ 那么每次枚举一个二元组加到状态里面即可，然后如果 $S$ 有 $\sum x=\sum y$（之前配好了，现在也配好了，所以总的是好的。），就相当于目前已经可以更新答案了就给 $dp_{S,0}$ 更新。时间复杂度是 $2^{cnt}n.$ 还需要进一步优化。 发现其实不需要把每一个二元组记下来，只需要记每一种二元组出现了多少次。这个可以用一个 $cnt$ 压起来，每次向上枚举就可以了，出题人说其实 $n=30$ 时一共只有 $1.7e5$ 左右种二元组，每一次就只需要枚举一种二元组，那么时间复杂度就是 $O(n\times 1.7e5)$ ，是能过的。空间复杂度可能有点高，但是也不会太大。 $code:$]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.10 模拟赛 题解]]></title>
    <url>%2F8.10%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[因为好像走了就用不了 $jzoj$ 了所以不放比赛地址了。。 Math题面 考场考场上主要玩这题了。能 $A$ 了就值了。。 首先朴素的把答案的式子展开：$\vec a=(x_1, y_1), ~\vec b = (x_2, y_2).$ ​ $\large\begin{equation} \begin{aligned}Ans &amp;=|\lambda_1\vec a+\lambda_2\vec b|^2\\&amp;=(\lambda_1x_1+\lambda_2x_2)^2+(\lambda_1y_1+\lambda_2y_2)^2\ &amp;=\lambda_1^2x_1^2+2\lambda_1\lambda_2x_1x_2+\lambda_2^2x_2^2+\lambda_1^2y_1^2+2\lambda_1\lambda_2y_1y_2+\lambda_2^2y_2^2 \ &amp;=\lambda_1^2(x_1^2+y_1^2)+2\lambda_1\lambda_2(x_1x_2+y_1y_2)+\lambda_2^2(x_2^2+y_2^2)\end{aligned}\end{equation}$ 然后因为 $\vec a, \vec b$ 是给定的，所以可以记 $\large a=x_1^2+y_1^2,b=x_1x_2+y_1y_2,~c=x_2^2+y_2^2.$ 那么式子就变成了：$\large Ans =a\lambda_1^2+2b\lambda_1\lambda_2+c\lambda_2^2$，然后我们研究右边。 首先有 $a\geq 0$ 所以把右边配成定点式有：$\large a(\lambda_1+\frac b a \lambda_2)^2+\frac{ac-b^2}a \lambda_2^2 \geq \frac{ac-b^2}a \lambda_2^2$ 它有什么用呢？ 首先，如果我们枚举一个 $\lambda_2$ 的话，我们就可以通过取 $\lambda_1$ 顶点 $\frac a b\lambda_2$ 附近的两个值就是最小值了。进一步可以发现，因为包含 $\lambda_2$ 的项有平方，而 $\lambda_1$ 又可以根据它来取，所以可以令 $\lambda_2\geq 0$ ，这样它小于零的情况可以通过把 $\lambda_1$ 取反等效成大于零。 其次，我们继续观察它的顶点纵坐标 $\frac{ac-b^2}a \lambda_2^2$ 。因为我们取的 $\lambda_2$ 是递增的自然数，所以它的平方递增的速度就非常快了，那么我们看看它的系数是不是也是非负的，这样就可以提很多速了。首先下面是非负的，也就是正的了，那么上面可以： ​ $\large\begin{equation} \begin{aligned}ac-b^2&amp;=(x_1^2+y_1^2)(x_2^2+y_2^2)-(x_1x_2+y_1y_2)^2\\&amp;=x_1^2x_2^2+x_1^2y_2^2+y_1^2x_2^2+y_1^2y_2^2-x_1^2x_2^2-2x_1x_2y_1y_2-y_1^2y_2^2\\&amp;=x_1^2y_2^2+y_1^2x_2^2-2x_1x_2y_1y_2\ &amp;=(x_1y_2+x_2y_1)^2\geq0.\end{aligned}\end{equation}$ 好的！它是非负的。所以就可以这样做啦！ 然后开始和纯暴力拍，拍了一会改了些错发现没什么问题。 然后随机了几组数据发现跑的飞快。（$300ms\sim500ms $ 加个 $O(2)$ 估计会很快） 出分：$100pt.$ //数据有点水，我这个算法应该能被卡的。 $code: $ https://paste.ubuntu.com/p/x3m5FqDWCw/ 正解那个算法很奇妙，所以还是好好写一下。 首先它是从欧几里得算法过来的。（靠虑共线的时候就是 $\gcd$ 最小。（$ax+by=1.$）） 我们考虑两条向量的夹角到一定程度之后是什么样的。还是从答案出发，这次用点乘： ​ $\large\begin{equation}\begin{aligned}Ans&amp;=|\lambda_1\vec a+\lambda_2\vec b|^2\ &amp;=\lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2+2\lambda_1\lambda_2|\vec a·\vec b|\ &amp;=\lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2+2\lambda_1\lambda_2|\vec a||\vec b|\cos\ang\theta.\end{aligned}\end{equation}$ 其中 $\theta$ 就是夹角了，我们想把前面的 $2$ 消掉？那 $\theta$ 取 $60^\circ$？ ​ $\large\begin{equation}\begin{aligned}Ans&amp;= \lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2+2\lambda_1\lambda_2|\vec a||\vec b|(-\frac1 2)\\&amp;=\lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2-\lambda_1\lambda_2|\vec a||\vec b|.\end{aligned}\end{equation}$ 两个 $\lambda$ 分别取 $0$ 的时候坑定是另一项取 $1$ 最优，那不就是等于 $\vec a^2$ 或 $\vec b^2$？ 那么不取零的时候呢？考虑配方： ​ $\large\begin{equation}\begin{aligned}Ans&amp;\geq|\lambda_1^2\vec a|^2+|\lambda_2^2\vec b|^2-|\lambda_1\vec a||\lambda_2\vec b|\\&amp;=(|\lambda_1\vec a|-|\lambda_2\vec b|)^2+|\lambda_1\vec a||\lambda_2\vec b|\\&amp;\geq|\lambda_1\vec a||\lambda_2\vec b|\geq|\vec a||\vec b|.\end{aligned}\end{equation}$ 那我们不妨设 $|\vec a|\geq|\vec b|$ 就有： ​ $\large Ans \geq \vec a^2.$ $OK$ 了！ 而当夹角更大的时候 $\cos \theta$ 是减小的所以那个东西是大于等于这个六十度的时候，所以同理了。 也就是说把角度搞到 $60^\circ$ 以上就好了？那我们怎么改角度呢？因为我们的 $\lambda$ 是任取的，所以两个向量分别加上一定倍数的对方是没有影响的。（可以通过减对方减回来。）即 $Ans\{\vec a,\vec b\}=Ans\{\vec a,\vec b+k\vec a\}.$ 好的那么我们构造一下。 这里记 $\vec a=\vec{OA},~\vec b = \vec{OB}$，其中 $|\vec a| \leq |\vec b|$考虑两个向量的差 $\vec c=k\vec a-\vec b$ ，那么我们可以直接求 $Ans\{\vec a , ~\vec c\}$ 即可，那么怎么取 $k$ 可以让夹角尽量大呢？ 考虑向量 $\vec b$ 在 $\vec a$ 所在直线上的投影点 $K$ ，然后考虑 $k\vec a$ 在 $K$ 附近，这里假设 $k\vec a=\vec{OA’},~（k+1）\vec a=\vec{OA’’}$ ，而 $K$ 在 $A’A’’$ 上。则： ​ 如果 $|k|=1$ ，那么直接取它就好。 ​ 不然的话考虑哪一个更优，就比较 $BA’$ 和 $BA’’$ 的大小就好。 但其实实现上来说直接取 $k\vec a$ 就够了。 这样慢慢增大夹角直到大于 $60^\circ$ 的话，就相当于是欧几里得里面的不断取模，最后得到答案。 这个复杂度作者也不会证，但是几次就能得到答案的，因为每次增加的角不小。（作者猜测 $log$ 级） 这个复杂度就比上面的剪枝靠谱多了。 $code:$ Treasure题面 考场一看就是爆搜？写了写前两个点，自己造的小数据过了，就没管了。 具体做法就是每一层记录最左最右的宝藏位置，那么他们之间的一定挖过了。然后暴力看走那个就好。 出分：$0pt.$ 正解好像是用斯坦纳树，看了博客不太会。咕。 City题面 考场建树$+DP$ ？ 写了写一个倍增求路径和但是是错的。 出分：$0pt.$ 正解这是个 $IOI2012Day2T1$？？？ 做法还是挺有意思的。 我们考虑如果是一棵树怎么办。就直接树形 $DP$ ，对于一个点 $now$ 记其子树大小 $siz$ ，我们考虑它和父亲连的边的贡献就是 $siz\times(n-siz).$ 那么这道题呢？考虑把它变成树，而我们每一次只考虑横着的或者纵着的联通块。这样就能分别处理出竖向边和横向边分别的贡献，然后累加即可。 是的。就是如此简单，至于横纵交换交换一下横纵坐标即可。 $code:$ https://paste.ubuntu.com/p/Nk5JBZfKRc/]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.9 模拟赛 题解]]></title>
    <url>%2F8.9%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[比赛地址：http://jzoj.net/senior/#contest/home/2835 Cell题面 ### 考场 比较简单的题吧，首先它给出了一种叫传送门的东西要走迷宫，就先看看传送门用来做什么。 它可以被开在墙上，然后在墙边上传送过去。 那么就相当于两个点由一条更近的路连在一起了，那么就考虑最短路，看这个可能连成稠密图，所以跑 $dijkstra$ 。 怎么建边呢？首先两个相邻的不是墙的点之间要连，长度为 $1$，另外在墙边上可以传到其他传送门去。所以墙边上就向每一个对着的墙前的空地连长度为 $1$ 的边。然后最短路。 出分： $0pt. RE$ ？？？？？经过反复检查提交发现我在读图的时候用 $int$ 存了 $char.$ 但理论上没什么事啊。。$orz…$ 改了之后还是没有 $A$ 为什么呢？ 正解仔细读题！发现第二项说明，就是建传送门的时候不需要和墙相邻！那么在四边没有墙的地方就也可以向某一边发传送门，然后走到另一个最近的墙，再在那座墙上开个传送门传到原来发了传送门的地方。也就是对于点 $(i, j)$ 向四个方向拓展到了墙是 $(x_k,y_k),k \in [0,3]$ 那么向每个点建长度为 $\min |x_k-i+y_k-j|+1$ 的边。（这里最近的点可能建了更远的边，但是没关系，因为我们可以直接用以前建好了的相邻空地的边走过去。） $code: $ https://paste.ubuntu.com/p/hbSPW2jsFJ/ 原题：jzoj5781 Tree题面 考场这个，好复杂，没什么想法。。 考虑一下随机吧！既然是二叉搜索树，$n$ 也很小，那就考虑每次随即一个插入顺序，暴力插入更新答案？ 可以的，第二个样例天差地别。。 不管了看 $T3$ 了。。 出分：$5pt..emm…$ 随机化一分没有。。//特判第一个点的 $5pt…$ 正解因为一个二叉搜索树的根可以相当于有序序列上的一个中间点，左边的区间就是左子树，右边的区间就是右子树。因为一个区间 $[l,~r]$ 只可能挂在 $l-1$ 的右边或者挂在 $r+1$ 的左边。所以我们记一下一个区间是挂在哪个爸爸上的。然后我们是知道整棵树的答案，所以可以类似区间 $dp$ 来做。 首先 $f_{l,r,0/1}$ 表示一段区间左端点（$0$）或右端点（$1$）是爸爸，自己就是 $[l+1,r]$ 或者 $[l,r - 1].$ 那么考虑一个普通的区间 $dp$ 是怎么转移的。 首先枚举左端点和右端点，那么我们考虑怎么转移，这里因为是可以把自己的爸爸挂在它爸爸的左边或者右边，再考虑向 $f_{l-1,r,0}$ 和 $f_{l,r-1,1}$ 转移，就有方程： $\Large f_{l-1,r,0}=\max f_{l,k,1}+f_{k,r,0}+\sum_{i=l}^{r}K_i,\quad \gcd(K_{l-1},K_k)&gt;1\\\Large f_{l,r +1,0}=\max f_{l,k,1}+f_{k,r,0}+\sum_{i=l}^{r}K_i,\quad \gcd(K_{r+1},K_k)&gt;1$ 后面的区间和考虑用前缀和预处理即可。并且如果每一次求 $\gcd$ 也会 $T$ 掉，所以两两间的 $\gcd$ 也要预处理。$k$ 跟另外答案是 $\max f_{1,i,1}+f_{i,n,0}.$ $code: $ https://paste.ubuntu.com/p/f2wk9GBwJX/ Rotate 考场题意很简单，先考虑第一个 $30pt.$： $O(n^3)$ 暴力：暴力选区间，暴力反转，暴力找对数。 然后看第二个数据点是个 $O(n^2)$ 的做法，那考虑优化上面那个暴力：不需要暴力找了，可以固定一个中间点，然后一对一对向外面扩展，没扩展一层更新答案。这就有 $60pt.$ 了。（卡到了 $65pt..$） 最后要交题的时候准备推一下一个点到自己的对应位置的式子，发现对于每个点有： ​ 对于点 $i$ 要去的点是 $a_i$ ，如果关于 $k_i$ 对称过去，那么有 $i+a_i=2k_i.$ 然后发现左边的每个点是固定的，所以对应 $k_i$ 也是固定的，那么考虑一下反转区间，发现反转区间的左右端点肯定是有一个固定点的，因为没有的话就没必要扩展开，不扩展是不劣的。（可能把固定点翻没了。）那就可以考虑每一个点的这个 $k_i$ ，更新答案，所以我们需要维护的是反转区间里面 $k_j=k_i$ 的点的个数，反转区间外的前后缀和解决。这个可以用根号算法解决，比如分块？莫队？ 分块写的快些所以当时写的分块，但是没调出来。就算调出来了也要爆空间。。 交的平方暴力。 出分：$65pt.$ 正解莫队（$O(n\sqrt n)$）上面讲的够清楚了，接下来就是把那些反转区间的询问用莫队搞一搞了。应该就是模板了，只需要询问区间内某个数的出现次数即可。//注意维护的是 $v_i$ 也就是 $a_i+i~!!!$ $code:$ https://paste.ubuntu.com/p/nB6h7KSrbx/ 优化上面的平方暴力？（$O(n\log n)$，$\log$ 数据结构（其实可以排序降一点）。）首先上面分块的时候说过一个反转序列的左右端点一定在反转之后是一个不动点，然后就可以记一下一个点的不动点在哪里，挂在那个中间点后面，然后在枚举中间点的时候就可以左右跳只跳到不动点的位置更新答案，这里因为要顺着跳，所以可以用一个大根堆记左端点（或小根堆记右端点），然后一个个跳着更新答案就可以了。因为只有 $n$ 个点，所以只会跳 $n$ 次，加上堆的复杂度就是 $O(n\log n).$ 其实复杂度瓶颈在让每个点后面的数有序，其实用一个线性排序算法就可以总体线性了。（基数排序。？） $code:$ https://paste.ubuntu.com/p/x552Wr74HK/]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.7 模拟赛 题解]]></title>
    <url>%2F8.7%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[比赛链接：http://jzoj.net/senior/#contest/home/2833 Seq题面 考场题目变简单了。这道题一个递推式很显然地看出可以做矩乘。那考虑怎么构造矩阵。 因为他都是前面式子相乘得到的下一项，而递推式里的常数 $b_i$ 又在指数上，可以想到两个等底数的式子相乘就等于他们的指数相加。那么只需要在指数上做矩乘维护一个递推后的指数和就好了。 这么构造矩阵的话，转移矩阵会很好看： $\begin{bmatrix}0 &amp;1 &amp; 0 &amp; …&amp;0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; …&amp;0 &amp; 0\\&amp;&amp;&amp;…\\0 &amp; 0 &amp; 0 &amp; …&amp; 1&amp; 0\\0 &amp; 0 &amp; 0 &amp; …&amp;0&amp;1\\b_k&amp;b_{k-1}&amp;b_{k-2}&amp;…&amp;b_2&amp;b_1\\\end{bmatrix}$ 构造起来也很简单。然后普通矩乘就好。 注意这里跑起来会有点慢，经过反复卡常 $+O3$ 之后本地仍然 $1.6s+.$ 开网之后在 $customtest$ 测了一下发现开 $O3 ~400ms+$，不开 $2000ms+…$ 然后交了 $O3.$ 拍了很久没错就觉得应该是满分了。 出分：$100pt.$ $code:$ https://paste.ubuntu.com/p/87Rk2K453B/ Dream题面 考场挺喜欢题面的。然后发现好像可以直接贪心。因为一个 $t$ 只能对应一个 $[l,~r]$，所以我们可以类似选区间的策略按左端点排序然后尽量选右端点靠左的区间和 $t$ 配对，这样区间更靠右的就有可能和后面的点配对从而有更优的答案。 具体实现起来就把区间按左端点排序，从小到大考虑 $t$ ，每一次首先把所有左端点小于 $t$ 的区间假如考虑中，因为后面的 $t$ 不减而我们要找最小的右端点，所以我们只需要用一个小根堆存这些区间的右端点，在找区间的时候如果堆顶比 $t$ 还要小，就直接弹出，因为它不能和 $t$ 配对就更不可能和 $t$ 后面的数配对。然后如果能配上一个就计入答案并弹出堆顶。（因为有可能一个满足的区间都没有，就是堆为空） 代码也很简单了。 出分：$100pt.$ //其实当时没想要拿满，但好像也举不出反例就交了。 $code:$ https://paste.ubuntu.com/p/n2XGdh5xkT/ tree题面 考场先暴力吧，就是暴力两个点然后暴力中间的点走过了一个点对没有。 然后觉得这个枚举另一个点的过程好像可以在搜出去的过程中解决，但是没往下想。//这个是可以的。 然后开始看特殊数据。 一条链还只有一对点的话，直接左边右边讨论。 菊花图的一对点的话，也可以直接讨论，这个讨论了我很一会。 然后由于第一题卡常卡了很久，谁知道它臭氧优化那么快。。 没时间了。 出分：$20pt.$ //可能讨论挂了吧。毕竟没有造数据看。 正解？？矩形面积并？？神奇。。 还是先从序列上下手的，把问题转化成求不合法的对数，这样原来的答案就是总对数减。 求不合法的对数的话，就是所有包括这两个点 $[l_i, r_i]$ 的一个区间，这样就是要区间的左端点 $\leq l_i$，右端点 $\geq r_i$。这个东西的解集可以看成一个二维的东西，具体而言就是一个矩形，因为它就是所有满足 $x \in [1,l_i],y\in [r_i,n]$ 的点对。这个就是一个矩形了。然后对每一个求一个并就是求矩形面积并了。 这是序列上的，那树上怎么办呢？那我们就在 $dfs$ 序上面考虑就好了。考虑点对 $(x,~y)$就有两种情况： ​ 1. $(x,y)$ 不是相互的祖先，那么一对答案 $(u,v)$ 要满足 $u$ 在 $x$ 的子树里面，$v$ 在 $y$ 的子树里面，那么在一个 $dfs$ 序上就可以直接转化成两段区间。​ 2. $(x, y)$ 有祖先后代关系，不妨设 $x$ 是 $y$ 的祖先，那么一对答案 $(u,v)$ 要满足 $u$ 在 $y$ 的子树里面，$v$ 在整棵树除了 $y$ 所在的 $x$ 的子树里面。这个就是整个区间减一个区间，拆成两个区间即可。 然后就是矩形面积并了。 那它怎么写呢？？？ 既然这个已经咕了很久，今天又是七夕，那就来写一下他吧。这个还是单独放在另一个博客里吧：[矩形面积并] [矩形面积并]: 然后和普通的矩形面积并不同，它的坐标是比较小的，所以不需要离散化，除此之外，因为一对点就算是算面积也只能被算一次，所以要严格保证所有表示矩形区间的横坐标小于纵坐标，大于就换一下，以为换一下不影响计数。而且因为边界都要算上，所以再加矩形的时候吧终边（上边）纵坐标 $+1$ 之后再加，保证上面那条线被算到了。 最后用 $\frac{n\times (n-1)}{2} - cnt$ 就可以得到答案了。 $code:$ https://paste.ubuntu.com/p/BDvhkHGKDy/ 七夕快乐啊！！orz…..]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.5 模拟赛 题解]]></title>
    <url>%2F8.5%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[比赛地址：http://jzoj.net/senior/#contest/home/2831 Game题面 考场比较简单的数学题。//没想到第二道能 $A$ 的题就在今天。 首先发现 $n, m$ 都很大就肯定要行列分开的。因为你开一个数据结构空间也肯定爆了。 分开行列的时候观察每一个点上原始的数字是什么： 第 $i$ 行 $j$ 列是 $(i - 1)\times m+j$ 这个东西好像天然把行和列分开了。 1 2 3 4 5 6 7 8 9 10 11 12 那么我们试着把一张表拆成两张表, 其中一张表是加号前的那项, 另一张是加号后的。（这样做的另一个动机是每一列可以看做是 $m$ 的一个剩余系了。） 表 $1$ ： 1 2 3 4 1 2 3 4 1 2 3 4 表 $2$ ： 0 0 0 0 4 4 4 4 8 8 8 8 其实这样对应相加也能得到原始表格。那么根据乘法分配律, 所有操作可以分别对两个表进行之后求和相加即可得到原表格的答案。 然后发现表 $1$ 里面的每一列是相同的, 表 $2$ 中的数是相同的。所以表 $1$ 中只需要将列的修改做成一个倍数和, 从行的方向扫一遍, 并将它和行的修改以及这一列的数字一起乘起来就是结果了。表 $2$ 中同理。 这样的复杂度就只有 $O(n+m)$ 了, 然后 $n,m$ 同级所以就是线性的了。 出分：$40pt.$ 我求倍数和的时候没取模爆炸了！！！！ 加了就 $A$ 了。 $code:$ https://paste.ubuntu.com/p/CpJXw6vXhR/ Jump题面 考场这个。一个数好像只能向一个地方走, 那就是 $n$ 个点, $n$ 条边, 就是一颗基环外向树啊？ 那么一定有循环了。但是找循环应该是 $O(nm)$ 级别的, 待修改的话就起飞了。 那考虑修改怎么改。因为是一颗基环外向树, 那么边只可能是树边和环边了, 那分类讨论一下： 1. 树边重新接在树上：对环（循环）没有影响直接连. 2. 树边重新接在环上：还是没有影响. 3. 环边重新接在树上：环变大了.搜一下变大的部分. 4. 环边重新接在环上：环变小了.搜一下变成树的部分.然后开始写。然后就没时间了。然后发现这样写每一次修改都要带着 $O(nm)$ 这个肯定就会爆炸了。 然后跟暴力拍 $1$ 个点就 $WA$ 了。细节写挂了吧。。 出分：$20pt.$ （交的暴力。） 正解就是高效地找循环搞循环。 因为循环是 $O(nm)$ 的而且每跳过 $n$ 步所在的一列是重复的。所以我们分块一下, 每一块的长度是 $L =\min (n, m)$ , （这个东西如果 $m$ 比 $n$ 大手动交换它们。）每一次一大块一大块地跳来找循环节, 不在大块顶点就暴力跳。这样找循环的复杂度就是 $O(L).$ 然后一个小优化就是只需要在修改后的第一次查询处找一次循环节。 那修改操作呢。修改操作应该是会去有可能改到前三个点的范围内的答案的, 然后我们分别看每一个点, 首先看它改到了哪一个点, 先从那个点往后跳跳到块地端点上, 然后向前跳, 向前跳发现可能前面的几个数都跳到这里了, 那么发现我们可以从中间向外扩展, 每次只考虑上下界的转移, 因为中间的只能看到后面三个包含在我们考虑区间内的, 一定能走到后面的点上的。（如果连第一行都走不到就不用更新了。） 但是他有一个 $3$ 的常数？//其实我怎么看这个都会 $T…$ $code: $ 原题。？$luogu$ 原题链接：[https://www.luogu.org/problem/P4739]（它开 $8s$ 比赛开 $4s$ ？） [https://www.luogu.org/problem/P4739] :https://www.luogu.org/problem/P4739 Sequence题面 考场想着用线段树 $Hash$ , （我傻啊又没有重复。。）写了 $WA$ 掉了的暴力。//没时间了。。 出分：$0pt…$ 正解$80pt.$$100pt.$ 的卡常线段树 $/ ST$表因为要是一段优美的序列 $a_{i…j}$, 里面的就需要是 $[\min_{i…j},\max_{i…j}~]$ 中的所有数都要包含在内的, 就是说 $[\min_{i…j},\max_{i…j}~]$ 中即使是最左边和最右边的数都要在这个范围内, 因为他已经天然离散化了, 所以可以根据一个数字出现的位置得到一个新序列, 而优美的序列就是说两个序列的长度是一样的。这样通过反复地来回映射就可以找到一个最短的包含自己的序列了。（因为每一次映射都是一个必须满足的条件得到的一个新区间, 而区间长度递增, 所以第一次的就是最短的。） $eg.$$\quad A~=\{ 3,1,7,5,6,4,2\}\\\quad A’=\{ 2,7, 1,6,4,5,3\}$那么例如 $[3, 6]$ 就是一段优美的序列, 因为 $A$ 序列中的最大最小值对应区间 $[4,7]$ 长度和原序列中的 $[3,6]$ 长度都是 $4.$ 那么我们就是需要查询两个序列的区间最值, 线段树 $/~ST$ 表, 因为线段树查询带 $log$ 而且常数大, $ST$ 表肯定就是更好的选择。 分治没人会。。题解讲的好像很随意。网上说得好像用线段树扫描线？ 严格 $log$ 的线段树考虑一个优美序列满足什么样的性质。首先它肯定是由连续数字组成的。（废话那是定义。） 称每两个连续数字是一个连续数对的话，那么对于一个优美序列而言就有： $l+num=r ~IFF ~a_{l,…,r}是一个优美序列$.（其中 $num$ 是连续数对个数） 证明的话这个东西显然的：排好序之后是从 $Min$ 到 $Max$ 的一个连续序列, 中间自然就有 $r-l$ 个连续数对了, 逆命题同理。 然后我们考虑怎么维护这个信息。可以首先考虑把询问离线下来并从左往右考虑右端点 $i$ 框定包含询问的右端点的优美序列。 这样首先可以保证右边的 $r$ 是一个有序的。 然后考虑每一次来到一个右端点 $r$ 的时候考虑用它所组成的连续数对更新能够成立的等式左边就可以了。这样的话首先考虑每个点初始就会有一个自己位置的值 $pos.$ 然后通过后面和它后面的数（包括它）构成的连续点对更新自己的值以得到答案。那么每次的右端点更新左边的值就是更新一个前缀和，那么区间加。 再考虑怎么得到答案。每次需要的是最右边的一个在询问的左端点左边的点，那么怎么保证呢？观察式子的左边，发现这个东西每一次可能受到 $+0,+1,+2$ 三种影响，这个不太好处理，而考虑到每一次右边是肯定会 $+1$ 的，所以我们考虑改变的差值。差值就只可能 $-1,+0,+1$ 因为 $num$ 初始为 $0$ 时左边是小于右边的，而每次 $+1$ 就又可以保证这个差值是一个一个缩小的，所以如果出现了答案，这个值一定是整个前缀中最大的之一。那么区间最大值。 区间加 $+$ 区间最大值：线段树。 $\rightarrow$ 严格 $O(n\log n)$ 算法。 $code: $ https://paste.ubuntu.com/p/WgP6sm3MQH/ 原题。？？$luogu$ 原题链接：https://www.luogu.org/problem/P4747（它开 $3s$ 比赛开 $1s$ ？？？）]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.4 模拟赛 题解]]></title>
    <url>%2F8.4%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[比赛地址：http://jzoj.net/senior/#contest/home/2827 Forging题面 考场本来可以第一次考场上 $A$ 题，结果卡空间！我开了 $ll$ 就炸了！$int$ 就过了！而且他还卡常数。。（我 用 $cout$ 他最后一个点就 $T$ 了。）//终于可以考场正解一起写了。 首先理解一下题意，就是两个相邻级别的剑合在一起，有 $p$ 的概率成功合成更高一级的剑，有 $1 - p$ 的概率变成较低级别的剑，就相当于较高的剑没了。发现这个东西 $DP$ 是搞不定的，因为他有后效性而且还要有一个无穷的极限。这个就好像就要推式子。？ 先看看部分分吧： 特殊性质？$p = 1$？那概率不就是 $1$ ？好了 $40pt.$ 到手，直接递推 $f_i = f_{i - 1} + f_{i - 2}.$ $n = 0$？那不就是 $a$ 吗。 $n=1$？好像就必须推式子了。先试试吧。 ​ $f_0=a+(1-p)a+(1-p)^2a+(a-p)^3a…$ //解释一下就是直接到自己，失败一次回到自己，失败两次….直到无穷。 $&lt;=&gt; f_0 = \sum_{i = 0}^{\infin}(1-p)^ia$ $&lt;=&gt; f_0 = \frac{a}{p}$ 这个就很好看了。 然后同样的考虑 $f_1=a+\frac{a}{p}$ 因为有 $1-p$ 的概率要损失一个所以类似上面的一个求和可以得到这个式子。那这个部分分就好了。 $n\leq1e7$？这个由上面的推导就容易了。可以类似的发现这个式子：$f_i=f_{i - 2}+\frac{f_{i - 1}}{p}.$ 因为损失的是上一个。 然后就可以递推了。但是 $1e7$？逆元要线性推了。 但是： 出分：$0pt…MLE…$ 空间！不能开 $long long!$ 不能开 $long long!$ 不能开 $long long!$ 开了就炸了！ 其实时间也要卡一卡不过还好。//比下一题好多了。。 $code: $ https://paste.ubuntu.com/p/4Rr2YVXMZS/ Division题面 考场看完题发现看数据范围可能可以分一个一个质因数来做，但是怎么合起来呢？岂不是要求一个并？？不知道。先看看部分分吧。 前四个点好像可以直接暴力。（其实第三个点数据太多了 $A$ 不掉，而且第二个点也没过。） 第五个点？$n==2$ ？手动因式分解发现只可能有两个，然后手动讨论情况。然后 $WA$ 了。。 出分：$20pt.$ 正解没错！就是一个一个做再合起来。这里考虑一下一个叫中国剩余定理的东西来看怎么合。 中国剩余定理说的是：如果有若干个互质的数为模的同余方程的话，他们的通解可以表示每个同余方程的解乘上其他所有的数除自己模数外的模数之积和其逆元，再加上若干倍的所有模数之积。 代数表示如下： ​ 对于 $c$ 个同余方程： ​ $\Large (S)=\begin{cases}x\equiv a_1(\mod p_1)\\x\equiv a_2(\mod p_2)\ \quad.\\\quad.\\\quad.\\x\equiv a_c(\mod p_c)\\\end{cases}$ ​ 满足 $gcd(p_1, p_2,…,p_n)=1$ 则有： ​ 记 $P=\prod p, \quad P_i=\frac{P}{p_i},\quad inv_i\times P_i\equiv 1(\mod p_i)$ 则： ​ 通解为：$X=\sum_{i = 1}^{c} a_iP_iinv_i+kP$ 为什么呢？可以考虑上面的 $X$ 的每一项 $i.$ 把包含 $a_i$ 的一项分离出来的话，其他项里面是有一个 $P_j$ 的，它里面一定包含了 $p_i$ 所以被 $p_i$ 整除。而 $a_i$ 这一项本身是余 $a_i$ 的，因为 $P_iinv_i$ 再模 $p_i$ 意义下是 $1$ 所以方程就成立了。 这个有什么用吗？当然。考虑用我们的每个方程替换上面的方程，那么解就一定能够用下面的通式表示。每一个解都可以去表示，而我们每一个方程可以算出来有 $cnt_i$ 个解，那么乘法原理答案就是 $\prod cnt$ 了。好了！解决了！ 那么就一个一个暴力试吧。还有一个问题，因为数据有 $50$ 组并且每组复杂度 $5e5$ 总的就是 $2.5e7$ 但是我们还要求一个 $x^m$ 呢？快速幂就直接 $T$ 了啊。。怎么解决？ 一个新的神奇的东西：线性（欧拉）筛。 这个东西可以解决几乎所有积性函数的线性求前 $k$ 项的值。怎么做的呢？ 类似很久以前学的筛素数的欧拉筛，就是每个数再最小质因子的地方被标记。那这个的意思呢？就是每个数对应的积性函数值再最小质因子的地方被计算！这样就只需要再所有质数的地方计算一次值，其他地方直接用之前的和最小质因子更新就好了。 具体实现很简单： 1234567891011for (int j = 2; j &lt; val; ++j)&#123; if (!book[j]) pr[++cnt] = j, f[j] = cal(j);//在质数的地方计算一下。 for (int k = 1; k &lt;= cnt &amp;&amp; j * pr[k] &lt;= val; ++k) &#123; f[j * pr[k]] = f[j] * f[pr[k]];//其他地方直接乘起来，因为是积性函数。 if (j % pr[k] == 0) break; &#125;&#125; 然后还是要卡常。往死里卡。再加 $O2,O3$ 优化。然后经过 $12$ 次的卡常 $+$ 调试终于 $A$ 了。 $code:$ https://paste.ubuntu.com/p/3fqt7SGcQn/ Money题面 考场一看。哎呀不是 $LCT$ 吗？哎呀没学过。看部分分。 $10pt.$ 直接暴力。 $30pt.$ 直接暴力 $+$ 倍增。 后面就不会了。 然后倍增没调出来。 出分：$10pt.$ 正解没错就是 $LCT.$ // $log^2$ 的 但是其实还有倍增的做法可以 $A$ 掉。//还能一个 $log$ ！？ 咕。]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Ftest%2F</url>
    <content type="text"><![CDATA[![123](1.jpg)]]></content>
  </entry>
  <entry>
    <title><![CDATA[8.2 模拟赛 题解]]></title>
    <url>%2F8-2-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[比赛地址：http://jzoj.net/senior/#contest/home/2825 Attack题面 考场点开发现第一题就是一个数据结构。然后既是二维的还是一个求第 $k$ 小还是一个待修改的，那岂不是要一个四维的数据结构来弄。？ 先想了想用二维线段树套树，然后发现以前连二维线段树都没写过瞬间放弃了。 然后打了个暴力。 出分：我暴力打错了挂成一个小数。//出题人手抖把时限开成了 $10s$ 让暴力能 $A$ 当然要优美一些的暴力。。 正解其实就用暴力吧。一个优化就是不是每次询问的时候根据值排序，而是预先排好序之后去顺序选，就能保证递增了。这个可以做到严格 $O(nm)$ 但是修改可能做不到 $O(1)$ 了。 标准复杂度的东西题解上是划分树可以学学。或者是一个什么整体二分加树套树。。//有时间的话。。 $code: $ ​ 暴力：https://paste.ubuntu.com/p/trfdZHK8YY/ Bomb题面 考场主要写这题了。还花了几乎所有时间在一个很简单的问题上。。 先考虑三个点的曼哈顿距离是什么。可以发现就是包住他们的一个矩形的周长。而一定有一个点在定点上。（另一个点可能也在，但是没关系。。）然后记录一个横纵坐标的前后缀最大最小值就可以了。（有 $8$ 个。。） 最小值参考平面最近点对。但是正确性有问题。因为不能用前后 $6$ 个数的优化了。这个直接用答案框范围的话直接 $T$ 。然后卡时限吧。最多就能卡到 $70pt.$了。 出分：$70/100$ $WA$ 了 $30$ 的是正确性。（是有人用分治 $A$ 掉的，后面具体说。） 为了纪念这里贴一下最大值的代码：（自动忽略最小值部分就好） $code:$ https://paste.ubuntu.com/p/PMbm6Pknm3/ 正解首先看最大值。最大值可以有正确的贪心。考虑 $8$ 个特殊点，就是八个角上的点。（类似一个正八边形） 但是我不会证。所以还是用我上面那个 $O(n)$ 的贪心做也是可以的。虽然很麻烦。 然后是最小值。有两一种方法：线段树。乱搞贪心 贪心分别以 $x+y$ 和 $|x - y|$ 为关键字排序，取后 $10$ 个来查找。但是会被一个算法卡掉：网格图。一个转了 $45^{\circ} $ 的正方形。 怎么办呢。可以以 $x$ 为第一关键字，$y$ 为第二关键字排一遍做一遍就可以了。 但其实还是只有 $95pt.$ 因为出题人可能真的故意卡了。可能就只能拿到这么多分了吧。先面向数据过了它再说。 其实有一种万全的策略：以这个点为中心的一个转了 $45^{\circ} $ 的正方形。但是查出来它可能复杂度高了。 $code: $ https://paste.ubuntu.com/p/tqbRYFPjHV/ 线段树这个是正解了。 题解里面的就是。和第一题一样有时间打吧。 优秀的分治这里其实就是我考场上的类似做法。但是更优秀。 首先我们拿出来保证 $|p[i].x-p[mid].x|&lt;ans$ 的所有 $i$ 然后考虑怎么优化一个顺序能够更快速的求值？ 因为一个点还有 $y$ 的一维，所以就可以给 $y$ 排个序，然后每一次保证选的点的 $y$ 值在 $[p[i].y - ans, p[i].y]$ 里面就好了，其中 $p[i].y$ 是最右边的那个点。 就可以 $A$ 了！ $code: $ https://paste.ubuntu.com/p/sMfKgftmdd/ Contra题面 考场想了想这个 $p$ 可以二分答案啊。然后概率 $dp$？然后想了一会没想出方程来，就放弃掉了。 主要原因其实是第二题看起来很可做就去肝它了 出分：没提交。 正解$aaa…$就是二分答案。没事，然后就是一个普通的 $dp$ 吧。这里首先想到的是可以用期望直接 $dp$ 的。但是可以发现他求的是一个分数和，这个就可以不用做一个部分的期望了，就可以直接把每一步的累加到最后的答案里面。具体就是： $\Large dp_{i + 1, j + 1, k + 1} += p \times dp_{i, j, k}$ $\Large dp_{i + 1, j - 1, 0}+=(1 - p) \times dp_{i, j, k}$ $\Large Ans += dp_{i, j, k} \times p \times (j + 1)$ 然后我调了近乎3，4个小时没跳出来。$orz…$我不调了我直接上矩乘。。 这个东西就是一个直接从第 $i$ 层转移到第 $i + 1$ 层的方程了，考虑建一个转移矩阵。 先把状态压起来压成一列（$Q \times R+1$，最后一列存答案）。 然后考虑转移方程。这个肯定就是一个 $(Q \times R+1) \times (Q \times R+1)$ 的矩阵了。这个玩意里面就是上面的方程，然后就是在 $dp_{i, j, k}$ 的地方换成 $1$ 就好了。因为是要矩乘的。就可以直接快速幂了。 然后其实初始状态所在的那一行的答案了。(整个矩阵 $Matrix_{S1, S2}$ 的意思就是从 状态 $S1$ 转移乘出来的多少步之后到达 $S2$的概率，然后最后一行也就是期望) 就差不多了。 这里需要注意以下几个细节点： 初始化的时候在注意 $Matrix_{i,i}=1.$ 因为这个状态转化成自己本身的概率就是 $1.$ 最开始的初始矩阵需要注意 $Matrix_{cnt, cnt} = 1.$ 因为所有的答案是要累加在一起的，所以 $cnt$ 的地方应该每次继承。 时间优化： 忽略到一些不存在的答案的转移。比如 $Matrix_{i, j} = 0$ 的时候就不要去算了。 考虑 $ikj$ 优化，就是先枚举 $i$ 再 $k$ 再 $j$ 这样可以顺便把 $a_{i, k}=0$ 的时候过滤掉（上面那个）可以拿掉一层循环的复杂度。 精度问题。必须开到 $1e-11$ 才能过所有点。实际上可以卡时限开满。 然后就终于可以 $A$ 了。 $code: $ https://paste.ubuntu.com/p/S8WYHmxcRz/]]></content>
      <tags>
        <tag>-模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.1 模拟赛 题解]]></title>
    <url>%2F8-1-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[比赛地址：http://jzoj.net/senior/#contest/home/2821 水叮当的舞步题面 考场这个名字好熟悉。？ 贪心一下？直接看看左上角所在的联通块外接的颜色中最多的然后去改那种颜色？先写了出来，发现不是一点难写。 手造数据发现好像贪心有问题。那么看外接颜色中联通块内个数之和最多的去改？发现过了手玩的样例。 感觉可以$A$于是开始看后面的题。//打个暴力都好。$orz..$ 出分：$0pt..$ 多测清零之后$10pt.$ 贪心错了。$orz.$. 正解搜索优化。。 首先最朴素的搜索：直接搜每一次跳什么颜色。 然后剪枝： 迭代加深，就是搜1层，2层…慢慢地搜下去。 如果剩下的部分中不同的颜色个数加上现在已经进行的操作个数已经超过了现在搜的层数直接减掉。 这样就可以$A$了。 $code: $ https://paste.ubuntu.com/p/DXr5JSwKqd/ Vani和Cl2捉迷藏题面 那么就是要求一个一般图的最大独立集。NP问题啊。。。 只能过20pt.的点。正解估计是什么神仙做法了。 出分：因为看错题爆零。 正解好的，他就是一个$DAG$然后那个互相望到的意思是一条路径上的前面的点可以看到后面的所有点。那就是在$DAG$上的最大独立集了。然后就可以拆成入点和出点，做一个最小路径覆盖数 $cnt$（就是最大匹配数），然后直接用 $n - cnt$ 就可以了。 二分图求一个最大匹配数直接匈牙利或者 $dinic$ 就可以了。//这是最简单的一题。。 $code: $ https://paste.ubuntu.com/p/RzNnpvkqdZ/ 粉刷匠题面 考场容斥？不太行。暴力吧。看起来可以$dp$然后想了好久发现最朴素的dp都要爆炸然后放弃了。 出分：暴力又没清零$40pt =&gt; 30pt..$ 正解两个老师讲了两种，下面分别介绍。 两维比较简单的DP考虑 $dp_{i, j}$ 表示已经选好了前 $i$ 种颜色，其中有 $j$ 对相邻的同色。 然后考虑转移，现在考虑怎么转移到 $dp_{i+1}$上去。首先需要把 $c_{i+1}$ 个桶分成 $k$ 组，然后再把这 $k$ 组插到前面的 $\sum_{a=1}^{i}c_{a}$ 的空里面。然后因为可能插进去之后把相邻同色的给破坏了，因此需要枚举一个 $t$ 表示有 $t$ 个相邻同色被破坏了。那么转移方程就可以写出来了： $\Large dp_{i + 1, j + c_{i+1}-k-t} +=dp_{i, j} \times C_{c_{i+1}}^k \times C_k^t \times C_j^t $ 然后就可以 $A$ 掉了。这个调起来是有点恶心的。 $code: $ https://paste.ubuntu.com/p/HWJrPTG566/ 七维很暴力的DP先咕吧。。]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树扫描线]]></title>
    <url>%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%89%AB%E6%8F%8F%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[简述线段树扫描线算法准确的来说就是用线段树维护在一个二维空间中的一根和 $x$ 轴平行线上的信息（$y$ 轴同理），通过把这跟扫描线从下向上扫一遍，就能得到二维平面上的一些信息。 而因为维护的是一个水平的直线，所以一般就是求矩形相关的信息了。 由于矩形有一个固定范围，因此我们一般将它分成上下边两个区间，一个加上操作，另一个消除操作。这样在中间算上这个矩形的贡献就可以了。下文称这些直线（区间）为关键直线，因为只有这里可能让线上的信息变化。 至于具体的维护什么信息就因题目而异了。 时间复杂度就是线段树的 $\log$ 加上离散化的二分 $log$，总的还是 $O(n\log n)$ 的。 最典型的例题就是矩形面积并了。 矩形面积并Atlantis 题面上的数据很小，但用线段树做扫描线是 $O(n\log n)$ 复杂度的。 我们想用一条线从下向上扫一遍来求矩形面积并，我们考虑每条关键直线怎么更新答案。因为求的是面积，所以要考虑的是两条直线之间的答案。因为是求所有矩形的面积并，所以每次两条关键直线之间的面积一定是若干个宽是两条直线之间距离的矩形面积之和，就维护每一次的长有多少与宽相乘即可。由于坐标是实数，先离散化，然后用线段树维护直线上被覆盖的区间长度即可。这个将矩形下边记为 $+1$，下边记为 $-1.$ 这里可以用到一个技巧：不把标记下放，因为每一个区间的加上后是会被整体减去的。因此是否被覆盖可以只考虑着一个点是否被整体覆盖，若没有则看两个儿子。另外，因为是区间长度，所以需要记录的不是点而是区间，所以把每个区间右边的区间信息弄在左端点上即可。 //注意实数啊，$lower_bound$ 找离散化也要开 $double..$ $code : $ https://paste.ubuntu.com/p/m4nyPVfvvK/ 除此之外用于维护扫描线上的其他信息也是可以的，比如最大值。 最大 矩形权值交之和窗口的星星 首先因为窗口大小是固定的，那么考虑一颗星星在窗口中的位置（如果被选中），那么他一定会在 $w\times h$ 的矩形内部，因此如果固定一颗星星在一个窗口的左下角，计算这个窗口内的所有部分的最大值（每个位置初始值是自己的值，其他星星的窗口交过来了就加上那颗星星的值）就是包含这个星星的最佳答案了。 那么我们就是要维护一个矩形内的交的部分的和，然后求最大值。 还是一样，考虑用一条扫描线，每一次拓展到一条矩形边的时候直接区间加它的权值，然后拓展完的时候求最大值。因为坐标还是很大所以还是要离散化。 注意，在以纵坐标排序的同时，需要保证一条线上先加再减，不然可能把答案给减没了。 $code:$ https://paste.ubuntu.com/p/6BxXC5T34B/ 其他这里列举一下出现的方法吧。 矩形内点数和 矩形面积交 矩形外周长]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[维护区间不同颜色]]></title>
    <url>%2F%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E4%B8%8D%E5%90%8C%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[其实就是这道题：HH的项链 离线转化成一个单点修改区间查询的问题。这样就可以用线段树或者树状数组做了。//用树状数组简单多了。。 先把所有询问以右端点排序，然后慢慢向后解决。 记录一下每个颜色最后出现在的地方，然后如果这个地方又出现了那种颜色的话，就把之前那个地方的颜色抹掉，然后在这里记上这种颜色，在更新表示每个颜色最后出现的数组。 code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define NO 600100#define MO 1000005typedef long long ll;//by Oliverusing namespace std;ll read()&#123; char ch = ' ', last; ll ans = 0; while (ch &lt; '0' || ch &gt; '9') last = ch, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') ans = ans * 10 + int(ch - '0'), ch = getchar(); if (last == '-') return -ans; return ans;&#125;//headint n, a[NO], m, d[NO], last[MO];struct node&#123; int L, R, pos, ans;&#125;asks[NO];//variableint lowbit(int x)&#123; return x &amp; -x;&#125;void add(int val, int pos)&#123; for(int i = pos; i &lt;= n; i += lowbit(i)) d[i] += val;&#125;int ask(int pos)&#123; int ans = 0; for(int i = pos; i; i -= lowbit(i)) ans += d[i]; return ans;&#125;bool cmp1(node i, node j)&#123; return i.R &lt; j.R;&#125;bool cmp2(node i, node j)&#123; return i.pos &lt; j.pos;&#125;void init()&#123; n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); m = read(); for(int i = 1; i &lt;=m; i++) asks[i].L = read(), asks[i].R = read(), asks[i].pos = i; sort(asks + 1, asks + m + 1, cmp1);&#125;//functionsint main()&#123; init(); memset(last, 0, sizeof(last)); int now = 1; for(int i = 1; i &lt;= m; i++) &#123; for(; now &lt;= asks[i].R; now++) &#123; if(last[a[now]]) add(-1, last[a[now]]); add(1, now), last[a[now]] = now; &#125; asks[i].ans = ask(asks[i].R) - ask(asks[i].L - 1); &#125; sort(asks + 1, asks + m + 1, cmp2); for(int i = 1; i &lt;= m; i++) cout &lt;&lt; asks[i].ans &lt;&lt; endl; return 0;&#125;//main 其实这题应该还可以用一些其他方法做(莫队之类的)。但是其实是卡不过去的，（最好成绩也只有90pt..） 然后这种思路还可以去维护不止数量不少于$2$个的颜色数量等等。//一道贪心模拟赛上的题。 此外好像也可以用主席树做。学了更。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-树状数组 -离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[head]]></title>
    <url>%2Fhead%2F</url>
    <content type="text"><![CDATA[保存于此，以便在外机登陆时取用。 另，需使用线段树时或其他定义时可自行修改，以免引起歧义而编译错误，这里不以添加。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#pragma G++ optimize (2)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define INF 0x3f3f3f3f#define NO 30005#define MO 100005#define mp(x, y) make_pair(x, y)#define fi first#define se second#define lln putchar('\n')typedef long long ll;typedef double db;using namespace std;typedef pair&lt;int, int&gt; pii;inline ll read()&#123; char ch = ' ', last; ll ans = 0; while (ch &lt; '0' || ch &gt; '9') last = ch, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') ans = ans * 10 + int(ch - '0'), ch = getchar(); if (last == '-') return -ans; return ans;&#125;void write(ll x)&#123; if (x &gt;= 10) write(x / 10); putchar(x % 10 + '0');&#125;//head//variablevoid init()&#123; &#125;//functionsint main()&#123; init(); return 0;&#125;//main]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
</search>
