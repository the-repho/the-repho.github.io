<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>汇文2020寒假经贸会 腾讯计算机 复盘（未完）</title>
    <url>/%E6%B1%87%E6%96%872020%E5%AF%92%E5%81%87%E7%BB%8F%E8%B4%B8%E4%BC%9A-%E8%85%BE%E8%AE%AF%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%A4%8D%E7%9B%98/2020/01/sol/</url>
    <content><![CDATA[<h1 id="第一财年"><a href="#第一财年" class="headerlink" title="第一财年"></a>第一财年</h1><h2 id="1-18-上午"><a href="#1-18-上午" class="headerlink" title="1.18 上午"></a>1.18 上午</h2><p>分别在交行，建行，中行开户，存款分别为 $4$ 亿，$3.45$ 亿，$3$ 亿。</p><p>出了初始项目，《诗雨数据中心》，进行了项目估值。</p><hr><h2 id="8-00"><a href="#8-00" class="headerlink" title="$8:00$"></a>$8:00$</h2><p>向<strong>建行贷款 $3$ 亿五年期，利息 $5.1\%$</strong>，像交行贷款 $3$ 亿五年期，利息未谈妥（$3.5\%$ 被主席团撤回）。</p><p>债券 $2$ 亿六年期，起初希望以联席的方式向中建，中信，招商发债，债券承销分 $3:3:4$，承销费 $0.6\%:0.6\%:0.7\%$，商榷后中建提醒联席制度的具体方案，中信退出，将债券分为<strong>两笔每笔 $1$ 亿 $6$ 年期</strong>。</p><a id="more"></a>




<p>股权融资，唯品会出资 $1.2$ 亿元，持股 $5\%$，收入 $1.2$ 亿元。</p>
<p>将中行存款 $3$ 亿全部转入建行。<strong>启动《诗雨》项目，花去 $10.8$ 亿元。付款银行与收款银行为建行</strong>，建行余额 $0.4$ 亿元。</p>
<p>研发项目，类型游戏，花费 $1$ 亿元。</p>
<p><del>等了一晚上的房间到了快 $1$ 点。</del> </p>
<p>晚上没办法跟交行谈利息，于是舍弃交行的贷款，向中行贷款 $3$ 亿五年期，利率 $5.05\%$。</p>
<p>字节找我们合作他们的《星宇中文网》项目，要谈 $2$ 亿的投资，股权。发现是个暴利，半忽悠地让他们接受了 $35\%$ 的要求。</p>
<p>诗雨的项目启动通过审批。</p>
<h2 id="第一会期总结"><a href="#第一会期总结" class="headerlink" title="第一会期总结"></a>第一会期总结</h2><p>主席说的很对，<strong>我们拖得太慢了。</strong></p>
<p>你发现一整场会期只发了个债贷了个款划了个股权，而且并没有整完。</p>
<p>主席说的很对，<strong>我们花太多时间在利率的商榷上了。</strong></p>
<p>可以发现在第一会期以及在会前的讨论上有大部分，几乎所有的企业银行间的合作都在谈利率。但是项目才是企业真正的财源，所以应当尽快把项目推进。</p>
<hr>
<p>首先把上一个会期贷款的烂摊子收了，把交行不明不白地贷款还了，把交行里所有的钱转到了中行。至此交行没有余额，中行剩余 $3.45$亿元。</p>
<h2 id="1-19-9-53"><a href="#1-19-9-53" class="headerlink" title="1.19 9:53"></a>1.19 9:53</h2><p>把唯品会《诗雨》的 $5\%$ 股权转了。</p>
<img src="/%E6%B1%87%E6%96%872020%E5%AF%92%E5%81%87%E7%BB%8F%E8%B4%B8%E4%BC%9A-%E8%85%BE%E8%AE%AF%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%A4%8D%E7%9B%98/2020/01/sol/%E8%82%A1%E6%9D%831.png" class="股权1">

<p>联系字节把股权划转协议签了，可以算是跟字节交了个朋友，奠定后期合作基础。</p>
<p>然后需要报利率区间，中建定在了 $4.0\%\to5.0\%$，招商定在了 $3.7\%\to4.7\%$。</p>
<p>第一年的债券簿记环节，首先有我们自己的两笔债，另外我们以不低的价格认购了两笔债（光线 $3.3\%\to5.3\%$ $1$ 亿，爱尔眼科 $4.5\%\to6.5\%$ $1$ 亿），都没中标。朱老师说了国债的质押式回购，然后我们发现很赚，认购了 $2$ 亿的国债，但是中建跟我们说已经晚了。售出后最终债券利率为 $3.7\%$ 在招商和 $4.0\%$ 在中建，承销费率均为 $1.5\%$，招商部份售给中信 $0.5$ 雅诗兰黛 $0.5$，中建售给雅诗兰黛。承销商不愿负责每年利率汇总，由席位自己完成。</p>
<p>追加了 $9000$ 万元的《诗雨》追加投资，完全没有必要地缩短建设周期。这将近 $1$ 亿就是完全做了慈善打了水漂给主席团当作拜年了。<strong>这是极其严重的错误。</strong></p>
<p>转了承销费。总计支出 $300$ 万元。</p>
<p>会场拍了第一块地，我们开始等项目下来（水会），就过没等到。</p>
<p><strong>推年了！</strong> 与此同时，第二会期结束。</p>
<hr>
<h1 id="第二财年"><a href="#第二财年" class="headerlink" title="第二财年"></a>第二财年</h1><p>联系两家认购债券的企业谈债券的事，让他们交付本金我们交付利息。（中信得 $5000$ 万元本金，付 $185$ 万元利息；雅诗兰黛得 $1.5$ 亿本金，付 $585$ 万元利息）</p>
<p>清还第一财年的贷款利息（中行 $1515$ 万元，建行 $1530$ 万元）。</p>
<p>研发文化传媒类项目，支出 $6000$ 万元。</p>
<p>获得文化传媒类项目《汇文炸裂经纪工作室》，进行项目分析，决定不进行股权融资。并发 $1$ 亿债券三年期。</p>
<p>购入 $2$ 亿同仁堂 $6.0\%\to6.3\%$ 债券，猜测由于款项不足未中标。</p>
<p>经过催，主席团把游戏项目发了，《跳跳球》，是个很小的项目，感觉没必要做，于是谈转让，找到了瑞银想要，经过商讨决定以 $1.5$ 亿卖出，并签订了股权划转协议。算上研发开支净赚了 $5000$ 万元，这是第一桶金，但现在已经第三会期了。</p>
<img src="/%E6%B1%87%E6%96%872020%E5%AF%92%E5%81%87%E7%BB%8F%E8%B4%B8%E4%BC%9A-%E8%85%BE%E8%AE%AF%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%A4%8D%E7%9B%98/2020/01/sol/%E8%82%A1%E6%9D%832.png" class="股权2">

<p><strong>推年了！</strong> </p>
<h1 id="第三财年"><a href="#第三财年" class="headerlink" title="第三财年"></a>第三财年</h1><p>清还第二财年债券利息。（付中信 $185$ 万元利息；付雅诗兰黛 $585$ 万元利息）</p>
<p>清还第二财年贷款利息。（中行 $1515$ 万元，建行 $1530$ 万元）</p>
<p>联系中建发行 $1$ 亿债券三年期利率 $3.5\%\to4.5\%$，因利率过低被拒。</p>
<p>《炸裂》启动，付 $4000$ 万元启动费，同时追加第一年投资 $8000$ 万元。</p>
<p>受到曹诗雨老师约谈，问清了项目收益的清算方式，并明确的认识到了追加投资和项目指令的重要性，并且认识到启动更多项目的必要性。</p>
<p>分别为《诗雨》，《炸裂》和《星宇》写了 $5$ 条项目指令，计划第二天研发 $6$ 个项目。（最后只研发了一个）</p>
<hr>
<p>经过跟曹老师不断地磨合格式与规则，发出了前一天写的《诗雨》，《炸裂》的经营指令，总计追加投资 $9000$ 万元。</p>
<p>研发一个互联网应用，花费 $8000$ 万元，获得项目《有慧农业》，并进行估值。</p>
<p>字节合资《有慧》，字节投 $3000$ 万元获得 $17\%$ 股权，发 $1$ 亿一年期债，自己出 $5000$ 万元。签订股权划转协议，并收到 $3000$ 万元。</p>
<p>联系瑞银发布 $1$ 亿债券一年期，利率 $4.5\%\to5.5\%$ 。但由于时间已经过了第三财年的债券发布，延期到第四财年。</p>
<p>启动《有慧》并追加第一年投资，共花费 $1.8$ 亿，</p>
<p>联系中建重新发行前一天晚上被拒的 $1$ 亿债券三年期利率 $4.8\%\to5.5\%$ 通过。最终以 $5.5$ 的利率敲定。得 $1$ 亿本金，支出 $150$ 万承销费。</p>
<p>购入字节 $1.5$ 亿五年期债券，利率 $5.9\%$，评级 $AA+$，可质押式回购。支出 $1.5$ 亿。</p>
<p><strong>推年了！</strong> 同时第四会期结束。</p>
<hr>
<h1 id="第四财年"><a href="#第四财年" class="headerlink" title="第四财年"></a>第四财年</h1><p>清还第三财年贷款利息。（中行 $1515$ 万元）</p>
<p>清还第三财年债券利息。（付中信 $185$ 万元利息；付雅诗兰黛 $585$ 万元利息；付中建 $550$ 万元利息）</p>
<p>瑞银第四财年债券发行，以 $4.5$ 发售成功。</p>
<p>发行房贷（CDO），为经融危机埋下伏笔。</p>
<p>写《有慧》经营指令并发出，追加投资 $2000$ 万元。</p>
<p>写《炸裂》经营指令并发出，追加投资 $2000$ 万元。</p>
<p>写《诗雨》经营指令并发出，追加投资 $1000$ 万元。</p>
<p>字节《星宇》分红 $2.8$ 亿，《炸裂》分红 $5000$ 万元。总收益 $3.3$ 亿元。</p>
<p>从欧莱雅中国购买京东世纪贸易项目《花花世界》 $3\%$ 股份，花费 $3500$ 万元。</p>
<p>从雅诗兰黛购买亚马逊中国项目《特产网》$10\%$ 股份，花费 $2070$ 万元。</p>
<p>被高盛忽悠购买 $3$ 亿五年期债券，利率 $5\%$，评级 $AA$，无法质押式回购，支付 $3$ 亿元。</p>
<p>首次出现现金危机，中行账户暴负，建行余额 $4000$ 万。</p>
<p>清还第三财年贷款利息。（建行 $1530$ 万元）</p>
<p>申请质押式回购，将字节 $1.5$ 亿债券质押，获得借款规模 $11250$ 万元。</p>
<p>交付本年税款 $3000$ 万元。</p>
<p>第五会期结束。</p>
<p>清理所有审批账目，发现仍存在近 $1$ 亿亏空，首先找瑞银将债券要了。暂时补齐亏空。由于《诗雨》并没有分红。</p>
<hr>
<h1 id="第五财年"><a href="#第五财年" class="headerlink" title="第五财年"></a>第五财年</h1><p>主席在第六会期开始时推动财年，并发放，要求支付第四财年的利息与收益，若在一定时间后有企业在银行帐上存在亏空，且无法通过转账不足，则宣布破产。</p>
<p>清还第三财年贷款利息。（中行 $1515$ 万元；建行 $1530$ 万元）</p>
<p>清还第三财年债券利息及部分本金。（付中信 $185$ 万元利息；付雅诗兰黛 $585$ 万元利息；付中建 $550$ 万元利息；付瑞银证券 $10450$ 万元本息）</p>
<p>收取第三财年债券利息。（字节 $885$ 万元，高盛 $1500$ 万元）</p>
<p>将 $3$ 亿五年期债券中 $2$ 亿以 $1.8$ 亿卖给字节以补足中行掌上亏空。</p>
<p>获得所有项目分红：《星宇》$3.5$ 亿，《炸裂》 $4500$ 万元，《诗雨》 $8.55$ 亿，《特产网》 $1000$ 万元， 《花花世界》 $1500$ 万元，《有慧》 $8300$ 万元。共 $13.58$ 万元。现金不足导致的破产危机彻底解决。</p>
<p>还清中行建行共 $6$ 亿贷款。（提前一年交还）</p>
<p>进入经融危机状态，各大银行遭受不同程度亏损，地产项目收益折半，并且全场需要通过有主持核心磋商商议写作并交付一份指令草案 $dd$ 来脱离危机，重新回到正常经贸体系中推动财年。</p>
<p>经过 $2$ 轮没有实际意义的有主持核心磋商后，第六会期结束。</p>
<p>在国青讨论 $dd$ ，朱老师讲解经融危机（以及各种危机）爆发原因。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>触发原因</th>
<th>灾难形式</th>
<th>灾难加深形式</th>
</tr>
</thead>
<tbody><tr>
<td>经融危机</td>
<td>银行自由财产过少，房贷损失放大导致银行破产</td>
<td>房价下跌，房贷贬值，CDO价值蒸发</td>
<td>银行向企业传递</td>
</tr>
<tr>
<td>去杠杆</td>
<td>企业项目中负债过高，自身投入资金过少</td>
<td>强制项目需拥有 $80%$ 自有资金投入，导致企业难以启动新项目，难以获得新收益，同时贷款量减少，银行赚钱渠道减少</td>
<td>企业向银行传递</td>
</tr>
<tr>
<td>中美贸易战</td>
<td>企业收益过度依赖进口材料，海外贸易公司收入低于国内公司</td>
<td>建设成本，经营成本增加，银行贷款受限</td>
<td>企业银行投资机构三方受损</td>
</tr>
</tbody></table>
<p>写完 $dd$ 初稿。写完《花花世界》，《特产网》，《诗雨》，《炸裂》经营指令。</p>
<hr>
]]></content>
      <tags>
        <tag>模联</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-2019 游记</title>
    <url>/CSP-2019-%E6%B8%B8%E8%AE%B0/2019/11/sol/</url>
    <content><![CDATA[<h1 id="My-Dream"><a href="#My-Dream" class="headerlink" title="My Dream"></a>My Dream</h1><p>去年虽然拿了省一，但分数很不理想，导致无法参加 $CCF-WC$ 以及清华营，就比较不甘心。。</p><p>所以今年小目标就是 $450$ ，大目标是 $500.$ </p><p>对于每一天的成绩做这样的预估：$450=100+100+50(100)+100+50+50$，具体是 $450$ 还是 $500$ 应该就看第一天怎么发挥了。</p><a id="more"></a>


<p>所以 $D1$ 至关重要啊。。好好考吧。。毕竟复习准备了这么久。</p>
<p>在赛前的几天，希望复习好所有的模板，避免出现知道算法打不出来的情况。</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>怎么搞着搞着就只剩两天了呢。。感觉去年的 $NOIP$ 还历历在目。。</p>
<p>今天学校训练的最后一场考试，很不理想的没有考好。（就很烦，本来应该信心考。。）</p>
<p>明天也是学校校内期中考试的最后一天了，虽然我们停课翘掉了考试。。</p>
<p>其实觉得只要能够把应该拿得分拿到，就够了，其实所谓的目标也是随之变化的，即使没拿到那么多，知道不可能再有更高的分，也没什么好不甘的了。</p>
<p>把之前的模拟题看看吧，还有一前的真题。（说不定又原题了呢。）</p>
<h1 id="Day-infin"><a href="#Day-infin" class="headerlink" title="Day $+\infin$"></a>Day $+\infin$</h1><p>直接就没有继续写了。</p>
<p>大概写一下复盘。</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>先总体读了一遍题，觉得不算很难，然后都有一点思路。</p>
<p>被第一题卡住了。写了有一点久。写完的时候前面的另一个 $NOILinux$ 已经在调 $T2$ 大样例了。 有一点点慌，但是第二题直接是有思路的。</p>
<p>第二题原先模拟赛做过序列上的，写的是 $dp$ ，细节比较多，也知道有简单的栈的写法，但是当时懒得搞了。于是写了在树上的 $dp$ ，发现本身在序列上就很多细节的东西在树上更难搞。大概调了一会过了。<strong>但是</strong>并没有发现我将左右括号转换之后 $index~0$ 是左括号的问题。况且垃圾样例也没有设计这个点。数据下发测的时候就发现了问题，只不过还是没有数据没调，最后发现了这个问题。不是什么难点但是我错了。其实解决这个很简单，用栈就不会有问题。</p>
<p>第三题发现在看题的时候没有完全理解。发现题里面的值和位置两个东西混在一起。然后发现链和菊花可做，就稍微大了一下，调到了结束。（并没有发现链的题目有看错了。）测出来民间也有 $60$ 但是官方数据特别强挂成了 $10$ 。</p>
<p>估分是 $100+100+60=260$，然而一切并没有那么圆满。民测已经 $100+50+60$，就发现不对了。离目标已经很远，第二天还是要继续，可能第二天题更难，期望 $100+60+60$ ，这样总分有 $400+$ 。</p>
<h2 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day 2"></a>Day 2</h2><p>总的来说一直在搞部分分，最后时间也不太够，尽可能拿了最高但是还是不如一吧。</p>
<p>第一题发现可以搞 $O(n^3m)$  的 $dp$，但是怎么都优化不到更好了。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>matrix 题解(CSP模拟赛11.11)</title>
    <url>/matrix-%E9%A2%98%E8%A7%A3-CSP%E6%A8%A1%E6%8B%9F%E8%B5%9B11-11/2019/11/sol/</url>
    <content><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 $P$ 现在有一个 $n\times m$ 的 $01$ 矩阵，某一天他突发奇想：假设矩阵行与行可以任意交换，其中最大的全 $1$ 子矩阵有多大。</p><p>他想了很久都没有得出答案，于是找到了你。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数 $n, m$，描述矩阵的大小。</p><p>接下来 $n$ 行，每行一个长度为 $m$ 的 $01$ 字符串，描述 $01$ 矩阵。</p><a id="more"></a>



<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，及最大全 $1$ 子矩阵面积。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 $1$"></a>样例 $1$</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例  $2$"></a>样例  $2$</h3><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">100</span><br><span class="line">011</span><br><span class="line">000</span><br><span class="line">101</span><br></pre></td></tr></table></figure>

<h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>



<h3 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 $3$"></a>样例 $3$</h3><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11 16</span><br><span class="line">0111110101100011</span><br><span class="line">1000101100010000</span><br><span class="line">0010110110010101</span><br><span class="line">0110110010110010</span><br><span class="line">0011101101110000</span><br><span class="line">1001100011010111</span><br><span class="line">0010011111111000</span><br><span class="line">0100100100111110</span><br><span class="line">1001000000100111</span><br><span class="line">0110000011001000</span><br><span class="line">1011111011010000</span><br></pre></td></tr></table></figure>

<h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>

<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $30\%$ 的数据，$n,m\leq 10$ </p>
<p>对于 $70\%$ 的数据，$n, m \leq 1000$ </p>
<p>对于 $100\%$ 的数据，$n,m\leq 5000$ </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看到这种题目首先想到的是 $dp$ ，可能是中了最大子矩形的毒，但是很快发现那个交换的操作很灵活，不方便记成状态，况且数据很大，不允许很复杂的 $dp$ 。</p>
<p>大概一算，时间复杂度最多只能是 $O(nm)$ 得了，对于矩阵来说就是线性。那么既然行和行之间可以交换，自然想到我们可以单独处理每一行的信息。于是：</p>
<h2 id="很傻很正确的模拟"><a href="#很傻很正确的模拟" class="headerlink" title="很傻很正确的模拟"></a>很傻很正确的模拟</h2><p>我们可以对于每一行每个位置记下这样的东西 $f_i$ ：</p>
<p>​    如果第 $i $ 位是 $0$ ，$f_i=0$；<br>​    如果第 $i$ 位是 $0$ ，$f_i$ 为 $f_i$ 前面最多有多少个 $1.$ </p>
<p>举个例子：</p>
<p>​    $A=11100110001110\\F=12300120001230$ </p>
<p>进一步的，如果我们把所有位结合起来，就会发现这个 $f$ 其实可以表示这一行最大能对边长为多少的矩阵做贡献。</p>
<p>自然的，我们可以把每一行的 $f$ 算出来，再对于每一列（准确的说是一个前缀矩阵）算一下答案。即我们记 $g_i$ 表示在这一列每一行的 $f$ 中有 $g_i$ 个是 $i$ 。然后我们发现 $f$ 记的是最大的长度，所以小于 $f$ 的长度都可以取到，所以需要对 $g$ 做一个后缀和，那么最终的答案是每一列的：$\min\limits^n_{i=1}g_i\times i$ ，因为 $g_i$ 表示有多少行，$i$ 表示行的长度（也就是列数），乘起来就是体积了。</p>
<p>那么处理 $f$ 时间复杂度是 $O(nm)$，处理 $g$ 是 $O(nm)$，总的就也是 $O(nm)$ 了。</p>
<p>注意要优化读入不然会卡常。</p>
<p>$code:$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3fll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO 5005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MO 300005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fup(i, x, y) for(register int i = x; i &lt;= y; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fdn(i, x, y) for(register int i = x; i &gt;= y; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lln putchar(<span class="meta-string">'\n'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> blk putchar(<span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, pii&gt; piii;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">' '</span>, last;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)</span><br><span class="line">        last = ch, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        ret = ((ret + (ret &lt;&lt; <span class="number">2</span>)) &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> last == <span class="string">'-'</span> ? -ret : ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>), x = -x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">        write(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[NO][NO], book[NO];</span><br><span class="line"><span class="built_in">string</span> x;</span><br><span class="line"><span class="comment">//variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"matrix.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"matrix.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    fup (i, <span class="number">1</span>, n)</span><br><span class="line">        fup (j, <span class="number">1</span>, m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = getchar();</span><br><span class="line">            <span class="keyword">while</span> (ch == <span class="string">' '</span> || ch == <span class="string">'\n'</span> || ch == <span class="string">'\r'</span>)</span><br><span class="line">                ch = getchar();</span><br><span class="line">            a[i][j] = ch - <span class="string">'0'</span>, a[i][j] = (a[i][j] ? a[i][j - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    fup (i, <span class="number">1</span>, m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(book, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (m + <span class="number">1</span>));</span><br><span class="line">        fup (j, <span class="number">1</span>, n)</span><br><span class="line">            book[a[j][i]]++;</span><br><span class="line">        fdn (j, m, <span class="number">1</span>)</span><br><span class="line">            book[j] += book[j + <span class="number">1</span>];</span><br><span class="line">        fup (j, <span class="number">1</span>, m)</span><br><span class="line">            ans = max(ans, book[j] * j);</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans), lln;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//functions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main</span></span><br></pre></td></tr></table></figure>



<h2 id="题解说的计数排序（？？）"><a href="#题解说的计数排序（？？）" class="headerlink" title="题解说的计数排序（？？）"></a>题解说的计数排序（？？）</h2><p>放张图吧：（效率和上面是一样的。所以了解上面就好）</p>
<img src="/matrix-%E9%A2%98%E8%A7%A3-CSP%E6%A8%A1%E6%8B%9F%E8%B5%9B11-11/2019/11/sol/sol1.png" class title="sol1">

<img src="/matrix-%E9%A2%98%E8%A7%A3-CSP%E6%A8%A1%E6%8B%9F%E8%B5%9B11-11/2019/11/sol/sol2.png" class title="sol2">

<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><a href="/matrix-%E9%A2%98%E8%A7%A3-CSP%E6%A8%A1%E6%8B%9F%E8%B5%9B11-11/2019/11/sol/matrix.rar" title="download">download</a>]]></content>
      <tags>
        <tag>前缀和</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>pay 题解(CSP模拟赛11.11)</title>
    <url>/pay-%E9%A2%98%E8%A7%A3-CSP%E6%A8%A1%E6%8B%9F%E8%B5%9B11-11/2019/11/sol/</url>
    <content><![CDATA[<p>​                                                                                </p><p>咕掉了。。</p><p>$csp$ 后补吧。</p>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟联合国北外会游记</title>
    <url>/%E6%A8%A1%E6%8B%9F%E8%81%94%E5%90%88%E5%9B%BD%E5%8C%97%E5%A4%96%E4%BC%9A%E6%B8%B8%E8%AE%B0/2019/11/sol/</url>
    <content><![CDATA[<h1 id="The-Beginning"><a href="#The-Beginning" class="headerlink" title="The Beginning"></a>The Beginning</h1><p>校内的一模结束之后随即就有了外出参会的通知，想着体验一把 $mpc$ 的感觉，报了北外会的 $mpc.$ </p><p>本来没什么希望但上了，正好有跟 $csp$ 有点冲突，就有点烦。</p><p>进群之后就是写学测，交完学测就出了席位，结果我被安排在了一个英文场。。</p><p>我一个学德语的就开始看 $40$ 多面的 $BG$ ，开始准备些前瞻。。真的好难。。不知道后面会怎么样但是我相信这样的一次经历从什么角度而言都是有意义的。</p><a id="more"></a>



<h1 id="11-14"><a href="#11-14" class="headerlink" title="11.14"></a>11.14</h1><p>今天拿到了 $unsc$ 的 $bg$ ，打印下来大概看了一下下，准备晚上研究一下开始写写 $PR$，$17$ 号晚上就是 $ddl$ 了啊。。</p>
<p>反正打算先写一份中文的，大概 $google~~translate$ 一下，再看看有什么不好的地方改一改就好了。。</p>
<p>加油，应该不会熬夜。 </p>
<p>$-~22:38$  </p>
<h1 id="11-28-day-0"><a href="#11-28-day-0" class="headerlink" title="11.28 day 0"></a>11.28 day 0</h1><p>好像好久没写已经到了前一天了。明天就要出发去北京，下午开幕式，晚上就有会期。也就是说晚上要开始写采访社论和简讯了。(说不定还有危机。)</p>
<p>之前的 $PR$ 评价不错，一方面感谢 $google$ 和北外学姐的指导，一方面也要对之后的表现作下一些承诺了。反正咕是绝对不能发生的，绝对不能。然后希望的是采访能更多一点。危机写作当然也是积极的。（又要依赖 $google$ 了）再就是新闻发布会，看在我极差的口语的份上，就尽量事先准备吧，当然能够有好的追问再好不过。</p>
<p>会场的议程的话，昨天晚上他们就已经开始讨论了。到现在，大概已经列出了框架。这里可能学到了一点东西：</p>
<p>​    所有的议程必须在中立的情况下规划。<br>​    国家自身立场可在议程中体现，但更多因在接下来的会期之中决定。</p>
<p>既然作为记者，规划一下明天在路上要采访一下英国代表（本国），了解一下立场吧。效果好的话也可以采访一下其他国的，像五常之类的。另外把打印的论文看一下。</p>
<p>模联生涯第二站，外出参会第一站，$BFSUMUNC2019$ 我来了。</p>
<p>$-~22:13$ </p>
<h1 id="11-29-day1"><a href="#11-29-day1" class="headerlink" title="11.29 day1"></a>11.29 day1</h1><p>早起，出门，上火车。</p>
<p>经过昨天的讨论议程已经出来了，</p>
<a href="/%E6%A8%A1%E6%8B%9F%E8%81%94%E5%90%88%E5%9B%BD%E5%8C%97%E5%A4%96%E4%BC%9A%E6%B8%B8%E8%AE%B0/2019/11/sol/agenda.docx" title="Agenda">Agenda</a>

<p>本份议程应该就只是 $us$ 的 $bloc$ 的，俄罗斯的看起来意见不是很一样，中国还并没有出现，猜测它们结盟也写了一份。</p>
<p>晚上的会期如果只是当前局势挑战的话应该比较轻松。会期文件的话如果采访做的成功就把采访写一个，不然就水一篇社论。</p>
<p>$- 9:02$ </p>
<p>联系了英国代表，一个在逛军博一个没回。大概写了提纲看起来没什么大问题。(水一个采访应该是够了的)</p>
<p>$-9:56$ </p>
<p>下车，开房，吃饭。</p>
<p>下午就是开幕式了，开幕式在第三阶梯教室（但是在2楼。。）来的途中路过了图书馆，图书馆的墙上全部都是各种语言写的，德语没有白学认出了一个 $bibliothek.$ </p>
<img src="/%E6%A8%A1%E6%8B%9F%E8%81%94%E5%90%88%E5%9B%BD%E5%8C%97%E5%A4%96%E4%BC%9A%E6%B8%B8%E8%AE%B0/2019/11/sol/bibliothek.png" class title="bibliothek">

<p>到了开幕式现场但是开幕式好像咕掉了。</p>
<p>早上跟另一个英国代表联系上了，他好像是北外的，然后大概说了一点，理论上再做一些采访应该可以解决第一会期了。（估计在开完之后或者在自搓的时候可以在问一些进一步关于会议的问题）</p>
<p>他发一个明信片是瞎发的，根本没有按照会场，导致我拿到了一个法语场的。看能不能在我们代表团内换一下吧。。</p>
<p>$-16:19$ </p>
<h1 id="12-1-day3"><a href="#12-1-day3" class="headerlink" title="12.1 day3"></a>12.1 day3</h1><p>开会真的很忙。真的很忙。所以根本没时间写这东西。</p>
<p>到最后一个会期之前了，才有闲心写写游记。</p>
<p>总管这两天的话，采访是不可能了，而且本来上午有的危机也因为我们场另外的两个新闻社咕掉了。就一共写了三篇社论，有一篇被拒了（因为观点有问题）。</p>
<p>昨天下午比较失败，发了两次都被拒了然后就什么都没搞出来了。新闻发布会也搞得不怎么样。总之参与为主吧。</p>
<p>收获真还挺多的。一方面是真的见到了很多很多强者，不仅仅在语言能力方面，更多的是观点，表现能力。我所驻场的 $UNSC$ 议程一直进行的很顺利，即使有分歧但是都没有真正地陷入停滞。最后的结果等会最后一个会期开完估计就知道了。有机会还有写写关于开幕式的东西（虽然马上就闭幕式了）。</p>
<p>$- 13:08$ </p>
<h1 id="总结（12-6-12-7）"><a href="#总结（12-6-12-7）" class="headerlink" title="总结（12.6~12.7）"></a>总结（12.6~12.7）</h1><p>比赛结束已经过去了很久很久了，在完全回到校内状态之后，发现的只是学习任务的同样繁重。</p>
<p>既然参了赛，加上模协要求，系统地写写收获吧。</p>
<h2 id="关于-MPC"><a href="#关于-MPC" class="headerlink" title="关于$MPC$"></a>关于$MPC$</h2><h3 id="会前"><a href="#会前" class="headerlink" title="会前"></a>会前</h3><p>第一次外出，也是第一次作 $MPC$。由于驻英文场，加上平时不学英语，会前的准备就着重放在了英语听力和单词的练习上。</p>
<h4 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h4><p>首先是 $bg$ 里面的，然后看看驻场报社的相关新闻，容易整理出一些<strong>与主题相关的核心词汇</strong>。我整理出了大概 $200$ 多，但是其实差不多都是比较基础的。因此平时把英语抓起来真的很重要，可能在学校用不到，在生活里面用不到，但在出去开会就只有惊讶别人英语能力的份了。</p>
<p>不足在于可以找一些<strong>联合国已有的决议或者会议记录</strong>，以找到听力中可能会碰到的词汇专项准备，特别是其中常见的固定句式和词汇用法。</p>
<p>文件系统链接：编号查询：<a href="https://documents.un.org/prod/ods.nsf/home.xsp" target="_blank" rel="noopener">search</a>，总览分区查询：<a href="https://www.un.org/zh/sections/general/documents/" target="_blank" rel="noopener">general</a></p>
<p>由于记者有写作任务，所以要求具备一定的英语写作能力。我们的驻场主席推荐了一本<strong>《中式英语之鉴》</strong>，是一本可以真正规避中式英语，养成英语写作习惯的书。另外在英语课上记的作文的<strong>高端句式</strong>是需要背的，不然真的书到用时方恨少，问 $google$ $translate$ 句式雷同，问百度找不到了。</p>
<p>除去写作，<strong>口语能力</strong>同样重要，因为即使是记者，同样需要通过英语表达出自己的想法和问题。这一点是在之前我极度忽视的。</p>
<h4 id="新闻写作"><a href="#新闻写作" class="headerlink" title="新闻写作"></a>新闻写作</h4><p>作为独立报社，每个报社拥有自己的写作风格和关注点，及对新闻关注的角度。即使是一个国家的报社，同样拥有不同的立场和态度（如美国 $FOX$ 和 $AP$ （来自驻$UN Women$ 主席））因此在写简讯，社论以及采访的时候，对于新闻的关注点是不同的。因此，在会前最重要的工作就是 <strong>真正了解清楚报社自身的立场</strong>。一方面是为了前瞻报告的写作，另一方面是对自身身份的带入。如果连自身的观察角度都没有找到，在会场中加上语言障碍，你永远只是一个旁观者，永远无法真正参与到会议之中。</p>
<p>这一点是本次会议中完全欠缺的。在美联社开会前问我的时候，其实我是不了解的，因为真的无法从新闻社的文字之中找到其特点，这个问题就算放在中文也是很难的了（但是极其重要）。回过来看我写的简讯和社论，发现完全像是几个自由撰稿人写的，一方面是并没有固定的写作思路，更重要的是整体看起来不成体系。<strong>报社的自由是基于其立场之上的，不是想嗨就能随便编。</strong>能够在会议中通过写文真正找到自由与乐趣，才是一个最好的 $Journalist.$ </p>
<h3 id="会中"><a href="#会中" class="headerlink" title="会中"></a>会中</h3><p>其实会前写完可能已经没什么写的了，但是：</p>
<h4 id="新闻写作-1"><a href="#新闻写作-1" class="headerlink" title="新闻写作"></a>新闻写作</h4><h5 id="简讯"><a href="#简讯" class="headerlink" title="简讯"></a>简讯</h5><p>主要说几种学到的写作思路：（在英语水平比较高的时候用得到）</p>
<ol>
<li><p>倒三角体写作</p>
<p>​    通过<strong>从简洁到具体</strong>的方法，对事实进行多次重现，一方面吸引读者阅读，更重要的是强调本篇简讯之中所想要强调的观点，并用重构的方式通过事实排列展现出自己的立场观点。</p>
</li>
<li><p>华尔街体写作</p>
<p> ​    从具体细节入手，在细节中体现出想要表达的观点，再将点扩展成面，描述出宏观的态势。在写作的思路上是和倒三角完全相反的。</p>
<p> 具体见：<a href="http://www.360doc.com/content/13/1129/02/726465_333073243.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/13/1129/02/726465_333073243.shtml</a></p>
</li>
</ol>
<p>其实更深的内容应该在专业新闻理论中存在，这对记者是重要的。但实际上，思路只是一方面，能够找到<strong>更好更新更独特的素材</strong>更为重要。这就要靠在会场里对代表发言完整全面的倾听以及对议题本身的充分了解了。</p>
<p>简讯需要注意的是最好不要直接表达出自己观点，即直接写出类似 “本通讯社认为这是不对的” 之类的话。更加高的要求是：通过对事实的<strong>不完全报道与有偏向性重构 </strong>，让读者在阅读完简讯之后，自然而然得知记者所想要表达的态度与观点。而这一点在上面介绍的倒三角体写作中更容易做到，因此建议由此种方式进行写作（来自驻历史特委主席）。</p>
<h5 id="社论"><a href="#社论" class="headerlink" title="社论"></a>社论</h5><p>社论应当包括评论会议中代表的发言，以及自身通讯社的观点。所以一篇完整的好的社论应该这样构成：</p>
<p>首先，总结自己想要评论的方面代表们在会议之中的已有发言，对发言进行部分总结，可进行适当重构。</p>
<p>总结过后，写出自己对于他们观点的看法，即自己的评论。评论可针对一类看法，同样可以针对某些代表自身，后者更好的是插入些许<strong>对于其国家立场的剖析</strong>。</p>
<p>评论过后，应当提出自身在这个问题上的看法，即表达自身观点。社论中在批评性之外的<strong>建设性</strong>就应当由此体现。</p>
<p>另外，一篇社论最好进行分点写作，在总结时分点总结，评论和表达自己观点时对应阐述即可。</p>
<h5 id="危机"><a href="#危机" class="headerlink" title="危机"></a>危机</h5><p>主席团与记者即使没有什么交集，但是与其的交流在出现危机是就至关重要了。危机任务是由主席团下发，记者则负责根据主席团本次危机意图的扩展写作。一篇好的危机首先拥有<strong>合理的事实背景 </strong>，将主席团给出的危机放在一个合理的背景之下，让危机更具有真实性。其次，危机应当让更多的代表拥有发挥空间，最好能够在 $bloc$ 之间挑起争执，发挥出从另外一个角度放大利益矛盾的作用。最后，危机应是针对会议以讨论内容的缺陷或尚未讨论的重要议题的，<strong>即使在指令草案写出，危机成功解决之后，该危机仍应当继续影响会议</strong>。</p>
<p>另外，关于危机的升级，只要在上面前提下将问题严重化，社会影响扩大化即可。</p>
<h4 id="与代表的交流"><a href="#与代表的交流" class="headerlink" title="与代表的交流"></a>与代表的交流</h4><p>参会之中，我并没有参与任何一次的自搓。这是一个极大的问题。参与自搓是最直接最便捷向代表提出质疑，了解更多代表观点的方式，简单地说，<strong>参与自搓是最简单的与代表的交流方式</strong>。而这需要一定水平的口语能力。同样，记者可以提出自身对于当前议题的看法，或基于自身立场在自搓之中找到能够写作新闻稿的素材。新闻社立场的重要性再次体现。例如，在代表的发言之中出现了一些不当言论的时候，自搓时提出质疑，获得回答，便可以整理成一篇有侧重点的好简讯。</p>
<p>更加有准备，有深度的交流可以由采访的形式进行。一篇采访有 $4-5$ 个问题即可，而问题需要注意：</p>
<ol>
<li><p>与所问国家立场，国内政治政策，以往做法，以及本次议题相关。</p>
</li>
<li><p>提出问题应在侧重点上符合本通讯社的角度。</p>
</li>
<li><p>禁止提出答案可在代表会议发言中找到的问题，最好是针对已经有的分歧的扩展讨论，对会议的展望可以有但不能作为主体。</p>
</li>
</ol>
<p>如果有能力，可以<strong>通过语言艺术引导被采访者间接表达出他不想展示的观点与态度 </strong>。</p>
<h3 id="会后"><a href="#会后" class="headerlink" title="会后"></a>会后</h3><p>即使是记者，一定程度上的旁观者，仍是拥有总结的必要的。</p>
<p>参会更重要的在于本次的收获和进步，对比你第一天晚上和现在写的新闻稿，一定会发现很大的不同。（来自驻$UNSC$ 主席，$MPC$ 总主席）</p>
<p>最一开始的观点奇异，思想威胁，关注点偏激，到后来慢慢走上正轨，知道应该写什么怎么写，我所获得的不仅仅是上面的2000多个字，对英语学习的重视，对记者的了解，对安理会的认识，以及对身为模联人的自知，是对今后的我更为重要的。</p>
<p>闭幕式时，颁奖台下期盼又失落的我应当只是被荣誉蒙蔽双眼，因为在模联中最受益的是努力着的弱者。</p>
<p>但愿吧。</p>
<h2 id="关于-UNSC"><a href="#关于-UNSC" class="headerlink" title="关于 $UNSC$"></a>关于 $UNSC$</h2><p>即使我是作为记者参会，但是好像是自己开了一场 $UNSC$ 似的，作为一个旁观者对于安理会好像也有一些不一样的认识。一方面是从开会流程方面，另一方面则是什么才是一个优秀的安理会国家代表。</p>
<h3 id="开会流程（安理会的代表们在干什么？）"><a href="#开会流程（安理会的代表们在干什么？）" class="headerlink" title="开会流程（安理会的代表们在干什么？）"></a>开会流程（安理会的代表们在干什么？）</h3><h1 id="会议复盘"><a href="#会议复盘" class="headerlink" title="会议复盘"></a>会议复盘</h1><p>大概通过整个参会过程整理出各方面我做到了什么和我应当怎么做。</p>
<h2 id="会前准备"><a href="#会前准备" class="headerlink" title="会前准备"></a>会前准备</h2>]]></content>
      <tags>
        <tag>MUN</tag>
      </tags>
  </entry>
  <entry>
    <title>灾难 题解</title>
    <url>/%E7%81%BE%E9%9A%BE-%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<p>​                                                                                </p><p>咕掉了。。</p><p>$csp$ 后补吧。</p>]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>巡访 题解</title>
    <url>/%E5%B7%A1%E8%AE%BF-%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="题目名称-巡访"><a href="#题目名称-巡访" class="headerlink" title="题目名称 巡访"></a>题目名称 巡访</h2><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　$Chanxer$ 终于当上了“中华农民联盟”的盟主，他举目四望，决定四处走走，巡视自己的农土。</p><p>　　“中华农民联盟”的成员有个村庄，在“村村通”计划中，村庄们被条道路联通了起来， $Chanxer$ 计划从某个村庄出发，访问所有的村庄。</p><p>可是 $Chanxer$ 出行有一个特殊的要求，那就是必须以农车代步，现在我们知道哪些村庄配备有农车，也就是说，只有配备有农车的村庄才能够被作为出发点。</p><a id="more"></a>


<p>$Chanxer$ 有点懒，他想知道访问全部的村庄所要走的路程长度最小是多少。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件共 $n+1$ 行：</p>
<p>第一行一个正整数 $n.$ </p>
<p>第 $2\sim n$ 行每行三个正整数 $x_i,y_i,z_i$ 表示 $x_i$ 号村庄和 $y_i$ 号村庄之间有一条长度为 $z_i$ 的路。</p>
<p>接下来一行包含 $n$ 个 $0/1$，表示第 $i$ 个数是否能作为起始点。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行表示最小路径长度，数据保证存在。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">3 4 3</span><br><span class="line">3 5 4</span><br><span class="line">1 1 1 0 0</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>



<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>样例所示图如下图：（其中 $1,2,3$ 可作为起点）</p>
<img src="/%E5%B7%A1%E8%AE%BF-%E9%A2%98%E8%A7%A3/2019/11/sol/P1.png" class title="graph">

<p>选择 $2$ 号点时最优，最优路径为 $2\to 1\to 3\to 4\to 3\to 5$ </p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $60\%$ 测试点有 $n\leq10$ </p>
<p>对于 $100\%$ 测试点有 $n\leq10^6,1\leq x_i,y_i\leq n, 1\leq z_i\leq 10^4$ </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><h3 id="线性的换根-dp"><a href="#线性的换根-dp" class="headerlink" title="线性的换根 $dp$"></a>线性的换根 $dp$</h3><p>首先，题目要求的路径并不是很方便直接求出来，那么我们想一想怎么把最短路径转化一下。为了走过的路径最短，我们肯定尽量不能走回头路，那么就是说要让重复走的距离最短。换句话说，也就是让不走的距离最长。那么我们显然还可以先走掉其他重复走的路，再一头扎进从当前点出发最长的那条链中。那么题意可以转化成求从一些点出发的最长链的长度了。</p>
<p>那么，我们先随便指定一个点是根，我们考虑吧每一个 $u$，那么答案可能是 $u$ 所在子树里面的一条链，也可能是 $u$ 向父亲伸出去的一条链。这就是换根 $dp$ 的思想了，可以通过两遍 $dfs$ 分别求出答案。</p>
<p>我们设第一种答案是 $f_i$ ，第二种是 $g_i$，$f_i$ 可以常规树形 $dp$ 求，而 $g_i$ 则要单独考虑：它可以从父亲的其他儿子或者父亲的 $g_i$ 转移过来，因此我们需要知道 $f_i$ 对应的是哪一个儿子 $to_i$，以及次大长的链 $h_i.$ 然后转移方程就显然了。</p>
<p>$code:$ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MO 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fup(i, x, y) for(register int i = x; i &lt;= y; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lln putchar(<span class="meta-string">'\n'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> blk putchar(<span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">' '</span>, last;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)</span><br><span class="line">        last = ch, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        ret = ((ret + (ret &lt;&lt; <span class="number">2</span>)) &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> last == <span class="string">'-'</span> ? -ret : ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>), x = -x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">        write(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt, head[NO], f[NO], g[NO], s, f2[NO], to[NO], ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne, v, c;</span><br><span class="line">&#125;e[MO];</span><br><span class="line"><span class="comment">//variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].ne = head[u];</span><br><span class="line">    e[cnt].v = v;</span><br><span class="line">    e[cnt].c = c;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> la)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].ne)</span><br><span class="line">        <span class="keyword">if</span> (e[i].v != la)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(e[i].v, u);</span><br><span class="line">            <span class="keyword">if</span> (f[e[i].v] + e[i].c &gt; f[u])</span><br><span class="line">                f2[u] = f[u], f[u] = f[e[i].v] + e[i].c, to[u] = e[i].v;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f2[u] = max(f2[u], f[e[i].v] + e[i].c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> la, <span class="keyword">int</span> li)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[u] = max(g[la], (to[la] == u ? f2[la] : f[la])) + e[li].c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].ne)</span><br><span class="line">        <span class="keyword">if</span> (e[i].v != la)</span><br><span class="line">            dfs2(e[i].v, u, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"path.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"path.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = read();</span><br><span class="line">    fup (i, <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(), z = read();</span><br><span class="line">        add(x, y, z), add(y, x, z), s += z;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    fup (i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read();</span><br><span class="line">        <span class="keyword">if</span> (x)</span><br><span class="line">            ans = max(ans, max(f[i], g[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    write(s * <span class="number">2</span> - ans), lln;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main</span></span><br></pre></td></tr></table></figure>

<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><a href="/%E5%B7%A1%E8%AE%BF-%E9%A2%98%E8%A7%A3/2019/11/sol/path.rar" title="download">download</a> ]]></content>
      <tags>
        <tag>dp</tag>
        <tag>树相关</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>防火长城 题解</title>
    <url>/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E-%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="题目名称-防火长城-gfw"><a href="#题目名称-防火长城-gfw" class="headerlink" title="题目名称 防火长城 $gfw$"></a>题目名称 防火长城 $gfw$</h2><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在最近一次战争中，国家被摧毁了。你，这个国家的主人，决定提升首都防火长城的级别。防火长城能力很大一部分是由一排的魔法塔决定的，这一排魔法塔从城市一直延续到北边荒野丛林中。你的顾问告诉你，防火长城的能力其实是只由魔法塔的一个特性决定的：就是最长的连续的并且魔法塔高度是递增的魔法塔序列的长度。（顾问给了一个冗长的解释，但你只要知道这与控制敌军翻墙能力有关就可以了）。</p><a id="more"></a>
<p>为了提升防火长城的防御等级，你开始了刻苦的谈判，法师最终同意解除一部分魔法塔的封印以便你拆除并提升防御等级。然后其余的魔法塔将会重新合并，并保持相对位置不变。现在，你可以拆除任意数量的魔法塔。但法师又露出了邪恶的笑容，缓缓说道：这些被拆除的塔必须是连续的。</p>
<p>请问，删除一些魔法塔后，新的魔法塔序列中最长的连续的并且魔法塔高度是递增的魔法塔序列的长度最大是多少？</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$ ，表示原来有 $n$ 个魔法塔。</p>
<p>第二行 $n$ 个整数，为依次的每个魔法塔的高度Hi</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，为删除一些塔甚至是不删后最长连续且高度递增的魔法塔序列的长度。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">5 3 4 9 2 8 6 7 1</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>



<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>删除 $9,2,8$ 后，最长连续且高度递增的序列为 $3, 4, 6, 7$ 长度为 $4$ 。</p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $30 \%$ 的数据，$n≤ 10$ 。</p>
<p> 对于 $50\% $的数据，$n≤ 100$ 。</p>
<p> 对于 $100\%$ 的数据，$n≤ 200000$。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><h3 id="n-2-动态规划"><a href="#n-2-动态规划" class="headerlink" title="$n^2$动态规划"></a>$n^2$动态规划</h3><p>首先，题面的意思就是要找两段长度之和最大的最长连续上升子序列。</p>
<p>最长连续上升子序列是可以直接贪心出来的。如果我们要搞两段，可以类似两段最大字段和的方法，用 $\large f_{0/1,~i}$ 来定义状态，其中的 $0/1$ 就表示现在是在做第一段还是第二段， $i$ 则是现在做到了第 $i$ 个数字。</p>
<p>那么转移很显然：不管是第一段还是第二段如果上一个数比这一个数小，就可以直接伸长一段。或者我们可以从之前第一段的里面把第二段新开出来。具体转移方程就是：</p>
<p>$\Large if ~~ a_i&gt;a_{i - 1}\\\Large\quad \quad ~f_{0,i}=f_{0,i-1}+1;\\\Large\quad\quad f_{1,i}=f_{1,i-1}+1;\\\Large f_{1,i}=\max\limits^{i-1}_{j=1}(f_{0,j}+1)\times[a_i&gt;a_j]$ </p>
<p>发现这样是 $O(n^2)$ 的只有 $50pt.$ </p>
<h3 id="n-log-n-优化动规"><a href="#n-log-n-优化动规" class="headerlink" title="$n\log n$ 优化动规"></a>$n\log n$ 优化动规</h3><p>发现求最大值的那一维是在求一个类似前缀 $\max$ 的东西，但是又不太一样，因为只有在一定的限制之下才能更新答案。那么我们把 $f_0$ 的值抽象成点，就发现我们要求的是一个点左下方的所有点的个数之和，就是一个简单的二位偏序了。</p>
<p>那么离散化，做一个树状数组求前缀 $max$ 即可。（当然也可以用线段树。）</p>
<p>不管怎么实现都是 $O(n\log n)$ 的。</p>
<p>$code:$ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lln putchar(<span class="meta-string">'\n'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> blk putchar(<span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO 2000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fup(i, x, y) for (register int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">' '</span>, last;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)</span><br><span class="line">        last = ch, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> last == <span class="string">'-'</span> ? -ret : ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>), x = -x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">        write(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[NO], f[<span class="number">2</span>][NO], c[NO], cnt, d[NO];</span><br><span class="line"><span class="comment">// variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= n; i += (i &amp; -i))</span><br><span class="line">        d[i] = max(d[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i; i -= (i &amp; -i))</span><br><span class="line">        ret = max(ret, d[i]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"gfw.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"gfw.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = read();</span><br><span class="line">    fup (i, <span class="number">1</span>, n)</span><br><span class="line">        c[i] = a[i] = read();</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">    cnt = unique(c + <span class="number">1</span>, c + n + <span class="number">1</span>) - c - <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    fup (i, <span class="number">2</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            f[<span class="number">0</span>][i] = f[<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (f[<span class="number">1</span>][i - <span class="number">1</span>])</span><br><span class="line">                f[<span class="number">1</span>][i] = f[<span class="number">1</span>][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = lower_bound(c + <span class="number">1</span>, c + n + <span class="number">1</span>, a[i]) - c, Max = ask(pos - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (Max)</span><br><span class="line">            f[<span class="number">1</span>][i] = max(f[<span class="number">1</span>][i], Max + <span class="number">1</span>);</span><br><span class="line">        add(pos, f[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    fup (i, <span class="number">1</span>, n)</span><br><span class="line">        ans = max(ans, max(f[<span class="number">0</span>][i], f[<span class="number">1</span>][i]));</span><br><span class="line">    write(ans), lln;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// functions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br></pre></td></tr></table></figure>

<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><a href="/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E-%E9%A2%98%E8%A7%A3/2019/11/sol/gfw.rar" title="download">download</a>]]></content>
      <tags>
        <tag>dp</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>8.20 模拟赛  题解</title>
    <url>/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<h1 id="Glo"><a href="#Glo" class="headerlink" title="Glo"></a>Glo</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/glo.png" class title="glo"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>一看是一个最长上升子序列，只是带一点特殊的东西，再一看数据范围，根据已学知识要用单调栈搞一个 $\log$ 算法差不多能过。</p><p>然后开始看那个特殊的区间加操作。然后发现如果把一个区间加向后面拓展成后缀加，答案一定是不劣的，同理区间减扩展成前缀减。进一步我们发现最长上升子序列关心的只是他们之间的差值，所以数值本身意义不大，因此前缀减可以等效成后缀加，那么现在的问题就变成了要给一个后缀加上一个数之后的最长上升子序列了。</p><a id="more"></a>



<p>然后我考虑单调栈的做法，就是维护一个当前的上升子序列长度为 $x$ 的一个最小值，然后找到刚好比自己大的位置插进去，并更新答案。所以我的想法就是与此同时也在一个后缀的栈里面找到 $x-k$ 的位置，用那里的后缀最长下降子序列更新总的答案。但是这个栈是没办法回退的，所以我发现不能预处理一遍后缀栈然后在做前缀的时候退出上一位的影响。那就只能暴力做这里的栈了，这个做法要么时间爆炸要么空间爆炸。而我也没有什么进一步思路了。</p>
<p>看看部分分。</p>
<h4 id="k-0"><a href="#k-0" class="headerlink" title="$k=0$"></a>$k=0$</h4><p>这个就是普通的最长上升子序列。直接做。</p>
<h4 id="k-1e9-infin"><a href="#k-1e9-infin" class="headerlink" title="$k=1e9( \infin)$"></a>$k=1e9( \infin)$</h4><p>这个已经不需要考虑 $x-k$ 在哪了，所有的后缀都能满足了。那直接正反求一遍，然后在中间用前后缀更新答案。</p>
<p>出分：$10pt.$ ？？？它 $subtask???$ 稍微改了改救回 $33.$ </p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>上面的做法已经离得很近了。在处理前缀的时候，我们可以直接把那个值的答案记下来。就是那个前缀 $x$ 处的最长上升子序列，那么前缀上就必须大于 $x + k$。然后我们再倒着看，只要在每个地方加了之后在之前里面的答案中更新即可。具体而言就是：</p>
<p>记录一个 $f_i$ 表示在 $1 \to a_i$ 前缀上严格以 $a_i+k$ 结尾的最长上升子序列。那么在倒着做的时候，只需要在栈里面找 $a_i$ 的答案 $f_i$。</p>
<p>这个可以用单调栈实现，但是这次学会了另一种求最长上升子序列的方法：在值域上维护区间最大值。因为每一次要的是结尾比 $a_i$ 小的最长上升子序列，所以相当于求一个值域前缀 $\max.$ 这个离散化之后用线段树或者树状数组维护即可。也是一个 $\log$ 的。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/2dnt4nTXrg/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/2dnt4nTXrg/</a></p>
<h1 id="Mobitel"><a href="#Mobitel" class="headerlink" title="Mobitel"></a>Mobitel</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/mobitel.png" class title="mobitel">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>没想到用 $dp.$ 写的爆搜加小剪枝，因为发现当大于的时候后面的方案数可以用组合数算了，就直接剪掉了。</p>
<p>出分：$10pt.$ </p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>$dp.$ 因为大于 $n$ 没什么限制条件不好做，所以我们转化一下，转化成用整个的（也是一个组合数）减去小于 $n$ 的方案数，因此这个就可以 $dp$ 了。</p>
<p>设 $f_{i,<del>j,</del>m}$ 表示现在走到 $(i,<del>j)$ 乘积是 $m$ 的方案数。然后转移转移到 $(i+1,</del>j)$ 和 $(i,~j+1)$ 即可。这个复杂度是 $O(rsn)$ 的，肯定爆炸了。</p>
<p>所以考虑进一步转化，优化一下状态。因为发现最后能用到的空间其实是 $\large\frac{rest}{a_{i,<del>j}}$ ，而 $\large\frac n x$ 的个数又只有 $2\sqrt n$ 个 ，所以可以把状态优化成 $f_{i,</del>j,<del>m}$ 表示走到 $(i,</del>j)$ 还剩下 $m$ 给我们除。还是上面的转移，就可以继续做了。时间复杂度对了，但是发现空间炸了啊？能滚动吗？可以哦。每一次的值只和上一层有关，只要记这两层的就好了。</p>
<p>另外还有一个细节就是他要求的是大于等于 $n$ 的路径积方案数，所以求因子的时候注意要先 $n–.$</p>
<p><del>模数是 $1e9+7$ 不是 $998244353$！！！</del></p>
<p>$code:$  <a href="https://paste.ubuntu.com/p/qCc4dyDV4s/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/qCc4dyDV4s/</a></p>
<h1 id="Lottery"><a href="#Lottery" class="headerlink" title="Lottery"></a>Lottery</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/lottery.png" class title="lottery">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>只想到了 $n^3$ 转移的暴力。<del>其实是只去肝第一题了。。</del></p>
<p>出分：$25pt.$ </p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>首先 $n^2$ 就有一个很<del>巧妙</del>简单的转移：可以通过去掉左边端点上的两个加上右边端点上的两个点，来实现同一长度的区间从左向右的移动 $O(1)$ 得到答案。然后发现 $n=1e4?$ $O(n^2)$ 预处理好像能过。</p>
<p>但是发现空间开的很小，所以需要优化一下空间。如果直接开 $1e4\times 1e4$ 的数组要几个 $GB$ 内存啊。然后询问很少啊？</p>
<p>那就说明没有询问到的长度是无效的。所以可以先把询问离线下来，去个重编个号每次只要记每个数询问处的答案即可。</p>
<p>具体实现类似一个离散化吧。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/VtcCv5R4dp/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/VtcCv5R4dp/</a></p>
<h1 id="Sol-from-jzoj"><a href="#Sol-from-jzoj" class="headerlink" title="Sol - from jzoj"></a>Sol - from jzoj</h1><a href="/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/glo.pdf" title="solution_glo">solution_glo</a>



<a href="/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/mobitel.pdf" title="solution_mobitel">solution_mobitel</a>



<a href="/8.20%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/lottery.pdf" title="solution_lottery">solution_lottery</a>]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>单调栈</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>8.18 模拟赛  题解</title>
    <url>/8.18%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<p>比赛真的变简单了好多呢。</p><h1 id="Backpack"><a href="#Backpack" class="headerlink" title="Backpack"></a>Backpack</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.18%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/backpack.png" class title="backpack"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>首先想了一个贪心。（部分背包类似，把所有物品按照一个性价比排序。）</p><p>然后黑了自己。</p><p>然后开始 $dp$ ，发现是一个 $O(nm).$ ：</p><p>​    $\Large dp_j=\max\{dp_{j-w_i}+v_i\}.$</p><p>搞完后面的之后回头来看，发现 $a,<del>b$ 的范围只有 $[1,</del>100]$，那可以考虑做一个桶，把 $a$ 一样的物品只存它们的 $\max v.$</p><a id="more"></a>







<p>然后就得到了一个 $O(m\max a)$ 的算法，能拿 $60pt.$ 稍微考虑了一下矩乘但是好像不太好写就没管了。</p>
<p>出分： $60pt.$ </p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><h4 id="贪心。？？"><a href="#贪心。？？" class="headerlink" title="贪心。？？"></a>贪心。？？</h4><p>没错，一开始的类似部分背包的贪心有一定的正确性。可以大概的猜到，最优解里面一定会有很大一部分用性价比最大的物品组成的。所以我们考虑剩下多少贪心不一定正确。</p>
<p>首先在任意的 $n$ 个数中，一定有某些数之和是 $n$ 的倍数。证明方法考虑它们的 $n+1$ 个前缀和，由抽屉原理，一定有两个在模 $n$ 意义下同余。所以他们之差所对应的区间的数之和一定是 $n$ 的倍数。</p>
<p>如此一来，只要留下 $a_s$ 个数即可，不然可以通过用 $s$ 替换里面的若干个和是 $a_s$ 的倍数的物品，这样肯定会更优。（ $s$ 即为性价比最高的物品。）</p>
<p>这样把剩下的很少的物品做一个 $dp$ 即可。</p>
<p>$code:$ </p>
<h4 id="矩乘！"><a href="#矩乘！" class="headerlink" title="矩乘！"></a>矩乘！</h4><p>看这个 $m$ 的范围应该可以大概想到矩乘优化一下 $DP.$ 那么就是考虑怎么做转移矩阵了。</p>
<p>那么我们考虑现在的答案会从前面的哪里转移过来，用多少代价。我们发现，我们在 $i$ 的时候，会从所有的 $i-w_j$ 转移过来，并且答案是 $\max\{f_i+v_j\}.$ 所以就可以考虑构建一个 $100\times100$ 的矩阵，每次乘法是做的加法取 $\max.$ 那么矩阵具体应该是什么样的呢？</p>
<p>那么我们考虑从 $\large f_{i-k+1}\to f_i$ 转移到 $\large f_{i-k + 2}\to f_{i+1}.$ （其中 $k=\max\{w_i,~v_i\}$）首先，之前的后 $k-1$ 项和之后的前 $k-1$ 项是要相同的，考虑到是加法取 $\max$ ，可以只算矩阵中非 $-1$ 的数，并把对应斜对角线赋为 $0.$ 这样可以保证前 $k-1$ 项了。那么最后一行的矩阵就是直接和转移方程挂钩了。那么就是在所有的 $w_i$ 的位置上赋 $v_i$ 的值即可。其他空位赋 $-1.$ </p>
<p>完整矩阵如下图：（最后一行假定被所有物品填满了，且 $w_i=i.$）</p>
<p>​                                                             $\large\left[\begin{matrix} -1 &amp; 0&amp;-1&amp;\cdots &amp;-1&amp;-1\newline-1&amp;-1&amp;0&amp;\cdots&amp;-1&amp;-1\newline\vdots&amp;\vdots &amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\newline-1&amp; -1 &amp; -1 &amp;\cdots&amp;0&amp;-1\newline-1&amp;-1&amp;-1&amp;\cdots&amp;-1&amp;0\newline v_1&amp;v_2&amp;v_3&amp;\cdots&amp;v_{k-1}&amp;v_k\end{matrix}\right]$ </p>
<p>那么用它自乘再预处理前 $k$ 个就可以矩乘了。</p>
<p>$code:$ </p>
<h1 id="Median"><a href="#Median" class="headerlink" title="Median"></a>Median</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.18%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/median.png" class title="median">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>不知道是什么时候无意中看到了这道题的算法。但是没什么印象了，大概记得是二分吧。</p>
<p>所以首先我考虑在一个上面二分，然后每次在另一个上面 $lower_bound$ 出它的位置，加起来就可以知道它在合并之后的序列中的位置，复杂度就是 $O(n\log^2n).$ </p>
<p>但是出题人好像卡了两个 $\log$ 的算法。。只有暴力分。</p>
<p>所以要更优秀的算法了。我们仍然考虑二分，但方式不同了。由上面的我们可以联想到，那前一半的数大概分布是一边多一边少的（废话。。），那么我们不就可以每一次扔掉多的那部分里面的一些吗？那么为了尽量优，我们可以考虑每次丢一半，这样就能做到一个 $\log$ 啦。具体而言是这样的：</p>
<p>假设我们现在还要选的数的个数是 $p$ ，那么我们可以分别在两个序列里面取第 $\large \frac{p}{2}$ 个，然后比较一下它们的值，可以发现那个更小的一定被那更多的一边覆盖住了，所以就可以丢掉它了。这样规模减少了一半。直到一遍被删完之后，就可以直接在另一边的里面找到答案了。</p>
<p><strong>注意：上面说的更多一点其实是有问题的，仅用来理解这个算法的正确性。当一边的数分散在两极的时候，可能这边的少些，但是仍然要删它了。</strong></p>
<p>出分：$100pt.$ </p>
<p>$code: $ </p>
<h1 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.18%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/sequence.png" class title="sequence">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>我是怎么都没看出来它是一个积性函数。（因为在此之前我的认知是所有数都要有 $f(x)f(y)=f(xy).$）</p>
<p>然后写的爆搜。</p>
<p>出分： $10pt.$ </p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>没错，这应该是一个积性函数。因为如果两个数互质，那么他们和 $B$ 的 $\gcd$ 一定是互不相关，因此由乘法原理，它们乘起来的总方案数就是答案。（也就是没有重叠的多余部分被计算了。）</p>
<p>那么看着这个数据范围，就可以试一下欧拉筛了。（前面模拟赛的时候考过学过。）</p>
<p>首先考虑 $f(p^c)$ 怎么做。因为最后贡献要和 $B$ 取 $\gcd$ 所以这个一定和 $B$ 中的 $p$ 个数有关。那么考虑 $B$ 质因数分解后 $p$ 的指数是 $k.$ </p>
<p>那么对于 $A=p^c$ ，我们需要分两类讨论：$c&gt;k$ 与 $c\le k.$ 对于第二类，我们可以枚举所有 $a$ 中最小的次数 $i\leq c$ 每一次用 $p$ 的次数大于等于 $i$ 的所有数的可能情况 $(c-i+1)^n$ 减去大于等于 $i+1$ 的情况就能得到至少有一个最小值次数是等于 $i$ 的情况了，而这些整个要乘上它们的贡献，也就是 $\gcd(a_1,\dots,a_n,~B)$ 也就是 $p^c$ 了。而对于第二类，因为总的次数不能超过 $k$ ，所以 $c$ 超过的部分是没有贡献的，或者说贡献仍然只有 $p^k$，所以我们只需要枚举到 $k$ ，超过的部分直接用一个表示超过取值 $c\to k$ 的整个式子就好了，它们的贡献上面也说了，就是 $p^k$。具体就是：</p>
<p>​                            $\large\begin{equation}<br>\begin{aligned}    f(p^c)=<br>\begin{cases}<br>c\leq k&amp;&amp;&amp;\sum\limits_{i=1}^c ((c-i+1)^n-(c-i)^n)p^i.\\<br>c &gt; k &amp;&amp;&amp; \sum\limits_{i=1}^k ((c-i+1)^n-(c-i)^n)p^i+p^k(c-k)^n.<br>\end{cases}<br>\end{aligned}\end{equation}$ </p>
<p>那么实现起来就是以前的欧拉筛模板，有一点区别的就是当 $i$ 是一个合数的最小质因子的时候，我们就要另外用他这个最小质因子的整个次数去乘了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/fqgyRVMfdR/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/fqgyRVMfdR/</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>矩乘</tag>
        <tag>线性筛</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>8.17 模拟赛  题解</title>
    <url>/8.17%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<h1 id="Slope"><a href="#Slope" class="headerlink" title="Slope"></a>Slope</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.17%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/slope.png" class title="slope"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>首先读了下题，题意是找出斜率最接近 $\large\frac{P}{Q}$ 过两点直线的斜率·。</p><p>那么直接看一下一条直线的斜率和 $\large \frac{P}{Q}$ 的差是什么：</p><p>​    $\Large \Delta=|\frac{P}{Q}-\frac{y_1-y_2}{x_1-x_2}|=|\frac{P(x_1-x_2)-Q(y_1-y_2)}{Q(x_1-x_2)}|=\frac 1 Q|\frac{(Px_1-Qy_1)-(Px_2-Qy_2)}{x_1-x_2}|.$ </p><a id="more"></a>




<p>当我们转化成这样的时候，就发现分子上的部分括号内的只与某一个点有关.</p>
<p>那么对于每一个点，就可以记 $\large w_i=Px_1-Qy_1$ ，那么这里的 $\Delta$ 在忽略前面的常数之后就相当于：</p>
<p>​    $\Large \Delta = |\frac{w_1-w_2}{x_1-x_2}|.$ </p>
<p>这个式子的形式也可以看作是过两个点的直线的斜率了。我们问题就转化成求过两点的直线的斜率的绝对值最小。</p>
<p>这个问题就好求了，直接将所有点按照 $w_i$ 排序，然后只需要考虑每个点后面的那个和它相邻的点统计答案即可。</p>
<p>为什么呢？首先他前面的点跟他统计过一次答案了，所以只需要统计后面的。那么为什么在排序之后答案是最优的呢？考虑点 $i$，那么记它和 $i+1$ 连成的直线的斜率是 $k$ （不妨设两点间斜率均大于零），那么如果 $j$ 和 $i$ 有更优的答案，我们发现 $i+1$ 和 $j$ 会更优，证明如下：（其实画图很好理解）</p>
<p>​        不妨设 $i:(0,<del>0),</del> i+1:(x_1,<del>y_1), ~j:(x_2, ~y_2).$ 那么有：<br>​         $\Large</del>\frac{y_1}{x_1}&gt;\frac{y_2}{x_2}\\\therefore y_1x_2&gt;x_1y_2\\\therefore y_1x_2-x_1y_1&gt;x_1y_2-x_1y_1\\\therefore (x_2-x_1)y_1&gt;(y_2-y_1)x_1\\\therefore \Large\frac{y_1}{x_1}&gt;\frac{y_2-y_1}{x_2-x_1}$<br>​        得证。</p>
<p>程序就记一下如果相等取 $k$ 的 $\min$ 就好了。</p>
<p>出分：$100pt.$</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/MVB39949PK/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/MVB39949PK/</a></p>
<h1 id="Min"><a href="#Min" class="headerlink" title="Min"></a>Min</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.17%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/min.png" class title="min">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>第一次讲课讲 $DP$ 的时候好像说过很多种这一类题，那么考虑一个朴素的 $DP.$ </p>
<p>$f_i$ 表示最后一个区间以 $i$ 结尾的答案，那么转移就枚举最后一个区间左端点即可。具体就是：</p>
<p>​    $\Large f_i=\max\limits_{j=0}^{i-1}f_j+F(\min\limits_{k=j+1}^{i} a_k).$</p>
<p>然后就是区间最小值了， $ST$ 表即可。</p>
<p>对于那个特殊条件，对于样例稍加改动看了看函数值，发现这个时候只有当前一个数能自成一段时转移，否则跟前面合并。</p>
<p>出分：$20pt.$ 暴力挂了。不知道为什么。</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>因为只需要求之前的，并且右端点严格递增的区间最小值，因此可以用一个单调线性数据结构维护，考虑到没有对长度的限制，所以用单调栈维护就好。每一次只要维护一个位置的关键字即可。那么我们考虑答案在哪里。</p>
<p>首先答案如果是在栈上面维护的点之外的地方，那么肯定可以在它靠右的最近的一个点上有不劣的答案。那么我们只需要在关键点上更新信息就好。那么我们可以考虑维护每两个相邻关键点中间的区间中的 $f$ 值，而在不断弹出栈顶的时候可以一起记下他们的 $f$ 来继承他们的贡献。因为我们设的 $f$ 是一个前缀的答案，所以可以直接用栈顶来更新当前的 $f_i$，需要注意的是这个点单独成一个区间也需要考虑。</p>
<p>那么写起来就较为容易了。整体而言不算是很难的 $dp$ 优化，但是细节很多了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/wGNYdXZg65/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/wGNYdXZg65/</a></p>
<h1 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.17%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/swap.png" class title="swap">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>是一道有趣的题目，一开始的想法是找逆序对然后直接暴力交换，开始写的时候发现不好写。。</p>
<p>然后随便糊了一个特别慢的东西。就交了。</p>
<p>出分：$0pt.$</p>
<p>其实逆序对是可以搞的啊，只要把$B$ 关于 $A$ 类似离散化一下就好了啊。。没想到吧。</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>神奇的做法。</p>
<p>首先他说的交换好像很玄学，所以只需要考虑两两交换即可。<del>那你说什么最大最小值。。</del> </p>
<p>那么因为是两两交换，所以交换是可逆的，因此可以通过把 $A,~B$ 变成有序的，再把变换 $B$ 的序列反过来即可。</p>
<p>现在要求的就是多少次交换之后能够让整个变得有序了。什么排序算法呢？<del>冒泡</del>，快排，归并，堆？</p>
<p>快排的交换好像无法实现，堆就不说了。那考虑归并排序。</p>
<p>分治就普通分治就好，关键是怎么合并。假设我们已经有了两个有序的序列，现在就是要把它们合成一个。</p>
<p>出题人的想法很神奇。我们先让问题好描述一点。对于两个有序序列 $A,<del>B$ 需要让他们通过交换操作变得有序。这里大概借用快排的思想，就是用一个基准数 $x$。找出一个 $x$ 之后，在 $A$ 中找出所有的比它大的序列，拎出来，$B$ 中比它小的序列，拎出来。然后我们发现问题又分半：$A$ 的剩下部分和 $B$ 拿出来的部分都 $&lt;x$ ，剩下两部分都 $&gt;x$ 。但是还有问题：他们不挨着。那么交换就上场了，我们可以通过首尾的交换把 $A,</del>B$ 拿出来的部分分别反转，然后再整个翻转他们两个大区间，（通过选首尾的区间慢慢向中间选，具体可以画图。）这样两部分相互分开了，而内部就连在一起了，这样两边再分治下去，最后再连起来，就是一个有序的序列了。</p>
<p>复杂度呢？因为每一次合并的复杂度也需要分治，每一次翻转是 $O(n)$ 所以单次合并是 $O(n\log n)$ ，所以总复杂度是 $O(n\log^2n)$ 的。对于 $4096$ 的数据 $345678$ 就够了。</p>
<p>$code:$ </p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>贪心</tag>
        <tag>分治</tag>
        <tag>单调队列优化</tag>
      </tags>
  </entry>
  <entry>
    <title>8.15 模拟赛  题解</title>
    <url>/8.15%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<h1 id="Vote"><a href="#Vote" class="headerlink" title="Vote"></a>Vote</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.15%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/Vote.png" class title="Vote"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>一开始觉得应该是越靠近旁边的越容易被选上，但是写了一个小程序一看不太对。发现已选一定人之后怎么求出他们中的贡献是一定要求的所以开始推这个式子。</p><p>首先考虑 $f_i$ 表示前 $i$ 个是选上的，那么向下一个转移。然后可以插一对进去，可以两个赞成，两个反对或者一个赞成一个反对。一个赞成一个反对可以直接转移，但是另外两种情况就不行了，然后我开始走弯路，走了很远很远。。（$f_{i,~j}$ 表示前 $i$ 个 $j$ 被选了没有之类的。。）</p><a id="more"></a>



<p>然后发现还是暴力吧。就打了暴力，当然前面是一个错的贪心，因为后来我不知道为什么就想着用靠近 $0.5$ 的数。（那样是最小吧。。）</p>
<p>出分：$20pt.$ 果然，数据大的点 $WA$ 了。</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>没错，答案一定是一个前缀后缀，证明如下：</p>
<p>​    考虑一个数 $p_i$ 的贡献：$P<em>p_i+Q</em>(1-p_i)=(P-Q)p_i+Q.$ 其中 $P,~Q$ 是之前的答案，发现它其实是一个一次函数，所以极致一定在左右两端取到。证完。</p>
<p>那么左右两端可以 $DP$ 一下了。右边同理所以考虑左边。</p>
<p>$f_{i,~j}$ 表示前 $i$ 个中 $j$ 个赞成的结果。那么转移就从上一个赞成还是反对转移。具体就是：</p>
<p>​    $\Large f_{i,<del>j}=f_{i-1,</del>j-1}\times p<del>+f_{i - 1,</del>j}\times (1-p_i).$</p>
<p>最后枚举一下 $k$ 个数里面有几个在左边，几个赞成就好，注意答案是对每种选法取 $\max.$</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/qpwqWxVhdk/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/qpwqWxVhdk/</a></p>
<h1 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.15%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/Point.png" class title="Point">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>没怎么看，随便想出来了一个 $n^2$ 的暴力，就是枚举答案在哪里，然后向左右扩展找到最远的地方更新答案。</p>
<p>出分：$30pt..RE$ 了。。数组开小了。</p>
<p>重开数组之后： $95pt..????$  说好的 $5e5???$ 你让 $n^2$ 过？</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><h4 id="n-3-n-2-暴力"><a href="#n-3-n-2-暴力" class="headerlink" title="$n^3,n^2$暴力~~"></a><del>$n^3,</del>n^2$暴力~~</h4><p>数据水到一定程度。。。所谓的 $n^3$ 过 $5e5,~$ 暴力碾表算。。</p>
<h4 id="题解给的正解"><a href="#题解给的正解" class="headerlink" title="题解给的正解"></a>题解给的正解</h4><p>因为对于一段序列，如果能够是答案，那么最小的一个数一定就是那个关键数，也一定是序列中所有数的 $\gcd.$ 那么考虑用 $ST$ 表存 $\gcd$ 和 $\min$ ，二分答案判断就好，复杂度是 $O(n\log^2 n)$。</p>
<p>但是它 $T$ 了！！！这玩意没有暴力跑得快！！！</p>
<p>出题人在题解里面说要卡常才能过，但是暴力过了。。</p>
<p>唯一解释就是出题人卡了 $\gcd!!$ 如果所有的 $\gcd$ 卡满可能是更劣的。。</p>
<p>$upd…:$ 不。。其实我发现是 $math.h$ 里面的 $\log_2$ 这玩意跑的特别慢。</p>
<p><del>但是他放了暴力。。</del></p>
<p>$code:$ （$T$ 了的，<del>当然可能</del>就是我写丑了。）<a href="https://paste.ubuntu.com/p/VvckND36vP/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/VvckND36vP/</a></p>
<h4 id="优秀的线性做法-真正的标算"><a href="#优秀的线性做法-真正的标算" class="headerlink" title="优秀的线性做法 真正的标算"></a>优秀的线性做法 <del>真正的标算</del></h4><p>记得最一开始的 $n^2$ 暴力吗？这个可以优化的。因为每次是向左扩展一些，向右扩展一些，那么记一个点 $i$ 向右扩展到的点为 $r_i$ ，向左是 $l_i$ ，那么在区间 $[l_i,<del>r_i]$ 中间的点就不可能有更优的答案了，因此可以跳过他们。因此实现起来可以向两个方向扫一遍，每次向右扩展到 $r_i$ 的时候就把 $[i,</del>r_i]$ 的 $r$ 都记成 $r_i$ ，然后从 $r_i + 1$ 继续找即可。这样每个点只会被扩展一次，所以就是线性的了。！</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/yKH42tkcpP/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/yKH42tkcpP/</a></p>
<h1 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.15%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/Actor.png" class title="Actor">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>$emm..$ 不会。。考虑暴力吧。</p>
<p>然后第一个点特别小，就打了个表，其他的点放弃了。</p>
<p>出分：$13pt.$</p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>神仙 $DP~+$  优化。？咕。 </p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>8.13 模拟赛  题解</title>
    <url>/8.13%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<h1 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.13%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/Count.png" class title="Count"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>主攻它！</p><p>首先因为它要求所有数不是 $m$ 的倍数，所以首先考虑容斥一下把 $m$ 扣掉。</p><p>大概的式子是这样的：</p><p>​    $\Large C_{n - 1}^{m - 1}-\sum\limits_{k=1}^{\frac {n}{m}}C_{n-km-1}^{m-1}-\sum\limits_{k=2}^{\frac {n}{m}}C_{n-km-1}^{m-2}-…$ </p><a id="more"></a>





<p>我一开始想的是把下面一样的合并一下求，但是没有发现简洁公式。而且这个式子本来就是 $\large\frac{n}{m}$ 项的， $n$ 那么大它项数就直接炸了。</p>
<p>所以换一个思路，考虑他们对 $m$ 的余数。因为不被整除，所以原式可以直接表示成 $\sum a_i\equiv A\mod m$ 。所以每一个 $a_i$ 可以转化成对 $m$ 的余数和商两部分，商部分因为没有任何限制，所以可以直接挡板法求，余数部分相当于若干个 $\in[1,<del>m-1]$ 的整数相加与 $n$ 模 $m$ 同余。同样，我们把 $n$ 也分成被 $m$ 组成的部分和被余数组成的部分，因为余数有范围，所以 $n$ 被余数组成的部分 $N’\in [k,</del>k(m-1)]$ 。这个东西规模就从 $10^{18}$ 缩小成 $km$ 了。那我们来看怎么求这些余数部分。</p>
<p>首先是同余，所以 $N’$ 的取值也是以 $m$ 为间隔的，也就是我们可以枚举这个和，复杂度是 $k$ 的，然后还是可以挡板，但是有 $[1,~m -1]$ 的限制。容斥一下？有点麻烦先看看其他的吧。（不麻烦啊这就是正解！！！）</p>
<p>当时我开始想能不能用类似背包的东西递推一下。就是 $N’k$ 的，也就是 $mk^2$ 的。写完之后发现更新的那重可以去掉改成前缀和减，所以单个 $N’$ 的求值部分复杂度就降到 $mk$ 了，总复杂度就是 $mk^2.$</p>
<p>可以过 $70pt.$ 了！那这个还能优化吗。？可能真的是还可以的，但是时间已经差不多了。写了个对拍发现过了。</p>
<p>出分：$30pt…$ ？？我过了拍还挂分了？然后发现怎么都调不对。</p>
<p><del>结果最后我写的正解的代码跟他拍还是过了，但是还是WA了。？原因后面会说。。orz…</del></p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><h4 id="容斥"><a href="#容斥" class="headerlink" title="容斥"></a>容斥</h4><p>真不难。。就是我上面说的容斥，先不考虑限制，然后减去一个超过了限制的结果，再加上两个超过了等等等。</p>
<p>当时真的就差实现的一步了。。至于实现就是超过限制的时候把超过的那 $m-1$ 减掉在求一个挡板。</p>
<p>然后就是它和前面的 $70$ 暴力过了拍但是 $WA$ 了的情况。。</p>
<p>经过长久的调试，我发现是再求组合数的地方爆了 $ll…$ 因为那是要求 $m$ 的倍数部分，所以是 $\large\frac{n}{m}+k-1$ 所以超级大，然后没取模直接成了 $ret…$ 就炸了。。<del>关键是爆成负数我都不知道因为后面把负数取回来了。。</del></p>
<p>然后就 $A$ 了。应该不算道难题吧。。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/dJRMVsjtkW/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/dJRMVsjtkW/</a></p>
<h4 id="生成函数。？"><a href="#生成函数。？" class="headerlink" title="生成函数。？"></a>生成函数。？</h4><p>老师说是道板子。。但是没学。。咕。（好像说代码和容斥是一样的。？）</p>
<h1 id="Pj"><a href="#Pj" class="headerlink" title="Pj"></a>Pj</h1><p>普及组？你在逗我。。</p>
<h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.13%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/pj.png" class title="pj">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>暴力滚了。</p>
<p>出分： $0pt.~~CE$ 了。。我随机数的 $ctime$ 头文件没打有尖括号。。</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>好像也不算难吧。</p>
<p>首先题目把 $x$ 给你了，就分解质因数，因为质因数之间是独立的。（鬼知道啊。。）</p>
<p>然后发现每个数的质因数指数不超过 $2.$ 然后考虑递推，分别看 $1,~2$ 两种情况。</p>
<p>指数是 $1$ 的时候可以发现就是删除最后一列上的 $1$ 所在位置以及它所在的行，那么一共有 $n$ 个位置，所以就是 $f_i=if_{i-1}.$</p>
<p>指数为二的时候有两种情况，就是一个 $2$ 和两个 $1.$ </p>
<p>一个二的时候可以类似上面转移，但是两个一就需要再考虑了。</p>
<p>考虑最后一列的 $i,<del>j$ 有两个 $1.$ 第 $i,</del>j$ 行的另一个 $1$ 在或者不在同列。首先要选两个 $1$ 在那就是 $\large C_i^2.$</p>
<ol>
<li>不在同列的话我们考虑合并其中的两列（可以 $i$ 的到 $j$ 也可以反过来。），那么就变成了两个 $1$ 在一列上。这个就是 $\large 2C_i^2f_{i-1}.$ </li>
<li>在同列的话我们首先去掉 $j$ 行和最后一列，然后在 $i$ 行另一个 $1$ 的位置变成 $2.$ 这个 $2$ 则考虑上面 一个 $2$ 的处理方法，那么同列情况的总数就是 $\large (i-1)C_i^2f_{i-2}.$ 注意因为上面一种情况我们算过这个一次了，所以要把它减掉。</li>
</ol>
<p>这样就有总的转移式：</p>
<p>​        $\Large f_i=if_{i-1}+2C_i^2f_{i-1}-(i-1)C_i^2f_{i-2}$ </p>
<p>这是对于每一个质因数的，总体而言呢？首先对于他们本身是可以加偶数个负号的，这个可以除了最后一行一列任意加，最后一行一列调整一下乘积即可，就是要乘上 $\large2^{(n-1)^2}.$ 然后乘上每一个质因数的答案即可。</p>
<p>然后线性递推出来记一下有几个 $1$ 几个 $2$ ，快速幂一下回答询问就好。</p>
<p>总复杂度 $O(n+q\log n).$ （$\log$ 在快速幂。）</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/fCnZ6myWHn/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/fCnZ6myWHn/</a></p>
<h1 id="Tg"><a href="#Tg" class="headerlink" title="Tg"></a>Tg</h1><img src="/8.13%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/tg.png" class title="tg">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>暴力滚了。但是还是手玩了几组样例，觉得那个序列挺有意思的，但是没时间了。</p>
<p>出分：$3pt.$ 这个点没有询问。。</p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>原来的那个最大下降子序列长度为 $2$ 的排列可以等价于一个前缀最大值序列。</p>
<p>前缀最大值序列是什么？就是每个位置记这个位置前缀的最大值。</p>
<p>为什么呢？对于一个前缀最大值序列，我们考虑改变了最大值的点，称为关键点，那么除去关键点之外的数字，它们必须是从小到大，并严格依次插入到空隙之中的。不然考虑有两个关键点 $i,<del>j$ 中间有两个数 $x,</del>y$ 不是关键点，但是 $x&gt;y,<del>p_x&lt;p_y$ ，那么就会出现一个下降子序列 $i&gt;x&gt;y$ 长度大于 $2$ 了。（$i&gt;x$ 是因为它现在在两个关键点之间，所以 $i$ 在区间 $[i,</del>j)$ 里面是最大值。）就矛盾了，就证明了原命题。</p>
<p>至于出题人怎么想到这样转换就不得而知了。</p>
<p>然后询问呢？寻询问是给出 $x,~y$ 让 $a_x=y.$ 那么两种情况：</p>
<p>​    $x\leq y:$ $y$ 一定在关键点上，不然前面会有一个比它大的点，而前面只有 $x-2$ 位，却要填上 $y-1$ 个数由抽屉原理可知一定有一个比 $y$ 小的数在 $y$ 后面，那就有一个长度大于 $2$ 的下降子序列了。矛盾。<br>​    $x &gt; y:$  把整个序列反转过来就是上面的情况了。</p>
<p>他是关键点的话怎么求呢？</p>
<p>考虑前缀最大值序列是什么。一个这样的序列可以看做是在一个坐标轴上，从 $(0,<del>0)$ 走到 $(n,</del>n)$ ，每次只能向上或者向右走，并且不能超过直线 $y=x$ 的方案数。（横坐标是 $i$，纵坐标是前缀 $\max.$）这个应该比较好理解。</p>
<p>那么现在就相当于有一个必经点，那答案就可以直接用组合数求了：</p>
<p>​    $\Large Ans=(C_{(x-1)+(y-1)}^{x-1}-C_{(x-1)+(y-1)}^{x})\times (C_{(n-x+n-y)}^{n -x}-C_{(n-x+n-y)}^{n -x - 1})$ </p>
<p>（上面要 $+1$ 是因为要手动过直线 $y=x$）</p>
<p>预处理阶乘快速幂求即可。时间复杂度同样 $O(n+q\log n).$ </p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/Mz2wnVvhWt/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/Mz2wnVvhWt/</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>容斥</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>8.12 模拟赛  题解</title>
    <url>/8.12%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<h1 id="Maze"><a href="#Maze" class="headerlink" title="Maze"></a>Maze</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.12%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/maze.png" class title="maze"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>第一眼看到了那个 $n$ 好像特别小，就想着能不能用 $n\times n$ 的正方形来分成很多很多块，然后一起做，至于询问的话想了一下线段树来维护边上的点到另一边点的最短距离（每个节点上开二维数组存），然后写广搜初始化和旁边的情况。至于线段树上的合并可以枚举一下中间从哪里走然后更新整个的答案。</p><a id="more"></a>


<p>然后。。。分块块 $+$ 线段树加上两边的广搜，我第一次发现线段树写起来简单。最后一个小时开始写的，还没写完就 $250$ 行左右，还没搞完还没调试。没了。</p>
<p>出分：没交。</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>很不幸的是分块和线段树两种都能做。没必要结合在一起。我服了我自己。</p>
<h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><p>虽说也是分块，但这是普通的分块，就是分成 $\sqrt m$ 块。 然后也是两边暴力 $bfs$ 然后中间预处理完了就直接跳大块。修改的话是暴力重构是 $O(n^2\sqrt m)$ 的，询问要枚举中间的转移点，是 $O(n^3\sqrt m)$ 的。</p>
<p>总复杂度就是 $qn^3\sqrt m.$ </p>
<p>好像这个开 $O3$ 优化可以过。</p>
<h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>跟我前面用的线段树一样但有几点变动。</p>
<p>不需要分组！！！然后每个地方也是二维数组存的是从左端点到右端点的每对点之间的最短距离。转移的时候也是枚举一个中间点转移。然后查询直接分下去，修改直接改单点。</p>
<p>这样复杂度就都是 $qn^3\log m.$ </p>
<p>好写多了。。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/8qCFTTQkwM/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/8qCFTTQkwM/</a></p>
<h1 id="Mhw"><a href="#Mhw" class="headerlink" title="Mhw"></a>Mhw</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.12%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/mhw.png" class title="mhw">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>看上去是个二分图的样子。题目给了两类人，在一定距离下他们有克制关系。那就相当于有向边啊。</p>
<p>因为要求的三点环必须有两条边是横跨两边，另一边在一半上的，所以只需要给那个在一半上的点定向就可以了。那么三点环有几种连边情况：（对于在一边的两点 $x,~y$ 和 另一边上的点 $z$）</p>
<pre><code>1. 对于两条边 $x\leftrightarrow z \&amp; y \leftrightarrow z$ 他们的方向必须是反的。就是： $x\rightarrow z \&amp; z \rightarrow y$ 或 $y\rightarrow z(\alpha) \&amp; z \rightarrow x(\beta).$ 
​     2. 对于上面的两种不同的边的方向，我们要给 $x \leftrightarrow y$ 定向，在最大值的时候就是在所有 $\alpha$ 和 $\beta$ 环里面找到较多的一个给它们定向，最小值则相反。</code></pre><p>那么求两点间的边数就可以确定边的方向了。我只会 $n^3$ 的方法。。</p>
<p>出分： $20pt.O(n^3).$ </p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>$O(n^3)$ 可以过 $1000????$ （要开 $O3$ 优化别想了。）</p>
<h4 id="线段树扫描线"><a href="#线段树扫描线" class="headerlink" title="线段树扫描线"></a>线段树扫描线</h4><p>又是你。扫描线。</p>
<p>这玩意跟扫描线有什么关系啊。？</p>
<p>我们先继续上面的两项向下分析。先把两边的点染色，左边的染白色，右边染黑色。那么我们先考虑所有白点间的边。</p>
<p>我们记白点 $x$ 连向一个黑点的黑点总数是 $f_x.$ 而两个白点 $x,<del>y$ 同时连向一个黑点的黑点总数是 $g_{x,</del>y}.$ </p>
<p>所以对于两个点 $x,<del>y$ 间半环（两条确定边）个数就是 $f_x-g_{x,</del>y}$ 相当于取一个补集。</p>
<p>那么对于所有的贡献就是：</p>
<p>$\Large \begin{aligned}Ans&amp;=\sum\limits_{x,y\in S_{white}} \max\{f_x-g_{x,y},f_y-g_{x,y}\}\\\Large&amp;=\sum\limits_{x,y\in S_{white}} \max\{f_x,f_y\}-g_{x,y}\end{aligned}$</p>
<p>那么我们再考虑右边的那个 $g_{x, y}$ 能不能也化成 $f_x$ ？</p>
<p>它的意思就是同时连向了一个黑点，那么反过来就是一个黑点被两个白点连了，那么既然我们还要求一遍所有黑点 $f$ 那么就相当于是对于每一个黑点，选两个连向自己的边的总数。所以把 $f$ 重新定义成连向异色点的。</p>
<p>那么就是：$\large \sum g_{x, y} = \sum\tbinom{f_k}2.$具体而言就是说：</p>
<p>$\Large Ans=\sum\limits_{x,y\in S_{white}} \max\{f_x,f_y\}-\sum\limits_{k\in S_{black}}\tbinom {f_k}2.$</p>
<p>剩下的就是求所有的 $f_x$ 了。 </p>
<p>我们回到最初的连边条件：曼哈顿距离小于等于 $D.$ 这个不太好处理所以<del>常规地</del>把他转化成切比雪夫距离。至于它是什么：</p>
<p>​    对于两个 $k$ 维的点 $A,~B$，其中 $A=(a_1,a_2,…,a_k)$，<br>​    则他们的切比雪夫距离定义为：$\large\max\limits_{i=1}^k\{|a_i-b_i|\}.$</p>
<p><del>曼哈顿距离是什么就不说了。。</del> </p>
<p>那么怎么转换呢？曼哈顿距离只是二维的，所以对于 $(x,y)$，就变成 $(x+y,x-y).$ </p>
<p>但其实理解起来没那么复杂。我们要算的是曼哈顿距离小于等于 $D$ 就是说要在范围内的点集。因为是曼哈顿距离，所以他就是一个斜着的正方形。这个就已经变成了二维的矩形内选点，但是线段树扫描线只能搞横平竖直的矩形，所以考虑把所有正方形旋转 $45^\circ$ 。而这个其实就可以用上面的那个变换。</p>
<p>还有一个问题，就是这样转换完之后长度没变吗？没变！证明如下：</p>
<p>​    对于两个点 $A(x_1, y_1),<del>B(x_2,y_2)$，<br>​    他们变换之后变成了：$A’(x_1+y_1, x_1 -y_1),</del>B’(x_2+y_2,x_2-y_2).$<br>​    然后之前的曼哈顿距离是：$|x_1-x_2|+|y_1-y_2|.$<br>​    现在的切比雪夫距离是： $\max\{|(x_1+y_1)-(x_2+y_2)|, |(x_1-y_1)-(x_2-y_2)|\}.$<br>​    还记得三角不等式吗：$|a-b|\leq|a|+|b|.$ 和 $|a+b|\leq|a|+|b|.$<br>​    我们记 $a=x_1-x_2,~b=y_1-y_2$，不就是最大值吗？<br>​    证完。</p>
<p>那么就用线段树扫描线扫以一个点为中心的矩形里面包含的点的数量即可。（前缀点数和。）</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/PTvD7P2Yqr/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/PTvD7P2Yqr/</a></p>
<h1 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.12%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/factory.png" class title="Factory">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>一开始想到思路的竟然是这题。</p>
<p>既然要任意情况都行，所以最后的矩阵一定是一个对角线上全是 $1$ 的正方形的方案。</p>
<p>所以就贪心排个序，然后顺着用并查集记一下现在所在的正方形大小。</p>
<p>然后自己黑了自己。。然后随便排了下序过了，然后交了。</p>
<p>出分：$30pt.$ 贪心是错的。</p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>神仙状压 $DP.$</p>
<p>听了三遍之后感觉差不多了。</p>
<p>首先题目给的一个人会不会操作几台机器给出的一张表其实就可以相当于是一张二分图。</p>
<p>那么一个人会操作就相当于给那个机器连上了一条边。由于上面那个小结论，我们就是需要把每个二分图上的联通块连成完全二分图并且两边点数相等。</p>
<p>证明呢？考虑反证：</p>
<p>​    如果不连通，那么设人有一些没和 $x$ 连边，那么当和 $x$ 连边的人不做 $x$ 的时候，就没人做 $x$ 了。</p>
<p>​    如果联通了但是点数不相等，那么就无法一一分配。</p>
<p>然后我们把每个联通块记成一个二元组 $(x_i,~y_i)$ 那么考虑怎么选这些二元组让代价最小。那么考虑状压 $DP$ 看每个联通块选不选时候的答案。</p>
<p>如可统计答案呢？因为已连边数不变，要加的边数等于总边数减已连边数，所以最小化总边数即可。总边数则是 $\large\sum\limits_{S’\subseteq S}\sum\limits_{i\in S’} x_i\times\sum y_i=\sum\limits_{S’\subseteq S}(\sum\limits_{i\in S’}x_i)^2.$ </p>
<p>最暴力的方法 $dp_S$ 表示选 $S$ 集合的答案，转移则枚举子集，如果子集满足 $\large \sum\limits_{i<del>\in</del>S’} x_i=\sum\limits_{i<del>\in</del>S’} y_i$ 就用它更新答案。复杂度是 $3^{cnt}$ ，$cnt$ 是二元组数量。</p>
<p>然后慢慢优化它。</p>
<p>设 $dp_{S,<del>i}$ 表示现在已选的数是 $S$ ，在处理的联通块里面的 $\sum x=i.$ 那么每次枚举一个二元组加到状态里面即可，然后如果 $S$ 有 $\sum x=\sum y$（之前配好了，现在也配好了，所以总的是好的。），就相当于目前已经可以更新答案了就给 $dp_{S,</del>0}$ 更新。时间复杂度是 $2^{cnt}n.$ 还需要进一步优化。</p>
<p>发现其实不需要把每一个二元组记下来，只需要记每一种二元组出现了多少次。这个可以用一个 $cnt$ 压起来，每次向上枚举就可以了，出题人说其实 $n=30$ 时一共只有 $1.7e5$ 左右种二元组，每一次就只需要枚举一种二元组，那么时间复杂度就是 $O(n\times 1.7e5)$ ，是能过的。空间复杂度可能有点高，但是也不会太大。</p>
<p>$code:$ </p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>8.10 模拟赛  题解</title>
    <url>/8.10%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<p><del>因为好像走了就用不了 $jzoj$ 了所以不放比赛地址了。。</del></p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.10%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/math.png" class title="math"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>考场上主要玩这题了。能 $A$ 了就值了。。</p><p>首先朴素的把答案的式子展开：$\vec a=(x_1, y_1), ~\vec b = (x_2, y_2).$</p><p>​    $\large\begin{equation} \begin{aligned}Ans &amp;=|\lambda_1\vec a+\lambda_2\vec b|^2\\&amp;=(\lambda_1x_1+\lambda_2x_2)^2+(\lambda_1y_1+\lambda_2y_2)^2\ &amp;=\lambda_1^2x_1^2+2\lambda_1\lambda_2x_1x_2+\lambda_2^2x_2^2+\lambda_1^2y_1^2+2\lambda_1\lambda_2y_1y_2+\lambda_2^2y_2^2 \ &amp;=\lambda_1^2(x_1^2+y_1^2)+2\lambda_1\lambda_2(x_1x_2+y_1y_2)+\lambda_2^2(x_2^2+y_2^2)\end{aligned}\end{equation}$ </p><a id="more"></a>





<p>然后因为 $\vec a, <del>\vec b$ 是给定的，所以可以记 $\large a=x_1^2+y_1^2,</del>b=x_1x_2+y_1y_2,~c=x_2^2+y_2^2.$ </p>
<p>那么式子就变成了：$\large Ans =a\lambda_1^2+2b\lambda_1\lambda_2+c\lambda_2^2$，然后我们研究右边。</p>
<p>首先有 $a\geq 0$ 所以把右边配成定点式有：$\large a(\lambda_1+\frac b a \lambda_2)^2+\frac{ac-b^2}a \lambda_2^2 \geq \frac{ac-b^2}a \lambda_2^2$ </p>
<p>它有什么用呢？</p>
<p>首先，如果我们枚举一个 $\lambda_2$ 的话，我们就可以通过取 $\lambda_1$ 顶点 $\frac a b\lambda_2$ 附近的两个值就是最小值了。进一步可以发现，因为包含 $\lambda_2$ 的项有平方，而 $\lambda_1$ 又可以根据它来取，所以可以令 $\lambda_2\geq 0$ ，这样它小于零的情况可以通过把 $\lambda_1$ 取反等效成大于零。</p>
<p>其次，我们继续观察它的顶点纵坐标 $\frac{ac-b^2}a \lambda_2^2$ 。因为我们取的 $\lambda_2$ 是递增的自然数，所以它的平方递增的速度就非常快了，那么我们看看它的系数是不是也是非负的，这样就可以提很多速了。首先下面是非负的，也就是正的了，那么上面可以：</p>
<p>​    $\large\begin{equation} \begin{aligned}ac-b^2&amp;=(x_1^2+y_1^2)(x_2^2+y_2^2)-(x_1x_2+y_1y_2)^2\\&amp;=x_1^2x_2^2+x_1^2y_2^2+y_1^2x_2^2+y_1^2y_2^2-x_1^2x_2^2-2x_1x_2y_1y_2-y_1^2y_2^2\\&amp;=x_1^2y_2^2+y_1^2x_2^2-2x_1x_2y_1y_2\ &amp;=(x_1y_2+x_2y_1)^2\geq0.\end{aligned}\end{equation}$</p>
<p>好的！它是非负的。所以就可以这样做啦！</p>
<p>然后开始和纯暴力拍，拍了一会改了些错发现没什么问题。</p>
<p>然后随机了几组数据发现跑的飞快。（$300ms\sim500ms $ 加个 $O(2)$ 估计会很快）</p>
<p>出分：$100pt.$ //数据有点水，我这个算法应该能被卡的。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/x3m5FqDWCw/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/x3m5FqDWCw/</a></p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>那个算法很奇妙，所以还是好好写一下。</p>
<p>首先它是从欧几里得算法过来的。（靠虑共线的时候就是 $\gcd$ 最小。（$ax+by=1.$））</p>
<p>我们考虑两条向量的夹角到一定程度之后是什么样的。还是从答案出发，这次用点乘：</p>
<p>​    $\large\begin{equation}\begin{aligned}Ans&amp;=|\lambda_1\vec a+\lambda_2\vec b|^2\ &amp;=\lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2+2\lambda_1\lambda_2|\vec a·\vec b|\ &amp;=\lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2+2\lambda_1\lambda_2|\vec a||\vec b|\cos\ang\theta.\end{aligned}\end{equation}$</p>
<p>其中 $\theta$ 就是夹角了，我们想把前面的 $2$ 消掉？那 $\theta$ 取 $60^\circ$？</p>
<p>​    $\large\begin{equation}\begin{aligned}Ans&amp;= \lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2+2\lambda_1\lambda_2|\vec a||\vec b|(-\frac1 2)\\&amp;=\lambda_1^2|\vec a|^2+\lambda_2^2|\vec b|^2-\lambda_1\lambda_2|\vec a||\vec b|.\end{aligned}\end{equation}$ </p>
<p>两个 $\lambda$ 分别取 $0$ 的时候坑定是另一项取 $1$ 最优，那不就是等于 $\vec a^2$ 或 $\vec b^2$？</p>
<p>那么不取零的时候呢？考虑配方：</p>
<p>​    $\large\begin{equation}\begin{aligned}Ans&amp;\geq|\lambda_1^2\vec a|^2+|\lambda_2^2\vec b|^2-|\lambda_1\vec a||\lambda_2\vec b|\\&amp;=(|\lambda_1\vec a|-|\lambda_2\vec b|)^2+|\lambda_1\vec a||\lambda_2\vec b|\\&amp;\geq|\lambda_1\vec a||\lambda_2\vec b|\geq|\vec a||\vec b|.\end{aligned}\end{equation}$</p>
<p>那我们不妨设 $|\vec a|\geq|\vec b|$ 就有：</p>
<p>​    $\large Ans \geq \vec a^2.$ </p>
<p>$OK$ 了！</p>
<p>而当夹角更大的时候 $\cos \theta$ 是减小的所以那个东西是大于等于这个六十度的时候，所以同理了。</p>
<p>也就是说把角度搞到 $60^\circ$ 以上就好了？那我们怎么改角度呢？因为我们的 $\lambda$ 是任取的，所以两个向量分别加上一定倍数的对方是没有影响的。（可以通过减对方减回来。）<br>即 $Ans\{\vec a,<del>\vec b\}=Ans\{\vec a,</del>\vec b+k\vec a\}.$</p>
<p>好的那么我们构造一下。</p>
<p>这里记 $\vec a=\vec{OA},~\vec b = \vec{OB}$，其中 $|\vec a| \leq |\vec b|$考虑两个向量的差 $\vec c=k\vec a-\vec b$ ，那么我们可以直接求 $Ans\{\vec a , ~\vec c\}$ 即可，那么怎么取 $k$ 可以让夹角尽量大呢？</p>
<p>考虑向量 $\vec b$ 在 $\vec a$ 所在直线上的投影点 $K$ ，然后考虑 $k\vec a$ 在 $K$ 附近，这里假设 $k\vec a=\vec{OA’},~（k+1）\vec a=\vec{OA’’}$ ，而 $K$ 在 $A’A’’$ 上。则：</p>
<p>​    如果 $|k|=1$ ，那么直接取它就好。</p>
<p>​    不然的话考虑哪一个更优，就比较 $BA’$ 和 $BA’’$ 的大小就好。</p>
<p>但其实实现上来说直接取 $k\vec a$ 就够了。</p>
<p>这样慢慢增大夹角直到大于 $60^\circ$ 的话，就相当于是欧几里得里面的不断取模，最后得到答案。</p>
<p>这个复杂度作者也不会证，但是几次就能得到答案的，因为每次增加的角不小。（作者猜测 $log$ 级）</p>
<p>这个复杂度就比上面的剪枝靠谱多了。</p>
<p>$code:$ </p>
<hr>
<h1 id="Treasure"><a href="#Treasure" class="headerlink" title="Treasure"></a>Treasure</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.10%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/treasure.png" class title="treasure">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>一看就是爆搜？写了写前两个点，自己造的小数据过了，就没管了。</p>
<p>具体做法就是每一层记录最左最右的宝藏位置，那么他们之间的一定挖过了。然后暴力看走那个就好。</p>
<p>出分：$0pt.$ </p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>好像是用斯坦纳树，看了博客不太会。咕。</p>
<h1 id="City"><a href="#City" class="headerlink" title="City"></a>City</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.10%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/city.png" class title="city">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>建树$+DP$ ？</p>
<p>写了写一个倍增求路径和但是是错的。</p>
<p>出分：$0pt.$ </p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>这是个 $IOI2012<del>Day2</del>T1$？？？</p>
<p>做法还是挺有意思的。</p>
<p>我们考虑如果是一棵树怎么办。就直接树形 $DP$ ，对于一个点 $now$ 记其子树大小 $siz$ ，我们考虑它和父亲连的边的贡献就是 $siz\times(n-siz).$ </p>
<p>那么这道题呢？考虑把它变成树，而我们每一次只考虑横着的或者纵着的联通块。这样就能分别处理出竖向边和横向边分别的贡献，然后累加即可。</p>
<p>是的。就是如此简单，至于横纵交换交换一下横纵坐标即可。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/Nk5JBZfKRc/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/Nk5JBZfKRc/</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>斯坦纳树</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>8.9 模拟赛  题解</title>
    <url>/8.9%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<p>比赛地址：<a href="http://jzoj.net/senior/#contest/home/2835" target="_blank" rel="noopener">http://jzoj.net/senior/#contest/home/2835</a></p><hr><h1 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.9%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/cell.png" class title="cell"><p>###　考场</p><p>比较简单的题吧，首先它给出了一种叫传送门的东西要走迷宫，就先看看传送门用来做什么。</p><p>它可以被开在墙上，然后在墙边上传送过去。</p><p>那么就相当于两个点由一条更近的路连在一起了，那么就考虑最短路，看这个可能连成稠密图，所以跑 $dijkstra$ 。</p><a id="more"></a>







<p>怎么建边呢？首先两个相邻的不是墙的点之间要连，长度为 $1$，另外在墙边上可以传到其他传送门去。所以墙边上就向每一个对着的墙前的空地连长度为 $1$ 的边。然后最短路。</p>
<p>出分： $0pt. RE$ ？？？？？经过反复检查<del>提交</del>发现我在读图的时候用 $int$ 存了 $char.$ 但理论上没什么事啊。。$orz…$</p>
<p>改了之后还是没有 $A$ 为什么呢？</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>仔细读题！发现第二项说明，就是建传送门的时候不需要和墙相邻！那么在四边没有墙的地方就也可以向某一边发传送门，然后走到另一个最近的墙，再在那座墙上开个传送门传到原来发了传送门的地方。也就是对于点 $(i, <del>j)$ 向四个方向拓展到了墙是 $(x_k,</del>y_k),<del>k \in [0,</del>3]$ 那么向每个点建长度为 $\min |x_k-i+y_k-j|+1$ 的边。（这里最近的点可能建了更远的边，但是没关系，因为我们可以直接用以前建好了的相邻空地的边走过去。）</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/hbSPW2jsFJ/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/hbSPW2jsFJ/</a></p>
<h6 id="原题：jzoj5781"><a href="#原题：jzoj5781" class="headerlink" title="原题：jzoj5781"></a>原题：<a href="http://jzoj.net/senior/#main/show/5781" target="_blank" rel="noopener">jzoj5781</a></h6><hr>
<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.9%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/tree.png" class title="tree">

<h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>这个，好复杂，没什么想法。。</p>
<p>考虑一下随机吧！既然是二叉搜索树，$n$ 也很小，那就考虑每次随即一个插入顺序，暴力插入更新答案？</p>
<p>可以的，第二个样例天差地别。。</p>
<p>不管了看 $T3$ 了。。</p>
<p>出分：$5pt..emm…$ 随机化一分没有。。//特判第一个点的 $5pt…$</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>因为一个二叉搜索树的根可以相当于有序序列上的一个中间点，左边的区间就是左子树，右边的区间就是右子树。因为一个区间 $[l,~r]$ 只可能挂在 $l-1$ 的右边或者挂在 $r+1$ 的左边。所以我们记一下一个区间是挂在哪个爸爸上的。然后我们是知道整棵树的答案，所以可以类似区间 $dp$ 来做。</p>
<p>首先 $f_{l,<del>r,</del>0/1}$ 表示一段区间左端点（$0$）或右端点（$1$）是爸爸，自己就是 $[l+1,<del>r]$ 或者 $[l,</del>r - 1].$ 那么考虑一个普通的区间 $dp$ 是怎么转移的。 首先枚举左端点和右端点，那么我们考虑怎么转移，这里因为是可以把自己的爸爸挂在它爸爸的左边或者右边，再考虑向 $f_{l-1,<del>r,</del>0}$ 和 $f_{l,<del>r-1,</del>1}$ 转移，就有方程：                                $\Large f_{l-1,<del>r,</del>0}=\max f_{l,<del>k,</del>1}+f_{k,<del>r,</del>0}+\sum_{i=l}^{r}K_i,\quad \gcd(K_{l-1},<del>K_k)&gt;1\\\Large f_{l,</del>r +1,<del>0}=\max f_{l,</del>k,<del>1}+f_{k,</del>r,<del>0}+\sum_{i=l}^{r}K_i,\quad \gcd(K_{r+1},</del>K_k)&gt;1$</p>
<p>后面的区间和考虑用前缀和预处理即可。并且如果每一次求 $\gcd$ 也会 $T$ 掉，所以两两间的 $\gcd$ 也要预处理。$k$ 跟另外答案是 $\max f_{1,<del>i,</del>1}+f_{i,<del>n,</del>0}.$ </p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/f2wk9GBwJX/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/f2wk9GBwJX/</a></p>
<hr>
<h1 id="Rotate"><a href="#Rotate" class="headerlink" title="Rotate"></a>Rotate</h1><img src="/8.9%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/rotate.png" class title="rotate">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>题意很简单，先考虑第一个 $30pt.$： $O(n^3)$ 暴力：暴力选区间，暴力反转，暴力找对数。</p>
<p>然后看第二个数据点是个 $O(n^2)$ 的做法，那考虑优化上面那个暴力：不需要暴力找了，可以固定一个中间点，然后一对一对向外面扩展，没扩展一层更新答案。这就有 $60pt.$ 了。（卡到了 $65pt..$）</p>
<p>最后要交题的时候准备推一下一个点到自己的对应位置的式子，发现对于每个点有：</p>
<p>​        对于点 $i$ 要去的点是 $a_i$ ，如果关于 $k_i$ 对称过去，那么有 $i+a_i=2k_i.$ </p>
<p>然后发现左边的每个点是固定的，所以对应 $k_i$ 也是固定的，那么考虑一下反转区间，发现反转区间的左右端点肯定是有一个固定点的，因为没有的话就没必要扩展开，不扩展是不劣的。（可能把固定点翻没了。）那就可以考虑每一个点的这个 $k_i$ ，更新答案，所以我们需要维护的是反转区间里面 $k_j=k_i$ 的点的个数，反转区间外的前后缀和解决。这个可以用根号算法解决，比如分块？莫队？</p>
<p>分块写的快些所以当时写的分块，但是没调出来。<del>就算调出来了也要爆空间。。</del></p>
<p>交的平方暴力。</p>
<p>出分：$65pt.$ </p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><h4 id="莫队（-O-n-sqrt-n-）"><a href="#莫队（-O-n-sqrt-n-）" class="headerlink" title="莫队（$O(n\sqrt n)$）"></a>莫队（$O(n\sqrt n)$）</h4><p>上面讲的够清楚了，接下来就是把那些反转区间的询问用莫队搞一搞了。应该就是模板了，只需要询问区间内某个数的出现次数即可。//注意维护的是 $v_i$ 也就是 $a_i+i~!!!$ </p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/nB6h7KSrbx/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/nB6h7KSrbx/</a></p>
<h4 id="优化上面的平方暴力？（-O-n-log-n-，-log-数据结构（其实可以排序降一点）。）"><a href="#优化上面的平方暴力？（-O-n-log-n-，-log-数据结构（其实可以排序降一点）。）" class="headerlink" title="优化上面的平方暴力？（$O(n\log n)$，$\log$ 数据结构（其实可以排序降一点）。）"></a>优化上面的平方暴力？（$O(n\log n)$，$\log$ 数据结构（其实可以排序降一点）。）</h4><p>首先上面分块的时候说过一个反转序列的左右端点一定在反转之后是一个不动点，然后就可以记一下一个点的不动点在哪里，挂在那个中间点后面，然后在枚举中间点的时候就可以左右跳只跳到不动点的位置更新答案，这里因为要顺着跳，所以可以用一个大根堆记左端点（或小根堆记右端点），然后一个个跳着更新答案就可以了。因为只有 $n$ 个点，所以只会跳 $n$ 次，加上堆的复杂度就是 $O(n\log n).$ </p>
<p>其实复杂度瓶颈在让每个点后面的数有序，其实用一个线性排序算法就可以总体线性了。（基数排序。？）</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/x552Wr74HK/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/x552Wr74HK/</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>最短路</tag>
        <tag>莫队</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>8.7 模拟赛  题解</title>
    <url>/8.7%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<p>比赛链接：<a href="http://jzoj.net/senior/#contest/home/2833" target="_blank" rel="noopener">http://jzoj.net/senior/#contest/home/2833</a></p><h1 id="Seq"><a href="#Seq" class="headerlink" title="Seq"></a>Seq</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.7%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/seq.png" class title="seq"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>题目变简单了。这道题一个递推式很显然地看出可以做矩乘。那考虑怎么构造矩阵。</p><p>因为他都是前面式子相乘得到的下一项，而递推式里的常数 $b_i$ 又在指数上，可以想到两个等底数的式子相乘就等于他们的指数相加。那么只需要在指数上做矩乘维护一个递推后的指数和就好了。</p><a id="more"></a>




<p>这么构造矩阵的话，转移矩阵会很好看：</p>
<p>$\begin{bmatrix}<br>0 &amp;1 &amp; 0 &amp; …&amp;0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; …&amp;0 &amp; 0\\<br>&amp;&amp;&amp;…\\<br>0 &amp; 0 &amp; 0 &amp; …&amp; 1&amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; …&amp;0&amp;1\\<br>b_k&amp;b_{k-1}&amp;b_{k-2}&amp;…&amp;b_2&amp;b_1\\<br>\end{bmatrix}$</p>
<p>构造起来也很简单。然后普通矩乘就好。</p>
<p>注意这里跑起来会有点慢，经过反复卡常 $+O3$ 之后本地仍然 $1.6s+.$ 开网之后在 $customtest$ 测了一下发现开 $O3 ~400ms+$，不开 $2000ms+…$ 然后交了 $O3.$ 拍了很久没错就觉得应该是满分了。</p>
<p>出分：$100pt.$</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/87Rk2K453B/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/87Rk2K453B/</a></p>
<h1 id="Dream"><a href="#Dream" class="headerlink" title="Dream"></a>Dream</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.7%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/dream.png" class title="dream">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>挺喜欢题面的。然后发现好像可以直接贪心。因为一个 $t$ 只能对应一个 $[l,~r]$，所以我们可以类似选区间的策略按左端点排序然后尽量选右端点靠左的区间和 $t$ 配对，这样区间更靠右的就有可能和后面的点配对从而有更优的答案。</p>
<p>具体实现起来就把区间按左端点排序，从小到大考虑 $t$ ，每一次首先把所有左端点小于 $t$ 的区间假如考虑中，因为后面的 $t$ 不减而我们要找最小的右端点，所以我们只需要用一个小根堆存这些区间的右端点，在找区间的时候如果堆顶比 $t$ 还要小，就直接弹出，因为它不能和 $t$ 配对就更不可能和 $t$ 后面的数配对。然后如果能配上一个就计入答案并弹出堆顶。（因为有可能一个满足的区间都没有，就是堆为空）</p>
<p>代码也很简单了。</p>
<p>出分：$100pt.$ //其实当时没想要拿满，但好像也举不出反例就交了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/n2XGdh5xkT/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/n2XGdh5xkT/</a></p>
<h1 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.7%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/tree.png" class title="tree">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>先暴力吧，就是暴力两个点然后暴力中间的点走过了一个点对没有。</p>
<p>然后觉得这个枚举另一个点的过程好像可以在搜出去的过程中解决，但是没往下想。//这个是可以的。</p>
<p>然后开始看特殊数据。</p>
<p>一条链还只有一对点的话，直接左边右边讨论。</p>
<p>菊花图的一对点的话，也可以直接讨论，这个讨论了我很一会。</p>
<p>然后由于第一题卡常卡了很久，<del>谁知道它臭氧优化那么快。。</del> 没时间了。</p>
<p>出分：$20pt.$ //可能讨论挂了吧。毕竟没有造数据看。</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>？？矩形面积并？？神奇。。</p>
<p>还是先从序列上下手的，把问题转化成求不合法的对数，这样原来的答案就是总对数减。</p>
<p>求不合法的对数的话，就是所有包括这两个点 $[l_i, <del>r_i]$ 的一个区间，这样就是要区间的左端点 $\leq l_i$，右端点 $\geq r_i$。这个东西的解集可以看成一个二维的东西，具体而言就是一个矩形，因为它就是所有满足 $x \in [1,</del>l_i],<del>y\in [r_i,</del>n]$ 的点对。这个就是一个矩形了。然后对每一个求一个并就是求矩形面积并了。</p>
<p>这是序列上的，那树上怎么办呢？那我们就在 $dfs$ 序上面考虑就好了。考虑点对 $(x,~y)$就有两种情况：</p>
<p>​    1. $(x,<del>y)$ 不是相互的祖先，那么一对答案 $(u,</del>v)$ 要满足 $u$ 在 $x$ 的子树里面，$v$ 在 $y$ 的子树里面，那么在一个 $dfs$ 序上就可以直接转化成两段区间。<br>​     2. $(x, <del>y)$ 有祖先后代关系，不妨设 $x$ 是 $y$ 的祖先，那么一对答案 $(u,</del>v)$ 要满足 $u$ 在 $y$ 的子树里面，$v$ 在整棵树除了 $y$ 所在的 $x$ 的子树里面。这个就是整个区间减一个区间，拆成两个区间即可。</p>
<p>然后就是矩形面积并了。</p>
<p>那它怎么写呢？？？</p>
<p>既然这个已经咕了很久，今天又是七夕，那就来写一下他吧。这个还是单独放在另一个博客里吧：<a href="https://the-repho.github.io/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%89%AB%E6%8F%8F%E7%BA%BF/2019/08/sol/" target="_blank" rel="noopener">矩形面积并</a></p>
<p>然后和普通的矩形面积并不同，它的坐标是比较小的，所以不需要离散化，除此之外，因为一对点就算是算面积也只能被算一次，所以要严格保证所有表示矩形区间的横坐标小于纵坐标，大于就换一下，以为换一下不影响计数。而且因为边界都要算上，所以再加矩形的时候吧终边（上边）纵坐标 $+1$ 之后再加，保证上面那条线被算到了。</p>
<p>最后用 $\frac{n\times (n-1)}{2} - cnt$ 就可以得到答案了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/BDvhkHGKDy/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/BDvhkHGKDy/</a></p>
<h6 id="七夕快乐啊！！orz…"><a href="#七夕快乐啊！！orz…" class="headerlink" title="七夕快乐啊！！orz….."></a>七夕快乐啊！！orz…..</h6>]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>8.5 模拟赛  题解</title>
    <url>/8.5%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<p>比赛地址：<a href="http://jzoj.net/senior/#contest/home/2831" target="_blank" rel="noopener">http://jzoj.net/senior/#contest/home/2831</a></p><h1 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.5%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/game.png" class title="game"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>比较简单的数学题。//没想到第二道能 $A$ 的题就在今天。</p><p>首先发现 $n, m$ 都很大就肯定要行列分开的。因为你开一个数据结构空间也肯定爆了。</p><p>分开行列的时候观察每一个点上原始的数字是什么：</p><p>第 $i$ 行 $j$ 列是 $(i - 1)\times m+j$ 这个东西好像天然把行和列分开了。</p><a id="more"></a>






<table>
    <tr>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
    <tr>
        <td>5</td>
        <td>6</td>
        <td>7</td>
        <td>8</td>
    </tr>
    <tr>
        <td>9</td>
        <td>10</td>
        <td>11</td>
        <td>12</td>
    </tr>
</table>

<p>那么我们试着把一张表拆成两张表, 其中一张表是加号前的那项, 另一张是加号后的。（这样做的另一个动机是每一列可以看做是 $m$ 的一个剩余系了。）</p>
<p>表 $1$ ：</p>
<table>
    <tr>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
    <tr>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
    <tr>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
</table>

<p>表 $2$ ：</p>
<table>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>4</td>
        <td>4</td>
        <td>4</td>
        <td>4</td>
    </tr>
    <tr>
        <td>8</td>
        <td>8</td>
        <td>8</td>
        <td>8</td>
    </tr>
</table>

<p>其实这样对应相加也能得到原始表格。那么根据乘法分配律, 所有操作可以分别对两个表进行之后求和相加即可得到原表格的答案。</p>
<p>然后发现表 $1$ 里面的每一列是相同的, 表 $2$ 中的数是相同的。所以表 $1$ 中只需要将列的修改做成一个倍数和, 从行的方向扫一遍, 并将它和行的修改以及这一列的数字一起乘起来就是结果了。表 $2$ 中同理。</p>
<p>这样的复杂度就只有 $O(n+m)$ 了, 然后 $n,m$ 同级所以就是线性的了。</p>
<p>出分：$40pt.$ 我求倍数和的时候没取模爆炸了！！！！</p>
<p>加了就 $A$ 了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/CpJXw6vXhR/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/CpJXw6vXhR/</a></p>
<h1 id="Jump"><a href="#Jump" class="headerlink" title="Jump"></a>Jump</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8.5%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/jump.png" class title="jump">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>这个。一个数好像只能向一个地方走, 那就是 $n$ 个点,  $n$ 条边, 就是一颗基环外向树啊？</p>
<p>那么一定有循环了。但是找循环应该是 $O(nm)$ 级别的, 待修改的话就起飞了。</p>
<p>那考虑修改怎么改。因为是一颗基环外向树, 那么边只可能是树边和环边了, 那分类讨论一下：</p>
<pre><code>1. 树边重新接在树上：对环（循环）没有影响直接连.
2. 树边重新接在环上：还是没有影响.
3. 环边重新接在树上：环变大了.搜一下变大的部分.
4. 环边重新接在环上：环变小了.搜一下变成树的部分.</code></pre><p>然后开始写。然后就没时间了。然后发现这样写每一次修改都要带着 $O(nm)$ 这个肯定就会爆炸了。</p>
<p>然后跟暴力拍 $1$ 个点就 $WA$ 了。细节写挂了吧。。</p>
<p>出分：$20pt.$ （交的暴力。）</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>就是高效地找循环搞循环。</p>
<p>因为循环是 $O(nm)$ 的而且每跳过 $n$ 步所在的一列是重复的。所以我们分块一下, 每一块的长度是 $L =\min (n, m)$ , （这个东西如果 $m$ 比 $n$ 大手动交换它们。）每一次一大块一大块地跳来找循环节, 不在大块顶点就暴力跳。这样找循环的复杂度就是 $O(L).$ 然后一个小优化就是只需要在修改后的第一次查询处找一次循环节。</p>
<p>那修改操作呢。修改操作应该是会去有可能改到前三个点的范围内的答案的, 然后我们分别看每一个点, 首先看它改到了哪一个点, 先从那个点往后跳跳到块地端点上, 然后向前跳, 向前跳发现可能前面的几个数都跳到这里了, 那么发现我们可以从中间向外扩展, 每次只考虑上下界的转移, 因为中间的只能看到后面三个包含在我们考虑区间内的, 一定能走到后面的点上的。（如果连第一行都走不到就不用更新了。）</p>
<p>但是他有一个 $3$ 的常数？//其实我怎么看这个都会 $T…$</p>
<p>$code: $ </p>
<h3 id="原题。？"><a href="#原题。？" class="headerlink" title="原题。？"></a>原题。？</h3><p>$luogu$ 原题链接：[<a href="https://www.luogu.org/problem/P4739]（它开" target="_blank" rel="noopener">https://www.luogu.org/problem/P4739]（它开</a> $8s$ 比赛开 $4s$ ？）</p>
<p>[<a href="https://www.luogu.org/problem/P4739]" target="_blank" rel="noopener">https://www.luogu.org/problem/P4739]</a> :<a href="https://www.luogu.org/problem/P4739" target="_blank" rel="noopener">https://www.luogu.org/problem/P4739</a></p>
<h1 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8.5%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/sequence.png" class title="sequence">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>想着用线段树 $Hash$ , （我傻啊又没有重复。。）写了 $WA$ 掉了的暴力。//没时间了。。</p>
<p>出分：$0pt…$</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><h4 id="80pt-100pt-的卡常线段树-ST-表"><a href="#80pt-100pt-的卡常线段树-ST-表" class="headerlink" title="$80pt.$$100pt.$ 的卡常线段树 $/ ST$表"></a>$80pt.$<del>$100pt.$ 的卡常线段树 $/</del> ST$表</h4><p>因为要是一段优美的序列 $a_{i…j}$, 里面的就需要是 $[<del>\min_{i…j},</del>\max_{i…j}~]$ 中的所有数都要包含在内的, 就是说</p>
<p> $[<del>\min_{i…j},</del>\max_{i…j}~]$ 中即使是最左边和最右边的数都要在这个范围内, 因为他已经天然离散化了, 所以可以根据一个数字出现的位置得到一个新序列, 而优美的序列就是说两个序列的长度是一样的。这样通过反复地来回映射就可以找到一个最短的包含自己的序列了。（因为每一次映射都是一个必须满足的条件得到的一个新区间, 而区间长度递增, 所以第一次的就是最短的。）</p>
<p>$eg.$<br>$\quad A~=\{ 3,1,7,5,6,4,2\}\\<br>\quad A’=\{ 2,7, 1,6,4,5,3\}$<br>那么例如 $[3, 6]$ 就是一段优美的序列, 因为 $A$ 序列中的最大最小值对应区间 $[4,7]$ 长度和原序列中的 $[3,6]$ 长度都是 $4.$</p>
<p>那么我们就是需要查询两个序列的区间最值, 线段树 $/~ST$ 表, 因为线段树查询带 $log$ 而且常数大, $ST$ 表肯定就是更好的选择。</p>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>没人会。。题解讲的好像很随意。网上说得好像用线段树扫描线？</p>
<h4 id="严格-log-的线段树"><a href="#严格-log-的线段树" class="headerlink" title="严格 $log$ 的线段树"></a>严格 $log$ 的线段树</h4><p>考虑一个优美序列满足什么样的性质。首先它肯定是由连续数字组成的。（废话那是定义。）</p>
<p>称每两个连续数字是一个连续数对的话，那么对于一个优美序列而言就有：</p>
<p>$l+num=r ~IFF ~a_{l,…,r}是一个优美序列$.（其中 $num$ 是连续数对个数） </p>
<p>证明的话这个东西显然的：排好序之后是从 $Min$ 到 $Max$ 的一个连续序列, 中间自然就有 $r-l$ 个连续数对了, 逆命题同理。</p>
<p>然后我们考虑怎么维护这个信息。可以首先考虑把询问离线下来并从左往右考虑右端点 $i$ 框定包含询问的右端点的优美序列。 这样首先可以保证右边的 $r$ 是一个有序的。</p>
<p> 然后考虑每一次来到一个右端点 $r$ 的时候考虑用它所组成的连续数对更新能够成立的等式左边就可以了。这样的话首先考虑每个点初始就会有一个自己位置的值 $pos.$ 然后通过后面和它后面的数（包括它）构成的连续点对更新自己的值以得到答案。那么每次的右端点更新左边的值就是更新一个前缀和，那么区间加。</p>
<p>再考虑怎么得到答案。每次需要的是最右边的一个在询问的左端点左边的点，那么怎么保证呢？观察式子的左边，发现这个东西每一次可能受到 $+0,<del>+1,</del>+2$ 三种影响，这个不太好处理，而考虑到每一次右边是肯定会 $+1$ 的，所以我们考虑改变的差值。差值就只可能 $-1,<del>+0,</del>+1$ 因为 $num$ 初始为 $0$ 时左边是小于右边的，而每次 $+1$ 就又可以保证这个差值是一个一个缩小的，所以如果出现了答案，这个值一定是整个前缀中最大的之一。那么区间最大值。</p>
<p>区间加 $+$ 区间最大值：线段树。 $\rightarrow$ 严格 $O(n\log n)$ 算法。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/WgP6sm3MQH/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/WgP6sm3MQH/</a></p>
<h3 id="原题。？？"><a href="#原题。？？" class="headerlink" title="原题。？？"></a>原题。？？</h3><p>$luogu$ 原题链接：<a href="https://www.luogu.org/problem/P4747" target="_blank" rel="noopener">https://www.luogu.org/problem/P4747</a>（它开 $3s$ 比赛开 $1s$ ？？？）</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>线段树</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>8.4 模拟赛  题解</title>
    <url>/8.4%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/</url>
    <content><![CDATA[<p>比赛地址：<a href="http://jzoj.net/senior/#contest/home/2827" target="_blank" rel="noopener">http://jzoj.net/senior/#contest/home/2827</a></p><h1 id="Forging"><a href="#Forging" class="headerlink" title="Forging"></a>Forging</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8.4%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/2019/11/sol/forging.png" class title="forging"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>本来可以第一次考场上 $A$ 题，结果卡空间！我开了 $ll$ 就炸了！$int$ 就过了！而且他还卡常数。。（我 用 $cout$ 他最后一个点就 $T$ 了。）//终于可以考场正解一起写了。</p><a id="more"></a>



<p>首先理解一下题意，就是两个相邻级别的剑合在一起，有 $p$ 的概率成功合成更高一级的剑，有 $1 - p$ 的概率变成较低级别的剑，就相当于较高的剑没了。发现这个东西 $DP$ 是搞不定的，因为他有后效性而且还要有一个无穷的极限。这个就好像就要推式子。？</p>
<p>先看看部分分吧：</p>
<h4 id="特殊性质？-p-1-？"><a href="#特殊性质？-p-1-？" class="headerlink" title="特殊性质？$p = 1$？"></a>特殊性质？$p = 1$？</h4><p>那概率不就是 $1$ ？好了 $40pt.$ 到手，直接递推 $f_i = f_{i - 1} + f_{i - 2}.$</p>
<h4 id="n-0-？"><a href="#n-0-？" class="headerlink" title="$n = 0$？"></a>$n = 0$？</h4><p>那不就是 $a$ 吗。</p>
<h4 id="n-1-？"><a href="#n-1-？" class="headerlink" title="$n=1$？"></a>$n=1$？</h4><p>好像就必须推式子了。先试试吧。</p>
<p>​            $f_0=a+(1-p)a+(1-p)^2a+(a-p)^3a…$ //解释一下就是直接到自己，失败一次回到自己，失败两次….直到无穷。</p>
<p>$&lt;=&gt;   f_0 = \sum_{i = 0}^{\infin}(1-p)^ia$</p>
<p>$&lt;=&gt;   f_0 = \frac{a}{p}$ </p>
<p>这个就很好看了。</p>
<p>然后同样的考虑 $f_1=a+\frac{a}{p}$ 因为有 $1-p$ 的概率要损失一个所以类似上面的一个求和可以得到这个式子。那这个部分分就好了。</p>
<h4 id="n-leq1e7-？"><a href="#n-leq1e7-？" class="headerlink" title="$n\leq1e7$？"></a>$n\leq1e7$？</h4><p>这个由上面的推导就容易了。可以类似的发现这个式子：$f_i=f_{i - 2}+\frac{f_{i - 1}}{p}.$ 因为损失的是上一个。</p>
<p>然后就可以递推了。但是 $1e7$？逆元要线性推了。</p>
<p><strong>但是：</strong></p>
<p>出分：$0pt…MLE…$ 空间！不能开 $long long!$ 不能开 $long long!$ 不能开 $long long!$ 开了就炸了！</p>
<p>其实时间也要卡一卡不过还好。//比下一题好多了。。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/4Rr2YVXMZS/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/4Rr2YVXMZS/</a></p>
<h1 id="Division"><a href="#Division" class="headerlink" title="Division"></a>Division</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3>

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>看完题发现看数据范围可能可以分一个一个质因数来做，但是怎么合起来呢？岂不是要求一个并？？不知道。先看看部分分吧。</p>
<p>前四个点好像可以直接暴力。（其实第三个点数据太多了 $A$ 不掉，而且第二个点也没过。）</p>
<p>第五个点？$n==2$ ？手动因式分解发现只可能有两个，然后手动讨论情况。然后 $WA$ 了。。</p>
<p>出分：$20pt.$ </p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>没错！就是一个一个做再合起来。这里考虑一下一个叫中国剩余定理的东西来看怎么合。</p>
<p>中国剩余定理说的是：如果有若干个互质的数为模的同余方程的话，他们的通解可以表示每个同余方程的解乘上其他所有的数除自己模数外的模数之积和其逆元，再加上若干倍的所有模数之积。</p>
<p>代数表示如下：</p>
<p>​    对于 $c$ 个同余方程：</p>
<p>​    $\Large (S)=<br>\begin{cases}<br>x\equiv a_1(\mod p_1)\\<br>x\equiv a_2(\mod p_2)\ \quad.\\\quad.\\\quad.\\x\equiv a_c(\mod p_c)\\<br>\end{cases}$</p>
<p>​    满足 $gcd(p_1, p_2,…,p_n)=1$ 则有：</p>
<p>​    记 $P=\prod p, \quad P_i=\frac{P}{p_i},\quad inv_i\times P_i\equiv 1(\mod p_i)$ 则：</p>
<p>​    通解为：$X=\sum_{i = 1}^{c} a_iP_iinv_i+kP$     </p>
<p>为什么呢？可以考虑上面的 $X$ 的每一项 $i.$ 把包含 $a_i$ 的一项分离出来的话，其他项里面是有一个 $P_j$ 的，它里面一定包含了 $p_i$ 所以被 $p_i$ 整除。而 $a_i$ 这一项本身是余 $a_i$ 的，因为 $P_iinv_i$ 再模 $p_i$ 意义下是 $1$ 所以方程就成立了。</p>
<p> 这个有什么用吗？当然。考虑用我们的每个方程替换上面的方程，那么解就一定能够用下面的通式表示。每一个解都可以去表示，而我们每一个方程可以算出来有 $cnt_i$ 个解，那么乘法原理答案就是 $\prod cnt$ 了。好了！解决了！</p>
<p>那么就一个一个暴力试吧。还有一个问题，因为数据有 $50$ 组并且每组复杂度 $5e5$ 总的就是 $2.5e7$ 但是我们还要求一个 $x^m$ 呢？快速幂就直接 $T$ 了啊。。怎么解决？</p>
<p>一个新的神奇的东西：线性（欧拉）筛。</p>
<p>这个东西可以解决几乎所有积性函数的线性求前 $k$ 项的值。怎么做的呢？</p>
<p>类似很久以前学的筛素数的欧拉筛，就是每个数再最小质因子的地方被标记。那这个的意思呢？就是每个数对应的积性函数值再最小质因子的地方被计算！这样就只需要再所有质数的地方计算一次值，其他地方直接用之前的和最小质因子更新就好了。</p>
<p>具体实现很简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; val; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!book[j])</span><br><span class="line">        pr[++cnt] = j, f[j] = cal(j);<span class="comment">//在质数的地方计算一下。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt &amp;&amp; j * pr[k] &lt;= val; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j * pr[k]] = f[j] * f[pr[k]];<span class="comment">//其他地方直接乘起来，因为是积性函数。</span></span><br><span class="line">        <span class="keyword">if</span> (j % pr[k] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后还是要卡常。往死里卡。再加 $O2,O3$ 优化。然后经过 $12$ 次的卡常 $+$ 调试终于 $A$ 了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/3fqt7SGcQn/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/3fqt7SGcQn/</a></p>
<h1 id="Money"><a href="#Money" class="headerlink" title="Money"></a>Money</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3>

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>一看。哎呀不是 $LCT$ 吗？哎呀没学过。看部分分。</p>
<p>$10pt.$ 直接暴力。</p>
<p>$30pt.$ 直接暴力 $+$ 倍增。</p>
<p>后面就不会了。</p>
<p>然后倍增没调出来。</p>
<p>出分：$10pt.$ </p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>没错就是 $LCT.$ // $log^2$ 的</p>
<p>但是其实还有倍增的做法可以 $A$ 掉。//还能一个 $log$ ！？</p>
<p>咕。</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>线性筛</tag>
        <tag>中国剩余定理</tag>
        <tag>lct</tag>
      </tags>
  </entry>
  <entry>
    <title>8.2 模拟赛  题解</title>
    <url>/8-2-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/2019/08/sol/</url>
    <content><![CDATA[<p>比赛地址：<a href="http://jzoj.net/senior/#contest/home/2825" target="_blank" rel="noopener">http://jzoj.net/senior/#contest/home/2825</a></p><h1 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8-2-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/2019/08/sol/Attack.png" class title="Attack"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>点开发现第一题就是一个数据结构。然后既是二维的还是一个求第 $k$ 小还是一个待修改的，那岂不是要一个四维的数据结构来弄。？</p><p>先想了想用二维线段树套树，然后发现以前连二维线段树都没写过瞬间放弃了。</p><a id="more"></a>




<p>然后打了个暴力。</p>
<p>出分：我暴力打错了挂成一个小数。//出题人手抖把时限开成了 $10s$ 让暴力能 $A$ 当然要优美一些的暴力。。</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>其实就用暴力吧。一个优化就是不是每次询问的时候根据值排序，而是预先排好序之后去顺序选，就能保证递增了。这个可以做到严格 $O(nm)$ 但是修改可能做不到 $O(1)$ 了。</p>
<p>标准复杂度的东西题解上是划分树可以学学。或者是一个什么整体二分加树套树。。//有时间的话。。</p>
<p>$code: $ </p>
<p>​    暴力：<a href="https://paste.ubuntu.com/p/trfdZHK8YY/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/trfdZHK8YY/</a></p>
<h1 id="Bomb"><a href="#Bomb" class="headerlink" title="Bomb"></a>Bomb</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8-2-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/2019/08/sol/Bomb.png" class title="Bomb">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>主要写这题了。<del>还花了几乎所有时间在一个很简单的问题上。。</del></p>
<p>先考虑三个点的曼哈顿距离是什么。可以发现就是包住他们的一个矩形的周长。而一定有一个点在定点上。（另一个点可能也在，但是没关系。。）然后记录一个横纵坐标的前后缀最大最小值就可以了。（有 $8$ 个。。）</p>
<p>最小值参考平面最近点对。但是正确性有问题。因为不能用前后 $6$ 个数的优化了。这个直接用答案框范围的话直接 $T$ 。然后卡时限吧。最多就能卡到 $70pt.$了。</p>
<p>出分：$70/100$  $WA$ 了 $30$ 的是正确性。（是有人用分治 $A$ 掉的，后面具体说。）</p>
<p>为了纪念这里贴一下最大值的代码：（自动忽略最小值部分就好）</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/PMbm6Pknm3/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/PMbm6Pknm3/</a></p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>首先看最大值。最大值可以有正确的贪心。考虑 $8$ 个特殊点，就是八个角上的点。（类似一个正八边形）</p>
<p>但是我不会证。所以还是用我上面那个 $O(n)$ 的贪心做也是可以的。虽然很麻烦。</p>
<p>然后是最小值。有<del>两</del>一种方法：线段树。<del>乱搞贪心</del></p>
<h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>分别以 $x+y$ 和 $|x - y|$ 为关键字排序，取后 $10$ 个来查找。但是会被一个算法卡掉：网格图。一个转了 $45^{\circ} $ 的正方形。</p>
<p>怎么办呢。可以以 $x$ 为第一关键字，$y$ 为第二关键字排一遍做一遍就可以了。</p>
<p>但其实还是只有 $95pt.$ 因为出题人可能真的故意卡了。可能就只能拿到这么多分了吧。<del>先面向数据过了它再说。</del></p>
<p>其实有一种万全的策略：以这个点为中心的一个转了 $45^{\circ} $ 的正方形。但是查出来它可能复杂度高了。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/tqbRYFPjHV/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/tqbRYFPjHV/</a></p>
<h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>这个是正解了。</p>
<p>题解里面的就是。和第一题一样有时间打吧。</p>
<h4 id="优秀的分治"><a href="#优秀的分治" class="headerlink" title="优秀的分治"></a>优秀的分治</h4><p>这里其实就是我考场上的类似做法。但是更优秀。</p>
<p>首先我们拿出来保证 $|p[i].x-p[mid].x|&lt;ans$ 的所有 $i$ 然后考虑怎么优化一个顺序能够更快速的求值？</p>
<p>因为一个点还有 $y$ 的一维，所以就可以给 $y$ 排个序，然后每一次保证选的点的 $y$ 值在 $[p[i].y - ans, p[i].y]$ 里面就好了，其中 $p[i].y$ 是最右边的那个点。</p>
<p>就可以 $A$ 了！</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/sMfKgftmdd/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/sMfKgftmdd/</a></p>
<h1 id="Contra"><a href="#Contra" class="headerlink" title="Contra"></a>Contra</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8-2-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/2019/08/sol/Contra.png" class title="Contra">

<h3 id="考场-2"><a href="#考场-2" class="headerlink" title="考场"></a>考场</h3><p>想了想这个 $p$ 可以二分答案啊。然后概率 $dp$？然后想了一会没想出方程来，就放弃掉了。</p>
<p><del>主要原因其实是第二题看起来很可做就去肝它了</del></p>
<p>出分：没提交。</p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>$aaa…$就是二分答案。没事，然后就是一个普通的 $dp$ 吧。这里首先想到的是可以用期望直接 $dp$ 的。但是可以发现他求的是一个分数和，这个就可以不用做一个部分的期望了，就可以直接把每一步的累加到最后的答案里面。具体就是：</p>
<p>$\Large dp_{i + 1, j + 1, k + 1} += p \times dp_{i, j, k}$</p>
<p>$\Large dp_{i + 1, j - 1, 0}+=(1 - p) \times dp_{i, j, k}$</p>
<p>$\Large Ans += dp_{i, j, k} \times p \times (j + 1)$</p>
<p><del>然后我调了近乎3，4个小时没跳出来。$orz…$我不调了我直接上矩乘。。</del></p>
<p>这个东西就是一个直接从第 $i$ 层转移到第 $i + 1$ 层的方程了，考虑建一个转移矩阵。</p>
<p>先把状态压起来压成一列（$Q \times R+1$，最后一列存答案）。</p>
<p>然后考虑转移方程。这个肯定就是一个 $(Q \times R+1) \times (Q \times R+1)$ 的矩阵了。这个玩意里面就是上面的方程，然后就是在 $dp_{i, j, k}$ 的地方换成 $1$ 就好了。因为是要矩乘的。就可以直接快速幂了。 然后其实初始状态所在的那一行的答案了。(整个矩阵 $Matrix_{S1, S2}$ 的意思就是从 状态 $S1$ 转移乘出来的多少步之后到达 $S2$的概率，然后最后一行也就是期望) 就差不多了。</p>
<p>这里需要注意以下几个细节点：</p>
<ol>
<li>初始化的时候在注意 $Matrix_{i,i}=1.$ 因为这个状态转化成自己本身的概率就是 $1.$</li>
<li>最开始的初始矩阵需要注意 $Matrix_{cnt, cnt} = 1.$ 因为所有的答案是要累加在一起的，所以 $cnt$ 的地方应该每次继承。</li>
<li>时间优化：<ol>
<li>忽略到一些不存在的答案的转移。比如 $Matrix_{i, j} = 0$ 的时候就不要去算了。</li>
<li>考虑 $ikj$ 优化，就是先枚举 $i$ 再 $k$ 再 $j$ 这样可以顺便把 $a_{i, k}=0$ 的时候过滤掉（上面那个）可以拿掉一层循环的复杂度。</li>
<li>精度问题。必须开到 $1e-11$ 才能过所有点。实际上可以卡时限开满。</li>
</ol>
</li>
</ol>
<p>然后就<del>终于</del>可以 $A$ 了。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/S8WYHmxcRz/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/S8WYHmxcRz/</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>贪心</tag>
        <tag>分治</tag>
        <tag>线段树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>8.1 模拟赛  题解</title>
    <url>/8-1-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/2019/08/sol/</url>
    <content><![CDATA[<p>比赛地址：<a href="http://jzoj.net/senior/#contest/home/2821" target="_blank" rel="noopener">http://jzoj.net/senior/#contest/home/2821</a></p><h1 id="水叮当的舞步"><a href="#水叮当的舞步" class="headerlink" title="水叮当的舞步"></a>水叮当的舞步</h1><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><img src="/8-1-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/2019/08/sol/dance.png" class title="dance"><h3 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h3><p>这个名字好熟悉。？</p><p>贪心一下？直接看看左上角所在的联通块外接的颜色中最多的然后去改那种颜色？先写了出来，发现不是一点难写。</p><p>手造数据发现好像贪心有问题。那么看外接颜色中联通块内个数之和最多的去改？发现过了手玩的样例。</p><a id="more"></a>





<p>感觉可以$A$于是开始看后面的题。//打个暴力都好。$orz..$</p>
<p>出分：$0pt..$ 多测清零之后$10pt.$ </p>
<p>贪心错了。$orz.$.</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>搜索优化。。</p>
<p>首先最朴素的搜索：直接搜每一次跳什么颜色。</p>
<p>然后剪枝：</p>
<ol>
<li>迭代加深，就是搜1层，2层…慢慢地搜下去。</li>
<li>如果剩下的部分中不同的颜色个数加上现在已经进行的操作个数已经超过了现在搜的层数直接减掉。</li>
</ol>
<p>这样就可以$A$了。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/DXr5JSwKqd/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/DXr5JSwKqd/</a></p>
<h1 id="Vani和Cl2捉迷藏"><a href="#Vani和Cl2捉迷藏" class="headerlink" title="Vani和Cl2捉迷藏"></a>Vani和Cl2捉迷藏</h1><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><img src="/8-1-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/2019/08/sol/game.jpg" class title="game">

<p>那么就是要求一个一般图的最大独立集。NP问题啊。。。</p>
<p>只能过20pt.的点。正解估计是什么神仙做法了。</p>
<p>出分：因为看错题爆零。</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><p>好的，他就是一个$DAG$然后那个互相望到的意思是一条路径上的前面的点可以看到后面的所有点。那就是在$DAG$上的最大独立集了。然后就可以拆成入点和出点，做一个最小路径覆盖数 $cnt$（就是最大匹配数），然后直接用 $n - cnt$ 就可以了。</p>
<p>二分图求一个最大匹配数直接匈牙利或者 $dinic$ 就可以了。//这是最简单的一题。。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/RzNnpvkqdZ/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/RzNnpvkqdZ/</a></p>
<h1 id="粉刷匠"><a href="#粉刷匠" class="headerlink" title="粉刷匠"></a>粉刷匠</h1><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><img src="/8-1-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/2019/08/sol/paint.png" class title="paint">

<h3 id="考场-1"><a href="#考场-1" class="headerlink" title="考场"></a>考场</h3><p>容斥？不太行。暴力吧。看起来可以$dp$然后想了好久发现最朴素的dp都要爆炸然后放弃了。</p>
<p>出分：暴力又没清零$40pt =&gt; 30pt..$</p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><p>两个老师讲了两种，下面分别介绍。</p>
<h4 id="两维比较简单的DP"><a href="#两维比较简单的DP" class="headerlink" title="两维比较简单的DP"></a>两维比较简单的DP</h4><p>考虑 $dp_{i, j}$ 表示已经选好了前 $i$ 种颜色，其中有 $j$ 对相邻的同色。</p>
<p>然后考虑转移，现在考虑怎么转移到 $dp_{i+1}$上去。首先需要把 $c_{i+1}$ 个桶分成 $k$ 组，然后再把这 $k$ 组插到前面的 $\sum_{a=1}^{i}c_{a}$ 的空里面。然后因为可能插进去之后把相邻同色的给破坏了，因此需要枚举一个 $t$ 表示有 $t$ 个相邻同色被破坏了。那么转移方程就可以写出来了：</p>
<p>$\Large dp_{i + 1, j + c_{i+1}-k-t} +=dp_{i, j} \times C_{c_{i+1}}^k \times C_k^t \times C_j^t $</p>
<p>然后就可以 $A$ 掉了。这个调起来是有点恶心的。</p>
<p>$code: $ <a href="https://paste.ubuntu.com/p/HWJrPTG566/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/HWJrPTG566/</a></p>
<h4 id="七维很暴力的DP"><a href="#七维很暴力的DP" class="headerlink" title="七维很暴力的DP"></a>七维很暴力的DP</h4><p>先咕吧。。</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>二分图匹配</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树扫描线</title>
    <url>/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%89%AB%E6%8F%8F%E7%BA%BF/2019/08/sol/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>线段树扫描线算法准确的来说就是用线段树维护在一个二维空间中的一根和 $x$ 轴平行线上的信息（$y$ 轴同理），通过把这跟扫描线从下向上扫一遍，就能得到二维平面上的一些信息。</p><p>而因为维护的是一个水平的直线，所以一般就是求矩形相关的信息了。</p><p>由于矩形有一个固定范围，因此我们一般将它分成上下边两个区间，一个加上操作，另一个消除操作。这样在中间算上这个矩形的贡献就可以了。下文称这些直线（区间）为关键直线，因为只有这里可能让线上的信息变化。</p><a id="more"></a>


<p>至于具体的维护什么信息就因题目而异了。</p>
<p>时间复杂度就是线段树的 $\log$ 加上离散化的二分 $log$，总的还是 $O(n\log n)$ 的。</p>
<p>最典型的例题就是矩形面积并了。</p>
<hr>
<h1 id="矩形面积并"><a href="#矩形面积并" class="headerlink" title="矩形面积并"></a>矩形面积并</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1542" target="_blank" rel="noopener">Atlantis</a></p>
<p>题面上的数据很小，但用线段树做扫描线是 $O(n\log n)$ 复杂度的。</p>
<p>我们想用一条线从下向上扫一遍来求矩形面积并，我们考虑每条关键直线怎么更新答案。因为求的是面积，所以要考虑的是两条直线之间的答案。因为是求所有矩形的面积并，所以每次两条关键直线之间的面积一定是若干个宽是两条直线之间距离的矩形面积之和，就维护每一次的长有多少与宽相乘即可。由于坐标是实数，先离散化，然后用线段树维护直线上被覆盖的区间长度即可。这个将矩形下边记为 $+1$，下边记为 $-1.$ </p>
<p>这里可以用到一个技巧：不把标记下放，因为每一个区间的加上后是会被整体减去的。因此是否被覆盖可以只考虑着一个点是否被整体覆盖，若没有则看两个儿子。另外，因为是区间长度，所以需要记录的不是点而是区间，所以把每个区间右边的区间信息弄在左端点上即可。</p>
<p>//注意实数啊，$lower_bound$ 找离散化也要开 $double..$ </p>
<p>$code : $ <a href="https://paste.ubuntu.com/p/m4nyPVfvvK/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/m4nyPVfvvK/</a></p>
<hr>
<p>除此之外用于维护扫描线上的其他信息也是可以的，比如最大值。</p>
<h1 id="最大-矩形权值交之和"><a href="#最大-矩形权值交之和" class="headerlink" title="最大 矩形权值交之和"></a>最大 矩形权值交之和</h1><p><a href="https://www.luogu.org/problem/P1502" target="_blank" rel="noopener">窗口的星星</a></p>
<p>首先因为窗口大小是固定的，那么考虑一颗星星在窗口中的位置（如果被选中），那么他一定会在 $w\times h$ 的矩形内部，因此如果固定一颗星星在一个窗口的左下角，计算这个窗口内的所有部分的最大值（每个位置初始值是自己的值，其他星星的窗口交过来了就加上那颗星星的值）就是包含这个星星的最佳答案了。</p>
<p>那么我们就是要维护一个矩形内的交的部分的和，然后求最大值。</p>
<p>还是一样，考虑用一条扫描线，每一次拓展到一条矩形边的时候直接区间加它的权值，然后拓展完的时候求最大值。因为坐标还是很大所以还是要离散化。</p>
<p>注意，在以纵坐标排序的同时，需要保证一条线上先加再减，不然可能把答案给减没了。</p>
<p>$code:$ <a href="https://paste.ubuntu.com/p/6BxXC5T34B/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/6BxXC5T34B/</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>这里列举一下出现的方法吧。</p>
<ul>
<li>矩形内点数和</li>
<li>矩形面积交</li>
<li>矩形外周长</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>维护区间不同颜色</title>
    <url>/%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E4%B8%8D%E5%90%8C%E9%A2%9C%E8%89%B2/2019/07/sol/</url>
    <content><![CDATA[<p>其实就是这道题：<a href="https://www.luogu.org/problemnew/show/P1972" target="_blank" rel="noopener">HH的项链</a></p><hr><p>离线转化成一个单点修改区间查询的问题。这样就可以用线段树或者树状数组做了。//用树状数组简单多了。。</p><p>先把所有询问以右端点排序，然后慢慢向后解决。</p><p>记录一下每个颜色最后出现在的地方，然后如果这个地方又出现了那种颜色的话，就把之前那个地方的颜色抹掉，然后在这里记上这种颜色，在更新表示每个颜色最后出现的数组。</p><a id="more"></a>




<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO 600100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MO 1000005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//by Oliver</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">' '</span>, last;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)</span><br><span class="line">        last = ch, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        ans = ans * <span class="number">10</span> + <span class="keyword">int</span>(ch - <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="string">'-'</span>)</span><br><span class="line">        <span class="keyword">return</span> -ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[NO], m, d[NO], last[MO];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> L, R, pos, ans;</span><br><span class="line">&#125;asks[NO];</span><br><span class="line"><span class="comment">//variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt;= n; i += lowbit(i))</span><br><span class="line">        d[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i; i -= lowbit(i))</span><br><span class="line">        ans += d[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(node i, node j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.R &lt; j.R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(node i, node j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.pos &lt; j.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = read();</span><br><span class="line">    m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=m; i++)</span><br><span class="line">        asks[i].L = read(), asks[i].R = read(), asks[i].pos = i;</span><br><span class="line">    sort(asks + <span class="number">1</span>, asks + m + <span class="number">1</span>, cmp1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//functions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">memset</span>(last, <span class="number">0</span>, <span class="keyword">sizeof</span>(last));</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(; now &lt;= asks[i].R; now++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(last[a[now]])</span><br><span class="line">                add(<span class="number">-1</span>, last[a[now]]);</span><br><span class="line">            add(<span class="number">1</span>, now), last[a[now]] = now;</span><br><span class="line">        &#125;</span><br><span class="line">        asks[i].ans = ask(asks[i].R) - ask(asks[i].L - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(asks + <span class="number">1</span>, asks + m + <span class="number">1</span>, cmp2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; asks[i].ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main</span></span><br></pre></td></tr></table></figure>

<hr>
<p>其实这题应该还可以用一些其他方法做(莫队之类的)。但是其实是卡不过去的，（最好成绩也只有90pt..）</p>
<p>然后这种思路还可以去维护不止数量不少于$2$个的颜色数量等等。//一道贪心模拟赛上的题。</p>
<p>此外好像也可以用主席树做。学了更。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>head</title>
    <url>/head/2019/07/sol/</url>
    <content><![CDATA[<p>保存于此，以便在外机登陆时取用。</p><p>另，需使用线段树时或其他定义时可自行修改，以免引起歧义而编译错误，这里不以添加。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize (2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO 30005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MO 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lln putchar(<span class="meta-string">'\n'</span>)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">' '</span>, last;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)</span><br><span class="line">        last = ch, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        ans = ans * <span class="number">10</span> + <span class="keyword">int</span>(ch - <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="string">'-'</span>)</span><br><span class="line">        <span class="keyword">return</span> -ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>)</span><br><span class="line">        write(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//functions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
</search>
