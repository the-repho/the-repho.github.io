<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[维护区间不同颜色]]></title>
    <url>%2F2019%2F07%2F22%2F%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E4%B8%8D%E5%90%8C%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[其实就是这道题：[P1972 [SDOI2009]HH的项链](https://www.luogu.org/problemnew/show/P1972) 离线转化成一个单点修改区间查询的问题。这样就可以用线段树或者树状数组做了。//用树状数组简单多了。。 先把所有询问以右端点排序，然后慢慢向后解决。 记录一下每个颜色最后出现在的地方，然后如果这个地方又出现了那种颜色的话，就把之前那个地方的颜色抹掉，然后在这里记上这种颜色，在更新表示每个颜色最后出现的数组。 code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define NO 600100#define MO 1000005typedef long long ll;//by Oliverusing namespace std;ll read()&#123; char ch = ' ', last; ll ans = 0; while (ch &lt; '0' || ch &gt; '9') last = ch, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') ans = ans * 10 + int(ch - '0'), ch = getchar(); if (last == '-') return -ans; return ans;&#125;//headint n, a[NO], m, d[NO], last[MO];struct node&#123; int L, R, pos, ans;&#125;asks[NO];//variableint lowbit(int x)&#123; return x &amp; -x;&#125;void add(int val, int pos)&#123; for(int i = pos; i &lt;= n; i += lowbit(i)) d[i] += val;&#125;int ask(int pos)&#123; int ans = 0; for(int i = pos; i; i -= lowbit(i)) ans += d[i]; return ans;&#125;bool cmp1(node i, node j)&#123; return i.R &lt; j.R;&#125;bool cmp2(node i, node j)&#123; return i.pos &lt; j.pos;&#125;void init()&#123; n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); m = read(); for(int i = 1; i &lt;=m; i++) asks[i].L = read(), asks[i].R = read(), asks[i].pos = i; sort(asks + 1, asks + m + 1, cmp1);&#125;//functionsint main()&#123; init(); memset(last, 0, sizeof(last)); int now = 1; for(int i = 1; i &lt;= m; i++) &#123; for(; now &lt;= asks[i].R; now++) &#123; if(last[a[now]]) add(-1, last[a[now]]); add(1, now), last[a[now]] = now; &#125; asks[i].ans = ask(asks[i].R) - ask(asks[i].L - 1); &#125; sort(asks + 1, asks + m + 1, cmp2); for(int i = 1; i &lt;= m; i++) cout &lt;&lt; asks[i].ans &lt;&lt; endl; return 0;&#125;//main 其实这题应该还可以用一些其他方法做(莫队之类的)。但是其实是卡不过去的，（最好成绩也只有90pt..） 然后这种思路还可以去维护不止数量不少于$2$个的颜色数量等等。//一道贪心模拟赛上的题。 此外好像也可以用主席树做。学了更。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-树状数组 -离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[head]]></title>
    <url>%2F2019%2F07%2F22%2Fhead%2F</url>
    <content type="text"><![CDATA[保存于此，以便在外机登陆时取用。 另，需使用线段树时或其他定义时可自行修改，以免引起歧义而编译错误，这里不以添加。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#pragma G++ optimize (2)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define INF 0x3f3f3f3f#define NO 30005#define MO 100005#define mp(x, y) make_pair(x, y)#define fi first#define se second#define lln putchar('\n')typedef long long ll;typedef double db;using namespace std;typedef pair&lt;int, int&gt; pii;inline ll read()&#123; char ch = ' ', last; ll ans = 0; while (ch &lt; '0' || ch &gt; '9') last = ch, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') ans = ans * 10 + int(ch - '0'), ch = getchar(); if (last == '-') return -ans; return ans;&#125;void write(ll x)&#123; if (x &gt;= 10) write(x / 10); putchar(x % 10 + '0');&#125;//head//variablevoid init()&#123; &#125;//functionsint main()&#123; init(); return 0;&#125;//main]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
</search>
